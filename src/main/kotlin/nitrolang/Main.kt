package nitrolang

import nitrolang.ast.DeadCodeAnalyzer
import nitrolang.ast.LstLambdaInit
import nitrolang.ast.LstProgram
import nitrolang.backend.ConstString
import nitrolang.backend.wasm.WasmBuilder
import nitrolang.parsing.ANNOTATION_EXTERN
import nitrolang.parsing.AstParser
import nitrolang.typeinference.TType
import nitrolang.util.Prof
import nitrolang.util.SourceFile
import java.io.File
import java.nio.file.*
import java.time.Instant
import kotlin.io.path.absolute
import kotlin.io.path.isRegularFile
import kotlin.io.path.name


fun main(args: Array<String>) {
    val opts = CompilerOptions.fromArgs(args)
    if (opts == null) {
        CompilerOptions.showUsage()
        return
    }

    try {
        if (compile(opts) && opts.execute) {
            execute(File(opts.output))
        }
    } catch (e: Throwable) {
        e.printStackTrace()
    }

    // Listen to changes
    if (opts.listenChanges.isNotEmpty()) {
        val paths: MutableList<Path> = mutableListOf(
            File(opts.source).absoluteFile.parentFile.toPath()
        )
        opts.listenChanges.forEach {
            paths.add(File(it).toPath())
        }

        watchFolderForChanges(paths) {
            val fileName = it.fileName.toString()

            if (!fileName.endsWith(".nitro") && !fileName.endsWith(".ts") && !fileName.endsWith(".js")) {
                return@watchFolderForChanges
            }

            try {
                if (compile(opts) && opts.execute) {
                    execute(File(opts.output))
                }
            } catch (e: Throwable) {
                e.printStackTrace()
            }
        }
    }
}

fun compile(opt: CompilerOptions): Boolean {
    Prof.start("compile")
    Prof.start("program")
    val program = LstProgram(opt)

    Prof.next("parse_core")
    AstParser.includeFile("core", "core.nitro", program, null)

    Prof.next("parse_source")
    AstParser.parseFile(SourceFile.load(opt.source), program)

    if (opt.dumpExtern) {
        Prof.next("dump_extern")

        val f1 = program.functions.filter { it.isExternal && !it.isWasmInline }
        val f2 = f1.map { func ->
            val extern = func.getAnnotation(ANNOTATION_EXTERN)!!
            val lib = (extern.args["lib"] as? ConstString)?.value ?: error("Missing lib in extern")
            val name = (extern.args["name"] as? ConstString)?.value ?: error("Missing name in extern")

            func to (lib to name)
        }

        println("// -----------------------------------------------------------------------------")
        println("// This file was generated by the Nitro compiler, do not edit manually")
        println("// Export date: ${Instant.now()}")
        println("// -----------------------------------------------------------------------------")
        println("import * as impl from './impl.ts'")
        println("// -----------------------------------------------------------------------------")
        println("type Nothing = void;")
        println("type Boolean = boolean;")
        println("type Byte = number;")
        println("type Int = number;")
        println("type Char = number;")
        println("type Long = bigint;")
        println("type Float = number;")
        println("type Ptr = number;")
        println("type RawArray = number;")
        println("type String = number;")
        println("type Ref = number;")
        println("// -----------------------------------------------------------------------------")

        for ((lib, entries) in f2.groupBy { it.second.first }) {

            println("export const $lib = {")
            for ((path, subentries) in entries.groupBy { it.first.span.file.path }) {
                println("   // -------------------------------------------------------------------------")
                println("   // From ${File(path).name}")
                println("   // -------------------------------------------------------------------------")
                println("   //")

                for ((func, pair) in subentries) {
                    val name = pair.second

                    fun tsType(type: TType): String {
                        return when {
                            type.isNothing() -> "Nothing"
                            type.isBoolean() -> "Boolean"
                            type.isByte() -> "Byte"
                            type.isInt() -> "Int"
                            type.isChar() -> "Char"
                            type.isLong() -> "Long"
                            type.isFloat() -> "Float"
                            type.isPtr() -> "Ptr"
                            type.isRawArray() -> "RawArray"
                            type.isString() -> "String"
                            else -> "Ref"
                        }
                    }

                    val params = func.params.joinToString(", ") { if (it.name == "this") "self" else it.name }
                    val tsDef = func.params.joinToString(", ") { param ->
                        val jsName = if (param.name == "this") "self" else param.name
                        "$jsName: ${tsType(param.type)}"
                    }

                    println("   // At src/${func.span.toString().substringAfter("src/")}")
                    println("   // @Extern [lib=\"$lib\", name=\"$name\"]")
                    println("   // fun ${func.fullName}(${func.params.joinToString(", ") { it.type.toString() }}): ${func.returnType}")
                    println("   $name($tsDef): ${tsType(func.returnType)} { return impl.$name($params); },")
                    println("   //")
                }
            }
            println("};")
            println("// -----------------------------------------------------------------------------")
        }
    }

    Prof.next("print_errors")
    if (program.collector.isNotEmpty()) {
        if (opt.dumpIr) {
            Prof.next("dump_ir")
            dumpIr(program)
        }

        System.err.println(program.collector.toString())
        Prof.end()
        return false
    }

    Prof.next("mark_code")
    DeadCodeAnalyzer.markDeadCode(program)

    if (opt.dumpIr) {
        Prof.next("dump_ir")
        dumpIr(program)
    }

    Prof.next("compile_wasm")
    File(opt.output).bufferedWriter().use { out ->
        WasmBuilder.compile(program, out)
    }

    if (opt.dumpWasm) {
        Prof.next("dump_wasm")
        println("------------------------------")
        File(opt.output).readLines().forEachIndexed { index, s ->
            println("${(index + 1).toString().padStart(4)} |$s")
        }
        println("------------------------------")
    }

    Prof.next("print_wasm_errors")
    if (program.collector.isNotEmpty()) {
        System.err.println(program.collector.toString())
        Prof.end()
        return false
    }

    Prof.end()
    return true
}

fun dumpIr(program: LstProgram) {
    program.functions.forEach { func ->
        if (func.isExternal || func.isDeadCode) return@forEach

        println("------------------------------")
        println("${func.fullName}:")
        func.body.nodes.forEach { node ->
            println("    $node")
            if (node is LstLambdaInit) {
                node.lambda.body.nodes.forEach { lambdaNode ->
                    println("        $lambdaNode")
                }
            }
        }
        println("------------------------------")
        println("")
    }
}

fun execute(watFile: File) {
    Prof.start("run")
    val wasmFile = File(watFile.parentFile, "compiled.wasm")

    Prof.start("wat2wasm")
    ProcessBuilder("wat2wasm", "--enable-code-metadata", watFile.path, "-o", wasmFile.path)
        .inheritIO()
        .start()
        .waitFor()
    Prof.end()

    Prof.start("deno")
    println("--- Running output.wasm")
    ProcessBuilder("./src/main/resources/deno_wrapper.ts")
        .inheritIO()
        .start()
        .waitFor()
    println("---")
    Prof.end()
    Prof.end()
}

fun getAbsDirsRec(dirs: List<Path>, result: MutableList<Path>) {
    for (dir in dirs) {
        result.add(dir.absolute())
        dir.toFile().listFiles()?.forEach {
            if (it.isDirectory) {
                getAbsDirsRec(listOf(it.toPath()), result)
            }
        }
    }
}

fun watchFolderForChanges(dirs: List<Path>, callback: (Path) -> Unit) {
    val watchService = FileSystems.getDefault().newWatchService()

    val absDirs = mutableListOf<Path>()
    getAbsDirsRec(dirs, absDirs)
    absDirs.forEach {
        val dir = if (it.isRegularFile()) it.parent else it
        dir.register(
            watchService,
            StandardWatchEventKinds.ENTRY_CREATE,
            StandardWatchEventKinds.ENTRY_MODIFY
        )
    }

    println("Watching directory: $absDirs")

    while (true) {
        val watchKey: WatchKey
        try {
            watchKey = watchService.take()

            // Required to avoid double fires
            Thread.sleep(50)
        } catch (ex: InterruptedException) {
            return
        }

        watchKey.pollEvents().forEach { event ->
            val kind = event.kind()

            @Suppress("UNCHECKED_CAST")
            val ev = event as WatchEvent<Path>
            val filename = ev.context()
            val parentDirectory = watchKey.watchable() as Path
            val fullPath = parentDirectory.resolve(filename)

            if (filename.name.endsWith('~')) {
                return@forEach
            }

            var matches = false
            for (absDir in absDirs) {
                if (fullPath.startsWith(absDir)) {
                    matches = true
                }
            }
            if (!matches) return@forEach

            when (kind) {
                StandardWatchEventKinds.ENTRY_CREATE -> {
                    println("File created: $filename")
                    callback(fullPath)
                }

                StandardWatchEventKinds.ENTRY_MODIFY -> {
                    println("File modified: $filename")
                    callback(fullPath)
                }
            }
        }

        if (!watchKey.reset()) {
            break
        }
    }
}
package nitrolang.typeinference

import nitrolang.ast.*
import nitrolang.parsing.ParserCtx
import nitrolang.parsing.THIS_TYPE

fun ParserCtx.doAllTypeChecking() {
    program.consts.values.forEach { const ->
        if (const.checked) return@forEach
        const.checked = true
        const.typeBox = typeEnv.box(typeUsage(const.typeUsage), const.span)
        const.body.returnTypeBox = const.typeBox
    }

    program.structs.values.forEach { struct ->
        if (struct.checked) return@forEach
        struct.checked = true

        struct.fields.values.forEach { field ->
            field.typeBox = typeEnv.box(typeUsage(field.typeUsage), field.span)
        }
    }

    program.functions.values.forEach { func ->
        if (func.checked) return@forEach
        func.checked = true

        currentTag = func.tag
        func.params.forEach { param ->
            param.typeBox = typeEnv.box(typeUsage(param.typeUsage), param.span)
            param.variable!!.typeBox = param.typeBox
        }
        func.returnTypeBox = typeEnv.box(typeUsage(func.returnTypeUsage), func.span)
        func.body.returnTypeBox = func.returnTypeBox
        currentTag = null
    }

    program.tags.values.forEach { tag ->
        if (tag.checked) return@forEach
        tag.checked = true

        val options = typeEnv.getSimpleBaseTypes().toMutableList()
        val functions = mutableMapOf<Pair<TTypeBase, String>, LstFunction>()

        for (func in tag.headers.values) {
            if (func.params.isEmpty()) {
                collector.report("Missing required receiver type", func.span)
                continue
            }

            val receiver = func.params[0].type

            if (receiver !is TTag || receiver.instance != tag) {
                collector.report("Receiver must be the same type as the tag", func.span)
                continue
            }

            val res = findTagFunctionInstances(options, func, tag)
            options.clear()
            res.forEach {
                options += it.first
                functions[it.first to func.name] = it.second
            }
        }

        tag.taggedBaseTypes += options

        functions.forEach { pair ->
            // Exclude functions from types that are incomplete
            if (pair.key.first in options) {
                tag.functionInstances[pair.key] = pair.value
            }
        }
    }

    program.functions.values.forEach { func ->
        if (func.codeChecked) return@forEach
        func.codeChecked = true

        // Extern functions have empty body
        if (func.isExternal) {
            if (func.body.nodes.isNotEmpty()) {
                collector.report("Extern function must have empty body", func.span)
            }
            return@forEach
        }

        currentTag = func.tag
        func.body.returnTypeBox = func.returnTypeBox

        visitCode(func.body)
        currentTag = null

        typeEnv.apply {
            // Return nothing or is a tag function with autogenerated body
            if (func.returnType.isNothing() || func.tag != null) {
                return@forEach
            }
        }

        val lastNode = func.body.lastExpression?.let { func.body.getNode(it) }

        if (lastNode == null) {
            collector.report("Function '${func.name}' must return a value but has empty body", func.span)
            return@forEach
        }

        if (lastNode is LstReturn) {
            return@forEach
        }

        if (lastNode !is LstExpression) {
            collector.report("Function '${func.name}' must return '${func.returnType}'", func.span)
            return@forEach
        }

        typeEnv.addAssignableConstraint(func.returnType, lastNode.type, lastNode.span)
    }

    program.consts.values.forEach { const ->
        if (const.codeChecked) return@forEach
        const.codeChecked = true

        const.body.returnTypeBox = const.typeBox

        visitCode(const.body)

        const.body.lastExpression
        val lastNode = const.body.lastExpression?.let { const.body.getNode(it) }

        if (lastNode == null) {
            collector.report("Const '${const.name}' must return a value but has empty body", const.span)
            return@forEach
        }

        if (lastNode is LstReturn) {
            return@forEach
        }

        if (lastNode !is LstExpression) {
            collector.report("Const '${const.name}' must return '${const.type}'", const.span)
            return@forEach
        }

        typeEnv.addAssignableConstraint(const.type, lastNode.type, lastNode.span)
    }

    typeEnv.solveConstraints()
    typeEnv.finish()
}

private fun ParserCtx.typeUsage(tu: TypeUsage): TType {
    if (tu.unresolvedTypeRef != null) {
        if (tu.sub.isNotEmpty()) {
            collector.report("Type parameters not allowed here", tu.span)
        }
        return typeEnv.unresolved(tu.span)
    }

    if (tu.typeParameter != null) {
        if (tu.sub.isNotEmpty()) {
            collector.report("Type parameters not allowed here", tu.span)
        }
        return typeEnv.generic(tu.typeParameter)
    }

    val params = tu.sub.map { typeUsage(it) }

    if (tu.fullName == THIS_TYPE) {
        if (currentTag == null) {
            collector.report("Use of '$THIS_TYPE' outside of a tag definition", tu.span)
            return typeEnv.invalid(tu.span)
        }

        return typeEnv.typeTag(currentTag!!)
    }

    // Search for struct/option/tag/etc

    val segments = createPathSegments(tu.currentPath, tu.fullName)

    for (segment in segments) {
        val option = program.options.values.find { it.fullName == segment }

        if (option != null) {
            val base = typeEnv.typeBaseOption(option)

            return typeEnv.composite(base, params)
        }

        val struct = program.structs.values.find { it.fullName == segment }

        if (struct != null) {
            val base = if (struct.parentOption != null)
                typeEnv.typeBaseOptionItem(struct, program.options[struct.parentOption]!!)
            else
                typeEnv.typeBaseStruct(struct)

            return typeEnv.composite(base, params)
        }

        val tag = program.tags.values.find { it.fullName == segment }

        if (tag != null) {
            return typeEnv.typeTag(tag)
        }
    }

    collector.report("Type '${tu.fullName}' not found", tu.span)
    return typeEnv.invalid(tu.span)
}

private fun ParserCtx.visitCode(code: LstCode) {
    this.code = code

    // Resolve specified types in let expressions
    code.variables.values.forEach { variable ->
        variable.typeUsage?.let {
            variable.typeBox = typeEnv.box(typeUsage(it), variable.span)
        }
    }

    // Link variable usage with the corresponding variable in scope
    bindVariables(code)

    // Resolve the type of every expression and check other requirements
    code.nodes.forEach { node ->
        when (node) {
            is LstIfStart -> {
                val cond = code.getNode(node.cond).asExpr(node) ?: return

                typeEnv.addEqualConstraint(cond.type, typeEnv.find("Boolean"), cond.span)
            }

            is LstExpression -> {
                visitExpression(node, code)
                typeEnv.solveConstraints()
            }

            else -> Unit
        }
    }
}

fun ParserCtx.bindVariables(code: LstCode) {
    fun <T> ParserCtx.linkVariable(node: T, code: LstCode) where T : LstExpression, T : HasVarRef {
        var found: LstVar? = null
        var block: LstNodeBlock? = node.block

        while (block != null && found == null) {
            found = code.variables.values
                .filter { it.block == block }
                .sortedByDescending { it.validAfter.id }
                .filter { it.validAfter.id <= node.ref.id }
                .find { it.name == node.name }

            block = block.parent
        }

        if (found != null) {
            node.varRef = found.ref
            node.variable = found
            found.referencedBy.add(node)
            return
        }

        val found2 = program.consts.values.find { it.name == node.name }

        if (found2 != null) {
            node.varRef = found2.ref
            node.constant = found2
            found2.referencedBy.add(node)
            return
        }

        collector.report("Variable not found: ${node.name}", node.span)
    }

    code.nodes.filterIsInstance<LstLoadVar>().forEach { if (it.varRef == null) linkVariable(it, code) }
    code.nodes.filterIsInstance<LstStoreVar>().forEach { if (it.varRef == null) linkVariable(it, code) }
}

fun ParserCtx.visitExpression(node: LstExpression, code: LstCode) {
    when (node) {
        is LstBoolean -> {
            node.typeBox = typeEnv.box(typeEnv.find("Boolean"), node.span)
        }

        is LstFloat -> {
            node.typeBox = typeEnv.box(typeEnv.find("Float"), node.span)
        }

        is LstInt -> {
            node.typeBox = typeEnv.box(typeEnv.find("Int"), node.span)
        }

        is LstNothing -> {
            node.typeBox = typeEnv.box(typeEnv.find("Nothing"), node.span)
        }

        is LstString -> {
            node.typeBox = typeEnv.box(typeEnv.find("String"), node.span)
        }

        is LstSizeOf -> {
            node.typeUsageBox = typeEnv.box(typeUsage(node.typeUsage), node.span)
            node.typeBox = typeEnv.box(typeEnv.find("Int"), node.span)
        }

        is LstPtrOf -> {
            node.typeBox = typeEnv.box(typeEnv.find("Int"), node.span)
        }

        is LstMemoryWrite -> {
            val ptrExpr = code.getNode(node.ptrExpr).asExpr(node) ?: error("MemoryWrite requires an expression")
            val valueExpr = code.getNode(node.valueExpr).asExpr(node) ?: error("MemoryWrite requires two expressions")

            val typeUsage = typeUsage(node.typeUsage)
            node.typeUsageBox = typeEnv.box(typeUsage, node.span)
            node.typeBox = typeEnv.box(typeEnv.find("Nothing"), node.span)

            typeEnv.addEqualConstraint(ptrExpr.type, typeEnv.find("Int"), ptrExpr.span)
            typeEnv.addEqualConstraint(valueExpr.type, typeUsage, valueExpr.span)
        }

        is LstMemoryRead -> {
            val ptrExpr = code.getNode(node.expr).asExpr(node) ?: error("LstMemoryRead requires an expression")
            val typeUsage = typeUsage(node.typeUsage)
            node.typeUsageBox = typeEnv.box(typeUsage, node.span)
            node.typeBox = typeEnv.box(typeUsage, node.span)

            typeEnv.addEqualConstraint(ptrExpr.type, typeEnv.find("Int"), ptrExpr.span)
        }

        is LstReturn -> {
            node.typeBox = typeEnv.box(typeEnv.find("Never"), node.span)

            val expr = code.getNode(node.expr).asExpr(node) ?: error("Return requires an expression")

            typeEnv.addEqualConstraint(code.returnTypeBox!!.type, expr.type, expr.span)
        }

        is LstAlloc -> {
            // Declared type, ej. List<*>, Map<*, *>, Struct<Int>
            val definedType = typeUsage(node.typeUsage)
            node.typeUsageBox = typeEnv.box(definedType, node.span)

            // Only structs can be allocated, options and traits are only for the type system
            if (definedType !is TComposite || (definedType.base !is TStruct && definedType.base !is TOptionItem)) {
                collector.report("Type '${definedType}' is not an struct", node.span)
                node.typeBox = typeEnv.box(typeEnv.invalid(node.span), node.span)
                return
            }

            val struct: LstStruct = when (definedType.base) {
                is TStruct -> definedType.base.instance
                is TOptionItem -> definedType.base.instance
                else -> error("Invalid option: ${definedType.base}")
            }

            // The real type is unknown until we resolve al unresolved types
            // and can replace the struct type template with concrete types
            val realParams =
                List(struct.typeParameters.size) { definedType.params.getOrNull(it) ?: typeEnv.unresolved(node.span) }

            val base = if (struct.parentOption != null)
                typeEnv.typeBaseOptionItem(struct, program.options[struct.parentOption]!!)
            else
                typeEnv.typeBaseStruct(struct)

            node.typeBox = typeEnv.box(typeEnv.composite(base, realParams), node.span)
        }

        is LstIfChoose -> {
            val ifTrue = code.getNode(node.ifTrue).asExpr(node)
            val ifFalse = code.getNode(node.ifFalse).asExpr(node)

            if (ifTrue == null || ifFalse == null) {
                node.typeBox = typeEnv.box(typeEnv.invalid(node.span), node.span)
                return
            }

            val commonType = typeEnv.unresolved(node.span)

            typeEnv.addAssignableConstraint(commonType, ifTrue.type, ifTrue.span)
            typeEnv.addAssignableConstraint(commonType, ifFalse.type, ifFalse.span)

            node.typeBox = typeEnv.box(commonType, node.span)
        }

        is LstIsType -> {
            node.typeBox = typeEnv.box(typeEnv.find("Boolean"), node.span)
            node.typeUsageBox = typeEnv.box(typeUsage(node.typeUsage), node.span)
        }

        is LstAsType -> {
            node.typeUsageBox = typeEnv.box(typeUsage(node.typeUsage), node.span)
            node.typeBox = node.typeUsageBox
        }

        is LstLoadVar -> {
            if (node.varRef == null) {
                node.typeBox = typeEnv.box(typeEnv.invalid(node.span), node.span)
                return
            }

            if (node.varRef in program.consts) {
                val const = program.consts[node.varRef] ?: error("ConstRef not found!")

                node.typeBox = typeEnv.box(const.type, node.span)
                return
            }

            val variable = code.variables[node.varRef] ?: error("VarRef not found!")

            if (variable.typeBox == null) {
                collector.report("Attempt to read a variable before its first write", node.span)
                node.typeBox = typeEnv.box(typeEnv.invalid(node.span), node.span)
                return
            }

            node.typeBox = typeEnv.box(variable.type, node.span)
        }

        is LstStoreVar -> {
            val value = code.getNode(node.expr).asExpr(node)

            if (node.varRef == null || value == null) {
                node.typeBox = typeEnv.box(typeEnv.invalid(node.span), node.span)
                return
            }

            if (node.varRef in program.consts) {
                val const = program.consts[node.varRef] ?: error("ConstRef not found!")
                node.varTypeBox = const.typeBox
                typeEnv.addAssignableConstraint(const.type, value.type, node.span)
            } else {
                val variable = code.variables[node.varRef] ?: error("VarRef not found!")

                // First use of the variable assigns the type
                if (variable.typeBox == null) {
                    variable.typeBox = value.typeBox
                }

                node.varTypeBox = value.typeBox
                typeEnv.addAssignableConstraint(variable.type, value.type, node.span)
            }

            node.typeBox = typeEnv.box(typeEnv.find("Nothing"), node.span)
        }

        is LstLoadField -> {
            val instance = code.getNode(node.instance).asExpr(node)

            if (instance == null) {
                node.typeBox = typeEnv.box(typeEnv.invalid(node.span), node.span)
                return
            }

            val unresolved = typeEnv.unresolved(node.span)
            node.typeBox = typeEnv.box(unresolved, node.span)

            typeEnv.addFindFieldConstraint(instance.type, node.span) { ty ->
                if (ty !is TComposite || (ty.base !is TStruct && ty.base !is TOptionItem)) {
                    collector.report("Type '$ty' has no fields", node.span)
                    typeEnv.addEqualConstraint(unresolved, typeEnv.invalid(node.span), node.span)
                    return@addFindFieldConstraint
                }

                val struct = when (ty.base) {
                    is TStruct -> ty.base.instance
                    is TOptionItem -> ty.base.instance
                    else -> error("Invalid type base: ${ty.base}")
                }
                val field = struct.fields.values.find { it.name == node.name }

                if (field == null) {
                    collector.report("Type '${ty}' ha no field named '${node.name}'", node.span)
                    typeEnv.addEqualConstraint(node.type, typeEnv.invalid(node.span), node.span)
                    return@addFindFieldConstraint
                }

                node.struct = struct
                node.field = field
                var fieldType = field.type

                repeat(struct.typeParameters.size) { i ->
                    val generic = typeEnv.generic(struct.typeParameters[i])

                    typeEnv.apply {
                        fieldType = fieldType.replace(generic, ty.params[i])
                    }
                }

                typeEnv.addEqualConstraint(node.type, fieldType, node.span)
            }
        }

        is LstStoreField -> {
            val instance = code.getNode(node.instance).asExpr(node)
            val value = code.getNode(node.expr).asExpr(node)

            if (instance == null || value == null) {
                node.typeBox = typeEnv.box(typeEnv.invalid(node.span), node.span)
                return
            }

            node.typeBox = typeEnv.box(typeEnv.find("Never"), node.span)

            typeEnv.addFindFieldConstraint(instance.type, node.span) { ty ->
                if (ty !is TComposite || (ty.base !is TStruct && ty.base !is TOptionItem)) {
                    collector.report("Type '$ty' has no fields", node.span)
                    typeEnv.addEqualConstraint(ty, typeEnv.invalid(node.span), node.span)
                    return@addFindFieldConstraint
                }

                val struct = when (ty.base) {
                    is TStruct -> ty.base.instance
                    is TOptionItem -> ty.base.instance
                    else -> error("Invalid type base: ${ty.base}")
                }
                val field = struct.fields.values.find { it.name == node.name }

                if (field == null) {
                    collector.report("Type '${ty}' has no field named '${node.name}'", node.span)
                    typeEnv.addEqualConstraint(ty, typeEnv.invalid(node.span), node.span)
                    return@addFindFieldConstraint
                }

                node.struct = struct
                node.field = field
                var fieldType = field.type

                repeat(struct.typeParameters.size) { i ->
                    val generic = typeEnv.generic(struct.typeParameters[i])

                    typeEnv.apply {
                        fieldType = fieldType.replace(generic, ty.params[i])
                    }
                }

                typeEnv.addAssignableConstraint(fieldType, value.type, node.span)
            }
        }

        is LstWhenEnd -> {
            val unresolved = typeEnv.unresolved(node.span)
            node.typeBox = typeEnv.box(unresolved, node.span)
            node.start.typeBox = node.typeBox

            node.branchStores.forEach { branch ->
                branch.typeBox = node.typeBox
                val value = code.getNode(branch.expr).asExpr(node) ?: return@forEach

                typeEnv.addAssignableConstraint(unresolved, value.type, branch.span)
            }
        }

        is LstFunCall -> {
            val unresolved = typeEnv.unresolved(node.span)
            node.typeBox = typeEnv.box(unresolved, node.span)

            val argTypes = mutableListOf<TType>()

            for (arg in node.arguments) {
                val expr = code.getNode(arg).asExpr(node) ?: error("Missing argument expression")
                argTypes += expr.type
            }

            typeEnv.addFindFunctionConstraint(argTypes, node.span) { args ->
                val func = findFunction(node.fullName, args)

                if (func == null) {
                    collector.report("Function '${node.fullName}' not found", node.span)
                    return@addFindFunctionConstraint
                }

                node.funRef = func.ref
                node.function = func
                for (arg in args) {
                    node.concreteArgTypes += typeEnv.box(arg, node.span)
                }

                if (func.params.size != args.size) {
                    collector.report(
                        "Function '${func.name}' expects ${func.params.size}, but ${args.size} arguments where provided",
                        node.span
                    )
                }

                var paramTypes = func.params.map { it.type }
                var returnType = func.returnType

                func.typeParameters.forEach { typeParam ->
                    val generic = typeEnv.generic(typeParam)
                    val paramUnresolved = typeEnv.unresolved(node.span)
                    node.typeParamsTypes += typeEnv.box(paramUnresolved, node.span)

                    typeEnv.apply {
                        paramTypes = paramTypes.map { it.replace(generic, paramUnresolved) }
                        returnType = returnType.replace(generic, paramUnresolved)
                    }
                }

                // Type params explicitly defined
                node.specifiedTypeParams.forEachIndexed { index, typeUsage ->
                    if (index >= node.typeParamsTypes.size) {
                        collector.report("Incorrect number of type parameters supplied", typeUsage.span)
                        return@forEachIndexed
                    }

                    typeEnv.addEqualConstraint(typeUsage(typeUsage), node.typeParamsTypes[index].type, typeUsage.span)
                }

                paramTypes.zip(args).forEach { (param, arg) ->
                    typeEnv.addAssignableConstraint(param, arg, node.span)
                }

                typeEnv.addEqualConstraint(node.type, returnType, node.span)
            }
        }
    }
}

private fun ParserCtx.findTagFunctionInstances(
    validOptions: List<TTypeBase>,
    func: LstFunction,
    tag: LstTag
): List<Pair<TTypeBase, LstFunction>> {
    val result = mutableListOf<Pair<TTypeBase, LstFunction>>()

    for (base in validOptions) {
        outer@ for (baseFunc in program.functions.values) {
            if (baseFunc.tag != null) continue
            if (baseFunc.name != func.name) continue
            if (baseFunc.params.size != func.params.size) continue

            inner@ for ((baseParam, funcParam) in baseFunc.params.zip(func.params)) {
                val baseT = baseParam.type
                val funcT = funcParam.type

                if (funcT is TTag && funcT.instance == tag) {
                    if (baseT !is TComposite || baseT.base != base) continue@outer
                } else {
                    if (baseT != funcT) continue@outer
                }
            }

            val baseT = baseFunc.returnType
            val funcT = func.returnType

            if (funcT is TTag && funcT.instance == tag) {
                if (baseT !is TComposite || baseT.base != base) continue@outer
            } else {
                if (baseT != funcT) continue@outer
            }

            result += base to baseFunc
        }
    }

    return result
}

private fun ParserCtx.findFunction(name: String, args: List<TType>): LstFunction? {
    val choices = program.functions.values.filter { it.name == name }

    if (choices.isEmpty()) {
        return null
    }

    val sortedChoices = choices.sortedByDescending { func ->
        functionSimilarity(func.params.map { param -> param.type }, args)
    }

    // Best match
    return sortedChoices.first()
}

fun ParserCtx.functionSimilarity(params: List<TType>, args: List<TType>): Float {
    var total = 1000000f

    if (params.size != args.size) {
        total -= 100000f
    }

    for ((param, arg) in params.zip(args)) {
        total += similarity(param, arg) - 10000f
    }

    return total
}

fun ParserCtx.similarity(param: TType, arg: TType): Float {
    var total = 10000f

    if (param == arg) {
        return total
    }

    if (param !is TComposite || arg !is TComposite) {
        return 0f
    }

    param.params.zip(arg.params).forEach { (p, a) ->
        total += (similarity(p, a) - 10000f) / 100f
    }

    if (param.params.size != arg.params.size) {
        total -= 1000f
    }

    total -= 10000f

    if (param.base != arg.base) {
        total -= 10000f
    }

    return total
}
<!DOCTYPE html>
<html lang="en">
<head>
    <title>Web editor</title>
    <style media="screen">
        * {
            box-sizing: border-box;
        }

        body {
            margin: 0;
            padding: 0;
            height: 100vh;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            background: #282935;
        }

        button {
            background: #50fa7b;
            border: none;
            border-radius: 0.25rem;
            padding: 0.25rem 0.75rem;
            color: #282935;
            font-size: 1.4rem;
            font-weight: bold;
            cursor: pointer;
            transition: all 0.2s ease-in-out;
        }

        #toolbar {
            display: flex;
            justify-content: start;
            padding: 0.25rem 1rem;
            width: 100%;
        }

        #editor {
            width: 100%;
            flex-grow: 1;
        }
    </style>
</head>
<body>

<div id="toolbar">
    <button id="run">Compile</button>
</div>
<div id="editor"></div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.0/ace.js"
        type="text/javascript"
        charset="utf-8"
        integrity="sha512-/j4QF7NJ4YyRe7gkXW9LNmMzebNKXUZagblPCkluUVcvG9iI5PtRdw3Zc7Hcvretcjwrrz8q+NpGWoQu/ElYDg=="
        crossorigin="anonymous"
></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/ace/1.32.0/theme-dracula.js" type="text/javascript"
        charset="utf-8"></script>

<script>
  // @see https://medium.com/@jackub/writing-custom-ace-editor-mode-5a7aa83dbe50
  ace.define('ace/mode/nitro_highlight_rules', ['require', 'exports', 'ace/lib/oop', 'ace/mode/text_highlight_rules'], (acequire, exports) => {
    const oop = acequire('ace/lib/oop');
    const TextHighlightRules = acequire('ace/mode/text_highlight_rules').TextHighlightRules;

    const NitroHighlightRules = function NitroHighlightRules() {
      // regexp must not have capturing parentheses. Use (?:) instead.
      // regexps are ordered -> the first match is used

      const keywordMapper = this.$keywords = this.createKeywordMapper({
        "keyword": "Self|function|var|val|module|class|type|recv|receiver|trait|interface|either|ref_mut|ref|copy|or|and|xor|not|This|fun|let|mod|struct|ret|return|size_of|sizeOf|sizeof|option|rec|tag|defer|type_alias|typeAlias|typealias|enum|when|match|alias|if|else|for|in|while|repeat|loop|is|as|include|break|continue|use|mut",
        "constant.language.nitro": "true|false|null|this|nothing|self",
      }, "identifier");

      const restart = (currentState, stack) => {
        while (stack && stack.length > 0) {
          stack.shift();
        }
        return "start";
      };

      const restart_to = (to_state) => {
        return (currentState, stack) => {
          while (stack && stack.length > 0 && stack[stack.length - 1] !== to_state) {
            stack.shift();
          }
          return to_state;
        };
      }

      this.$rules = {
        "start": [
          {
            include: "#comments"
          },
          {
            include: "#annotation"
          },
          {
            include: "#struct"
          },
          {
            include: "#option"
          },
          {
            include: "#tag"
          },
          {
            include: "#function_header"
          },
          {
            include: "#statements"
          },
          {
            include: "#expressions"
          },
          {
            token: keywordMapper,
            regex: /[a-zA-Z]\w*\b/
          },
          {
            token: "paren.lparen",
            regex: /[{(\[]/
          },
          {
            token: "paren.rparen",
            regex: /[})\]]/
          }
        ],
        "#comments": [
          {
            token: "comment",
            regex: /\/\*/,
            push: [
              {
                token: "comment",
                regex: /\*\//,
                next: "pop"
              },
              {
                defaultToken: "comment"
              }
            ]
          },
          {
            token: [
              "text",
              "comment"
            ],
            regex: /(\s*)(\/\/.*$)/
          }
        ],
        "#annotation": [
          {
            token: ["storage.type.annotation.nitro", "text", "punctuation.annotation.start"],
            regex: /(@\w+)(\s*)(\[)/,
            push: [
              {
                token: "punctuation.annotation.end",
                regex: /\]/,
                next: restart,
              },
              {
                include: "#instantiation_field"
              },
              {
                token: "punctuation",
                regex: /,/
              },
              {
                token: "text",
                regex: /\s+/
              },
            ],
          },
          {
            token: "storage.type.annotation.nitro",
            regex: /@\w+/,
          }
        ],
        "#constants": [
          {
            token: "constant.numeric.nitro",
            regex: /\b(?:0(?:[xbo])[0-9a-fA-F]*|(?:[0-9]+\.?[0-9]*|\.[0-9]+)(?:(?:[eE])(?:\+|-)?[0-9]+)?)(?:[LlFfUuDd]|UL|ul)?\b/
          },
          {
            token: "constant.other.nitro",
            regex: /\b[A-Z][A-Z0-9_]+\b/
          }
        ],
        "#expressions": [
          {
            include: "#strings"
          },
          {
            include: "#constants"
          },
          {
            include: "#keywords"
          }
        ],
        "#generics": [
          {
            token: "punctuation",
            regex: /</,
            push: [
              {
                token: "punctuation",
                regex: />/,
                next: "pop"
              },
              {
                token: "storage.type.generic.nitro",
                regex: /#\w+/
              },
              {
                token: "keyword.operator",
                regex: /:/
              },
              {
                token: "punctuation",
                regex: /,/
              },
              {
                include: "#generics"
              }
            ]
          }
        ],
        "#definition_generics": [
          {
            token: "punctuation.definition_generics.start",
            regex: /</,
            push: [
              {
                token: "punctuation.definition_generics.end",
                regex: />/,
                next: "pop"
              },
              {
                token: "storage.type.generic.nitro",
                regex: /#\w+/
              },
              {
                token: "punctuation",
                regex: /,/
              },
              {
                token: "punctuation",
                regex: /:/
              },
              {
                token: "storage.type.regular.nitro",
                regex: /\w+/
              },
              {
                token: "text",
                regex: /\s+/
              }
            ],
          }
        ],
        "#usage_generics": [
          {
            token: "punctuation.definition_generics.start",
            regex: /</,
            push: [
              {
                token: "punctuation.definition_generics.end",
                regex: />/,
                next: "pop"
              },
              {
                include: "#types",
              },
              {
                token: "punctuation",
                regex: /,/
              },
              {
                token: "text",
                regex: /\s+/
              }
            ],
          }
        ],
        "#types": [
          {
            include: "#defaultTypes"
          },
          {
            token: "storage.type.generic.nitro",
            regex: /#\w+/
          },
          {
            token: "storage.type.regular.nitro",
            regex: /\w+/
          },
          {
            token: "paren.lparen.funtion_type.nitro",
            regex: /\(/,
            push: [
              {
                token: ["paren.rparen.funtion_type.nitro", "text", "punctuation.funtion_type.nitro", "text"],
                regex: /(\))(\s*)(->)(\s*)/,
                next: "pop",
              },
              {
                include: "#types",
              },
              {
                token: "punctuation",
                regex: /,/
              },
              {
                token: "text",
                regex: /\s+/
              },
              {
                token: "text",
                regex: /(?=$|\))/,
                next: "pop",
              }
            ]
          },
          {
            token: "punctuation",
            regex: /\./
          },
          {
            include: "#usage_generics"
          }
        ],
        "#defaultTypes": [
          {
            token: "storage.type.buildin.nitro",
            regex: /\b(Any|Arena|Array|ArrayList|Boolean|Box|Buffer|Byte|Char|Console|Deque|Entry|Float|Fun0|Fun1|Fun2|Fun3|Fun4|Fun5|Fun6|Fun7|Fun8|Fun9|HashMap|Int|Iter|Iterator|Json|List|Map|MapEntry|Math|Memory|MemoryArena|Nothing|Null|Number|Object|Optional|Ordering|Ptr|Queue|Raw|RawArray|Ref|Result|Set|Short|Slice|Stack|String|StringMap|StringMapEntry|Unit|Vec|Pair)\b/
          },
          {
            token: "storage.type.special.nitro",
            regex: /\b(This|Self)\b/
          }
        ],
        "#struct": [
          {
            token: "keyword.struct.nitro",
            regex: /\bstruct\b/,
            push: [
              {
                token: "punctuation.struct.start",
                regex: /\{/,
                next: "#struct_body",
              },
              {
                token: "storage.type.struct.nitro",
                regex: /\w+/,
              },
              {
                token: "text",
                regex: /\s+/,
              },
              {
                include: "#definition_generics"
              },
              {
                token: "text",
                regex: /\s+/,
              },
              {
                token: "text",
                regex: /(?=$|\{|\}|=|,)/,
                next: "pop",
              },
            ],
          }
        ],
        "#struct_body": [
          {
            token: "punctuation.struct.end",
            regex: /\}/,
            next: restart,
          },
          {
            token: ["entity.name.variable.nitro", "text", "punctuation", "text"],
            regex: /(\w+)(\s*)(:)(\s*)/,
            push: [
              {
                include: "#types",
              },
              {
                token: "text",
                regex: /(?=$|,|}|\n)/,
                next: "pop",
              }
            ],
          },
          {
            token: "punctuation",
            regex: /,/,
          },
          {
            token: "text",
            regex: /\s+/,
          },
        ],
        "#option": [
          {
            token: "keyword.option.nitro",
            regex: /\boption\b/,
            push: [
              {
                token: "punctuation.option.start",
                regex: /\{/,
                next: "#option_body",
              },
              {
                token: "text",
                regex: /\s+/,
              },
              {
                token: "storage.type.option.nitro",
                regex: /\w+/,
              },
              {
                include: "#definition_generics"
              },
              {
                token: "text",
                regex: /(?=$|\{|\}|=|,)/,
                next: "pop",
              },
            ],
          }
        ],
        "#option_body": [
          {
            token: "punctuation.option.end",
            regex: /\}/,
            next: restart,
          },
          {
            token: ["storage.type.option.item.nitro", "text", "punctuation.option.item.start", "text"],
            regex: /(\w+)(\s*)(\{)(\s*)/,
            next: "#option_item_body",
          },
          {
            token: ["storage.type.option.item.nitro", "text"],
            regex: /(\w+)(\s*)/,
          }
        ],
        "#option_item_body": [
          {
            token: "punctuation.option.item.end",
            regex: /\}/,
            next: restart_to("#option_body"),
          },
          {
            token: ["entity.name.variable.nitro", "text", "punctuation", "text"],
            regex: /(\w+)(\s*)(:)(\s*)/,
            push: [
              {
                include: "#types",
              },
              {
                token: "text",
                regex: /(?=$|,|}|\n)/,
                next: "pop",
              }
            ],
          },
          {
            token: "punctuation",
            regex: /,/,
          },
          {
            token: "text",
            regex: /\s+/,
          },
        ],
        "#tag": [
          {
            token: "keyword.tag.nitro",
            regex: /\btag\b/,
            push: [
              {
                token: "punctuation.tag.start",
                regex: /\{/,
                next: "#tag_body",
              },
              {
                token: "text",
                regex: /\s+/,
              },
              {
                token: "storage.type.option.nitro",
                regex: /\w+/,
              },
              {
                include: "#definition_generics"
              },
              {
                token: "text",
                regex: /(?=$|\{|\}|=|,)/,
                next: "pop",
              },
            ],
          }
        ],
        "#tag_body": [
          {
            token: "punctuation.tag.end",
            regex: /\}/,
            next: restart,
          },
          {
            include: "#function_header"
          }
        ],
        "#function_header": [
          {
            token: "keyword.function.nitro",
            regex: /\bfun\b/,
            push: [
              {
                token: ["entity.name.function.nitro", "text", "punctuation.function_params.start", "text"],
                regex: /(\w+)(\s*)(\()(\s*)/,
                next: "#function_header_params",
              },
              {
                token: "text",
                regex: /\s+/,
              },
              {
                include: "#definition_generics",
              },
              {
                token: "punctuation.namespace.nitro",
                regex: /::/,
              },
              {
                include: "#types",
              },
              {
                token: "punctuation",
                regex: /\./,
              },
              {
                token: "text",
                regex: /(?=$|\{|=)/,
                next: "pop",
              },
            ],
          }
        ],
        "#function_header_params": [
          {
            token: "punctuation.function_params.end",
            regex: /\)/,
            next: "#function_end",
          },
          {
            token: ["entity.name.variable.nitro", "text", "punctuation", "text"],
            regex: /(\w+)(\s*)(:)(\s*)/,
            push: [
              {
                include: "#types",
              },
              {
                token: "text",
                regex: /(?=$|,|\))/,
                next: "pop",
              }
            ],
          },
          {
            token: "punctuation",
            regex: /,/,
          },
          {
            token: "text",
            regex: /\s+/,
          },
          {
            token: "text.any",
            regex: /.+/,
          }
        ],
        '#function_end': [
          {
            token: "punctuation",
            regex: /:/,
          },
          {
            include: "#types",
          },
          {
            token: "text",
            regex: /(?=$|\n|\{|=)/,
            next: "pop",
          }
        ],
        "#statements": [
          {
            token: ["keyword.let.nitro", "text", "keyword.mut.nitro", "text", "entity.name.variable.nitro", "text"],
            regex: /(\blet\b)(\s*)(mut)?(\s*)(\w+)(\s*)/,
            push: [
              {
                token: "text",
                regex: /\s+/,
              },
              {
                token: "keyword.operator.assignment.nitro",
                regex: /=/,
                next: "pop",
              },
              {
                token: "punctuation",
                regex: /:/,
                push: [
                  {
                    include: "#types"
                  },
                  {
                    token: "punctuation",
                    regex: /=|,|\n|$/,
                    next: "pop",
                  },
                ]
              },
              {
                token: "text",
                regex: /./,
                next: "pop"
              }
            ]
          },
          {
            token: "keyword.if.nitro",
            regex: /\bif\b/,
          },
          {
            token: "keyword.else.nitro",
            regex: /\belse\b/,
          },
          {
            token: "keyword.repeat.nitro",
            regex: /\brepeat\b/,
          },
          {
            token: "keyword.while.nitro",
            regex: /\bwhile\b/,
          },
          {
            token: "keyword.for.nitro",
            regex: /\bfor\b/,
          },
          {
            token: "keyword.defer.nitro",
            regex: /\bdefer\b/,
          },
          {
            token: "keyword.defer.nitro",
            regex: /\bdefer\b/,
          },
        ],
        "#keywords": [
          {
            token: "keyword.operator.nitro",
            regex: /==|!=|===|!==|<=|>=|<|>|=>|->|::|\?:/
          },
          {
            token: "keyword.operator.assignment.nitro",
            regex: /=/
          },
          {
            token: "keyword.operator.declaration.nitro",
            regex: /:/,
            push: [
              {
                token: "text",
                regex: /(?=$|{|=|,)/,
                next: "pop"
              },
              {
                include: "#types"
              }
            ]
          },
          {
            token: "keyword.operator.dot.nitro",
            regex: /\./
          },
          {
            token: "keyword.operator.increment-decrement.nitro",
            regex: /\-\-|\+\+/
          },
          {
            token: "keyword.operator.arithmetic.nitro",
            regex: /[\-+*/%]/
          },
          {
            token: "keyword.operator.arithmetic.assign.nitro",
            regex: /\+=|\-=|\*=|\/=/
          },
          {
            token: "keyword.operator.logical.nitro",
            regex: /not|xor|or|!|&&|\|\|/
          },
          {
            token: "keyword.operator.range.nitro",
            regex: /\.\.[=<]/
          },
          {
            token: "punctuation",
            regex: /[;,]/
          }
        ],
        "#strings": [
          {
            token: "string",
            regex: /"""/,
            push: [
              {
                token: "string",
                regex: /"""/,
                next: "pop"
              },
              {
                token: "variable.parameter.template.nitro",
                regex: /\$\w+|\${[^}]+}/
              },
              {
                token: "constant.character.escape.nitro",
                regex: /\\./
              },
              {
                defaultToken: "string"
              }
            ]
          },
          {
            token: "string",
            regex: /"/,
            push: [{
              token: "string",
              regex: /"/,
              next: "pop"
            },
              {
                token: "variable.parameter.template.nitro",
                regex: /\$\w+|\$\{[^\}]+\}/
              },
              {
                token: "constant.character.escape.nitro",
                regex: /\\./
              },
              {
                defaultToken: "string"
              }
            ]
          },
          {
            token: "string",
            regex: /```/,
            push: [
              {
                token: "string",
                regex: /```/,
                next: "pop"
              },
              {
                defaultToken: "string"
              }
            ]
          }
        ],
        "#instantiation_field": [
          {
            token: "entity.name.variable.nitro",
            regex: /\w+/,
          },
          {
            token: "punctuation",
            regex: /:/
          },
          {
            include: "#expressions"
          },
          {
            defaultToken: "text"
          }
        ],
        "#fields_definition": [
          {
            token: "punctuation",
            regex: /{/,
            push: [
              {
                token: "punctuation",
                regex: /}/,
                next: "pop",
              },
              {
                include: "#field_definition",
              },
              {
                token: "punctuation",
                regex: /,/,
              },
              {
                token: "text",
                regex: /\s+/,
              }
            ]
          },
        ],
        "#field_definition": [
          {
            token: "entity.name.variable.nitro",
            regex: /\w+/,
            push: [
              {
                token: "text",
                regex: /\s+/,
              },
              {
                token: "punctuation",
                regex: /:/,
                next: "pop",
                push: [
                  {
                    token: "text",
                    regex: /\s+/,
                  },
                  {
                    include: "#types",
                  },
                  {
                    token: "punctuation",
                    regex: /,|\n|$/,
                    next: "pop",
                  },
                ]
              },
            ]
          },
        ],
      };

      this.normalizeRules();
    };

    NitroHighlightRules.metaData = {
      fileTypes: ["nl", "nitro"],
      name: "Nitro",
      scopeName: "source.Nitro"
    };

    oop.inherits(NitroHighlightRules, TextHighlightRules);

    exports.NitroHighlightRules = NitroHighlightRules;
  });

  ace.define("ace/mode/nitro", ["require", "exports", "module", "ace/lib/oop", "ace/mode/text", "ace/mode/nitro_highlight_rules", "ace/mode/folding/text"], (require, exports, module) => {
    const oop = require("../lib/oop");
    const TextMode = require("./text").Mode;
    const NitroHighlightRules = require("./nitro_highlight_rules").NitroHighlightRules;

    const Mode = function () {
      this.HighlightRules = NitroHighlightRules;
      this.$behaviour = this.$defaultBehaviour;
    };
    oop.inherits(Mode, TextMode);
    exports.Mode = Mode;
  });

  const defaultText = `

fun main() {
    println("Hello world")
}

`;

  const editor = ace.edit("editor");
  editor.setTheme("ace/theme/dracula");
  editor.session.setMode("ace/mode/nitro");
  editor.setValue(
    window.localStorage.getItem('saved') || defaultText
  );

  // Save the code internally to localStorage
  setInterval(() => {
    const now = new Date();
    const prev = window.localStorage.getItem('saved');
    const curr = editor.getValue();

    if (prev !== curr) {
      window.localStorage.setItem('saved', curr);
      window.localStorage.setItem('last-saved', now.toISOString());
    }
  }, 1000);

  // On click send the code to the server to compile it
  run.onclick = () => {
    const code = editor.getValue();
    const start = new Date();

    console.info('Sending code to server...');

    fetch('http://localhost:8080/compile', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Accept': 'application/wasm'
      },
      cors: 'no-cors',
      body: JSON.stringify({source: code})
    })
      .then(res => res.blob())
      .then(res => {
        const end = new Date();
        const diff = end.getTime() - start.getTime();
        console.info(`Compiled in ${diff}ms`);
      })
      .catch(err => {
        console.error(err);
      });
  }

</script>
</body>
</html>

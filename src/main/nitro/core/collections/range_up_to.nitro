
// Range of Integers [start, end), start is inclusive, end is exclusive
struct IntRangeUpTo {
    start: Int
    end_exclusive: Int
}

// Creates a range of integers from start to end (exclusive)
fun Int.range_up_to(end_exclusive: Int): IntRangeUpTo {
    return IntRangeUpTo @[start: this, end_exclusive]
}

// Creates a list from a range of integers, the end not included
fun IntRangeUpTo.to_list(): List<Int> {
    let list = List::new()
    let current = this.start

    while current < this.end_exclusive {
        list[] = current
        current = current + 1
    }

    ret list
}

// Iterator to allow for loops like:
// for i in 0..<10 {}
fun IntRangeUpTo.to_iterator(): IntRangeIterator = IntRangeIterator @[
    current: this.start
    last: this.end_exclusive - 1
]

// Checks if the range is empty, meaning, no values are contained in it
fun IntRangeUpTo.is_empty(): Boolean {
    return this.start >= this.end_exclusive
}

// Checks if a value is contained in the range
fun IntRangeUpTo.contains(value: Int): Boolean {
    return value >= this.start && value < this.end_exclusive
}

fun IntRangeUpTo.to_string(): String {
    return "${this.start}..<${this.end_exclusive}"
}

@Test
mod test {

    @Test
    fun test_for_with_int_range_to() {
        let count = 0
        for i in 0..<10 {
            check(i >= 0 && i <= 9, "i should be between 1 and 9")
            count = count + 1
        }
        check(count == 10, "Number of iterations should be 9")
    }

    @Test
    fun test_int_range_to_to_list() {
        let list = (0..<10).to_list()
        check(list.len() == 10, "List should have 10 elements")
        check(list[0]!! == 0, "First element should be 1")
        check(list[9]!! == 9, "Last element should be 10")
    }
}

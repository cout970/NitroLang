
// Due to limitations of the compiler, tags cannot have type parameters.
//tag Iterator<#Item> {
//    fun This.next(): Optional<#Item>
//}

//tag ToIterator<#Iterator> {
//    fun <#Iterator: Iterator> This.to_iterator(): #Iterator
//}

// for i in list {}
struct ListIterator<#Item> {
    list: List<#Item>
    index: Int
}

// Iterator for lists
fun List<#Item>.to_iterator(): ListIterator<#Item> {
    ret ListIterator @[
        list: this
        index: 0
    ]
}

fun ListIterator<#Item>.next(): Optional<#Item> {
    if index >= list.len {
        ret None()
    }

    let item = list[index]!!
    index += 1
    ret Some(item)
}

// Iterator for int ranges
// for i in 0..=10 {}
// for i in 0..<10 {}
struct IntRangeIterator {
    current: Int
    last: Int
}

fun IntRangeIterator.next(): Optional<Int> {
    if current > last {
        ret None()
    }

    let item = current
    current += 1
    ret Some(item)
}

// for entry in map {}
struct MapIterator<#Key, #Value> {
    entries: List<Pair<#Key, #Value>>
    index: Int
}

// Iterator for map entries
fun <#Key: MapKey> Map<#Key, #Value>.to_iterator(): MapIterator<#Key, #Value> {
    ret MapIterator @[
        entries: entries_to_list()
        index: 0
    ]
}

fun MapIterator<#Key, #Value>.next(): Optional<Pair<#Key, #Value>> {
    if index >= entries.len {
        ret None()
    }

    let entry = entries[index]!!
    index += 1
    ret Some(entry)
}

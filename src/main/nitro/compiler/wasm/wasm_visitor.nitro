
// Start visiting the main function
fun WasmBackend.visit_program(main: NFunction): Id {
    ret visit_program_with_ctx(main, root_ctx)
}

fun WasmBackend.visit_program_with_ctx(func: NFunction, root_ctx: TypeMappingCtx): Id {
   let index = add_task_visit_function(root_ctx.new_child(func.span), func)

   // Run the task queue
   while task_queue.is_not_empty() {
       let task = task_queue.remove_first()!!
       when {
           task is CompilationTask::VisitFunction -> {
               let t = task as CompilationTask::VisitFunction
               visit_function(t.ctx, t.key, t.instance, t.index)
           }
           task is CompilationTask::VisitLambda -> {
               let t = task as CompilationTask::VisitLambda
               visit_lambda(t.ctx, t.key, t.instance, t.index, t.lambda_index)
           }
           task is CompilationTask::VisitConst -> {
               let t = task as CompilationTask::VisitConst
               visit_const(t.key, t.instance, t.index)
           }
       }
   }

   ret index
}

fun WasmBackend.add_task_visit_function(ctx: TypeMappingCtx, instance: NFunction): Id {
    let key = get_key_for_function(ctx, instance)
    let log = already_visited[key]

    // Already queued or done
    if log.is_some() {
        ret log!!
    }

    let index = function_indices.next()

    task_queue[] = CompilationTask::VisitFunction @[
        key,
        index,
        instance,
        ctx,
    ]

    // Prevent duplicates
    already_visited[key] = index
    ret index
}

fun WasmBackend.add_task_visit_lambda(ctx: TypeMappingCtx, instance: NLambda, lambda_type: FinalType): Id {
    let index = function_indices.next()
    let lambda_index = Id::uninitialized()
    let key = MonomorphizationKey @[
        name: "lambda_${instance.id}",
        final_type: lambda_type,
    ]

    task_queue[] = CompilationTask::VisitLambda @[key, index, lambda_index, instance, ctx,]
    ret lambda_index
}

fun WasmBackend.add_task_visit_const(instance: NConst): Id {
    let key = get_key_for_const(instance)
    let log = already_visited[key]

    // Already queued or done
    if log.is_some() {
        ret log!!
    }

    let index = const_id_provider.next()
    task_queue[] = CompilationTask::VisitConst @[
        key,
        index,
        instance,
    ]

    already_visited[key] = index
    ret index
}

fun WasmBackend.visit_function(ctx: TypeMappingCtx, key: MonomorphizationKey, instance: NFunction, index: Id) {
//    Log::debug("Visiting function $key")
    let header = get_function_header(key, index, false)

    // Wasm Function
    let wasm_func = WFunction @[
        name: instance.full_name,
        source: WFunctionSource::Function @[instance],
        code: instance.code,
        header,
        let_declarations: #[],
        let_final_types: #[],
        inst_final_types: #[],
        compile_operation: #[],
        function_calls: #[],
        lambda_instances: #[],
        constants: #[],
        ctx,
        locals: [],
        bytecode: emitter.new_child_emitter(),
    ]
    wasm_program.functions[] = wasm_func

    let wasm_name = instance.annotations.get_wasm_name_annotation()
    if wasm_name.is_some() {
        wasm_program.function_exports[] = WFunctionExport @[
            name: wasm_name!!.name,
            header,
        ]
    }

    visit_code(ctx, wasm_func, instance.code)

    let autogenerate = instance.annotations.get_autogenerated_annotation()

    if autogenerate.is_some() {
        visit_autogenerated_function(ctx, instance, wasm_func, autogenerate!!.name)
    }
}

fun WasmBackend.visit_lambda(ctx: TypeMappingCtx, key: MonomorphizationKey, instance: NLambda, index: Id, lambda_index: Id) {
//    Log::debug("Visiting function $key")
    let header = get_function_header(key, index, false)
    // First argument is the lambda itself, this is implicit
    header.params.add_first(WType::I32)

    // Wasm Function
    let wasm_func = WFunction @[
        name: header.name
        source: WFunctionSource::Lambda @[instance],
        code: instance.code,
        header,
        let_declarations: #[],
        let_final_types: #[],
        inst_final_types: #[],
        compile_operation: #[],
        function_calls: #[],
        lambda_instances: #[],
        constants: #[],
        ctx,
        locals: [],
        bytecode: emitter.new_child_emitter(),
    ]
    wasm_program.functions[] = wasm_func

    // Lambda index inside the table
    lambda_index.update(wasm_program.lambda_table.len)
    wasm_program.lambda_table[] = index

    wasm_func.add_param("lambda_instance", WType::I32)

    visit_code(ctx, wasm_func, instance.code)
}

fun WasmBackend.visit_const(key: MonomorphizationKey, instance: NConst, index: Id) {
    // Log::debug("Visiting const $key")
    let const_type = key.final_type
    let const_size = get_size_of(const_type)
    let const_init = false
    let data = ByteWriter::new()

    let inst_opt: Optional<NInst> = None()

    // Implicit return
    if instance.code.inst_list.len == 1 {
        inst_opt = Some(instance.code.inst_list.first()!!)
    }

    // Explicit return
    if instance.code.inst_list.len == 2 && instance.code.inst_list[1]!!.kind is NInstKind::Return {
        inst_opt = Some(instance.code.inst_list.first()!!)
    }

    // Constant values that don't need to be initialized
    if inst_opt.is_some() {
        let inst = inst_opt!!

        if inst.kind is NInstKind::Literal {
            let expr: NValue = (inst.kind as NInstKind::Literal).value

            when {
                expr is NValue::Int -> {
                    let value: Int = (expr as NValue::Int).value
                    data.add_int_le(value)
                }
                expr is NValue::Long -> {
                    let value: Long = (expr as NValue::Long).value
                    data.add_long_le(value)
                }
                expr is NValue::Float -> {
                    let float_value: Float = (expr as NValue::Float).value
                    let value: Int = float_value.reinterpret_as_int()
                    data.add_int_le(value)
                }
                expr is NValue::String -> {
                    let string_value: String = (expr as NValue::String).value
                    let address: Int = push_string(string_value)
                    data.add_int_le(address)
                }
                expr is NValue::Boolean -> {
                    let value: Boolean = (expr as NValue::Boolean).value
                    data.add_boolean(value)
                }
                expr is NValue::Nothing -> {
                    // Nothing has 0 size
                }
            }
            const_init = true
        }
    }

    // Initialize data with 0x00
    if !const_init {
        data.add_pad(0x00.to_byte(), const_size)
    }

    // Allocate a memory section
    let section = wasm_program.memory.add_section(data.bytes, "const ${instance.full_name}")

    // Store the header for later use
    let wconst = WConst @[
        index,
        instance,
        final_type: const_type,
        section,
        init_function: None(),
    ]
    consts[] = wconst

    if const_init {
        ret
    }

    // Initialize the constant in the init function
    let func_index = function_indices.next()

    let header = WFunctionHeader @[
        index: func_index,
        key,
        name: "init_const_${instance.full_name}",
        params: [],
        results: [encode_to_wasm_type(const_type)],
    ]

    // Wasm Function
    let wasm_func = WFunction @[
        name: header.name,
        source: WFunctionSource::Const @[instance, wconst],
        code: instance.code,
        header,
        let_declarations: #[],
        let_final_types: #[],
        inst_final_types: #[],
        compile_operation: #[],
        function_calls: #[],
        lambda_instances: #[],
        constants: #[],
        ctx: root_ctx,
        locals: [],
        bytecode: emitter.new_child_emitter(),
    ]
    wasm_program.functions[] = wasm_func

    visit_code(root_ctx, wasm_func, instance.code)
}

fun WasmBackend.visit_import(ctx: TypeMappingCtx, instance: NFunction, lib: String, name: String): Id {
    let key = get_key_for_function(ctx, instance)
    let log = already_visited[key]

    // Already visited
    if log.is_some() {
        ret log!!
    }

    let index = import_indices.next()
    let header = get_function_header(key, index, true)

    wasm_program.imports[] = WImport @[
        module_name: lib,
        name: name,
        header,
    ]

    already_visited[key] = index
    ret index
}

fun WasmBackend.visit_code(ctx: TypeMappingCtx, wasm_func: WFunction, code: NCode) {
    code.calculate_back_references()

    for inst in code.inst_list {
        visit_instruction(ctx, wasm_func, code, inst)
    }
}

fun WasmBackend.visit_instruction(ctx: TypeMappingCtx, wasm_func: WFunction, code: NCode, inst: NInst) {
    let final_type = ctx.convert_type(inst.type_token!!.find_type())
    wasm_func.inst_final_types[inst.id] = final_type

    when {
        inst.kind is NInstKind::Mark -> {}
        inst.kind is NInstKind::Let -> {
            let nvar: NVar = code.find_var((inst.kind as NInstKind::Let).variable)
            let nvar_type = ctx.convert_type(nvar.type_token!!.find_type())

            wasm_func.let_final_types[nvar.id] = nvar_type

            // zero size types are erased
            if get_size_of(nvar_type) == 0 {
                ret
            }

            let wasm_type = encode_to_wasm_type(nvar_type)

            // Upvalues are presented with Ptr<#T>
            if nvar.is_upvalue {
                // Call to alloc function
                let alloc_index = get_alloc_function(ctx)
                wasm_func.function_calls[inst.id] = WFuncCall::WFunction @[value: alloc_index, return_final_type: nvar_type]
            }

            let wvar: Optional<WVar> = None()

            if nvar.is_parameter {
                if nvar.is_upvalue {
                    let param = wasm_func.add_param(nvar.name, wasm_type)
                    let upvalue = wasm_func.add_local("upvalue_${inst.id}", WType::I32)
                    upvalue.copy_from = Some(param)
                    wvar = Some(upvalue)
                } else {
                    wvar = Some(wasm_func.add_param(nvar.name, wasm_type))
                }
            } else {
                if nvar.is_upvalue {
                    wasm_type = WType::I32
                }
                wvar = Some(wasm_func.add_local(nvar.name, wasm_type))
            }

            wasm_func.let_declarations[nvar.id] = wvar!!
        }
        inst.kind is NInstKind::LetUpvalue -> {
            let nvar: NVar = code.find_var((inst.kind as NInstKind::LetUpvalue).variable)
            let nvar_type = ctx.convert_type(nvar.type_token!!.find_type())

            wasm_func.let_final_types[nvar.id] = nvar_type

            // zero size types are erased
            if get_size_of(nvar_type) == 0 {
                ret
            }

            let wasm_type = encode_to_wasm_type(nvar_type)
            let wvar = wasm_func.add_local(nvar.name, wasm_type)
            wasm_func.let_declarations[nvar.id] = wvar
        }
        inst.kind is NInstKind::IfStart -> {}
        inst.kind is NInstKind::IfElse -> {}
        inst.kind is NInstKind::IfEnd -> {}
        inst.kind is NInstKind::IfChoose -> {}
        inst.kind is NInstKind::LoopStart -> {}
        inst.kind is NInstKind::LoopEnd -> {}
        inst.kind is NInstKind::BlockJump -> {}
        inst.kind is NInstKind::WhenStart -> {}
        inst.kind is NInstKind::WhenEnd -> {}
        inst.kind is NInstKind::FunCall -> {
            let call_site = (inst.kind as NInstKind::FunCall).call_site!!
            let func_target: Optional<NFunction> = None()

            let sub_ctx = ctx.new_child(inst.span)

            if call_site.target is NFunCallTarget::Tag {
                let tag_func = (call_site.target as NFunCallTarget::Tag).tag_func

                let generics = call_site.call_site_generics
                let final_tag_type = ctx.convert_type(generics.resolved.first()!!.find_type())

                for entry in tag_func.final_implementors {
                    let pattern = ctx.convert_pattern(entry.first)
                    let tag_type = entry.second.first
                    let func = entry.second.second

                    if pattern.matches_type(final_tag_type) {
                        find_tag_type_replacements(tag_type, final_tag_type, sub_ctx)
                        func_target = Some(func)
                        break
                    }
                }

                if func_target.is_none() {
                    crash("Unable to find implementation of tag ${tag_func.parent_tag.name} for type ${final_tag_type}")
                }
            }

            if call_site.target is NFunCallTarget::Func {
                func_target = Some((call_site.target as NFunCallTarget::Func).func)
            }

            let func = func_target!!

            // Use a inline wasm instruction
            let inline_annotation = func.annotations[ANNOTATION_WASM_INLINE]
            if inline_annotation.is_some() {
                let opcode = inline_annotation!!.get_arg("opcode")!!.get_string()!!
                let args = []
                let i = 0

                loop {
                    let arg = inline_annotation!!.get_arg("arg$i")
                    if arg.is_none() {
                        break
                    }
                    args[] = arg!!
                    i += 1
                }

                wasm_func.function_calls[inst.id] = WFuncCall::WOpcode @[value: opcode, args]
                ret
            }

            // Replace the generic types
            let generics = call_site.call_site_generics
            let generic_replacements = generics.resolved.find_types()
            let final_types = generic_replacements.map @{ i -> ctx.convert_type(i) }

            sub_ctx.add_generics(generics.generic_params, final_types)

            // External declaration
            let extern = func.annotations.get_extern_annotation()
            if extern.is_some() {
                let index = visit_import(sub_ctx, func, extern!!.lib, extern!!.name)
                wasm_func.function_calls[inst.id] = WFuncCall::WImport @[value: index]
                ret
            }

            let intrinsic_annotation = func.annotations[ANNOTATION_INTRINSIC]
            if intrinsic_annotation.is_some() && func.full_name == "call" {
                let final_lambda_type = sub_ctx.convert_type(func.header.parameters.first()!!.param_type!!)
                let header = get_indirect_function_header(final_lambda_type)

                wasm_func.function_calls[inst.id] = WFuncCall::WLambda @[type_id: header.index, table_id: 0]
                ret
            }

            let return_final_type = sub_ctx.convert_type(func.header.return_type!!)

            // Schedule the function for compilation
            let index = add_task_visit_function(sub_ctx, func)
            wasm_func.function_calls[inst.id] = WFuncCall::WFunction @[value: index, return_final_type]
        }
        inst.kind is NInstKind::BinaryOp -> {}
        inst.kind is NInstKind::Literal -> {}
        inst.kind is NInstKind::Return -> {}
        inst.kind is NInstKind::IsType -> {}
        inst.kind is NInstKind::AsType -> {}
        inst.kind is NInstKind::LoadVar -> {
            let opt_constant_id: Optional<Id> = (inst.kind as NInstKind::LoadVar).constant
            if opt_constant_id.is_none() {
                ret
            }
            let constant = program.find_const(opt_constant_id!!)
            wasm_func.constants[inst.id] = add_task_visit_const(constant)
        }
        inst.kind is NInstKind::StoreVar -> {}
        inst.kind is NInstKind::StoreField -> {}
        inst.kind is NInstKind::LoadField -> {}
        inst.kind is NInstKind::SizeOf -> {
            let size_of_type = (inst.kind as NInstKind::SizeOf).type_token!!.find_type()
            wasm_func.inst_final_types[inst.id] = ctx.convert_type(size_of_type)
        }
        inst.kind is NInstKind::IncludeAs -> {}
        inst.kind is NInstKind::Alloc -> {
            let alloc_index = get_alloc_function(ctx)

            wasm_func.function_calls[inst.id] = WFuncCall::WFunction @[value: alloc_index, return_final_type: final_type]
        }
        inst.kind is NInstKind::Lambda -> {
            let lambda_id = (inst.kind as NInstKind::Lambda).lambda_id
            let lambda = code.program.find_lambda(lambda_id)
            let sub_ctx = ctx.new_child(inst.span)
            lambda.ctx = Some(sub_ctx)

            // Instantiation of the lambda as wasm function
            let index = add_task_visit_lambda(sub_ctx, lambda, final_type)
            wasm_func.lambda_instances[inst.id] = index

            // Call to alloc function
            let alloc_index = get_alloc_function(ctx)

            wasm_func.function_calls[inst.id] = WFuncCall::WFunction @[value: alloc_index, return_final_type: final_type]
        }
        inst.kind is NInstKind::Link -> {}
        inst.kind is NInstKind::Comment -> {}
        inst.kind is NInstKind::Noop -> {}
        else -> {
            crash("Instruction not visited: $inst")
        }
    }
}

fun WasmBackend.get_alloc_function(ctx: TypeMappingCtx): Id {
    let alloc_functions = program.functions.filter @{ it -> it.full_name == "memory_alloc_internal" }
    let alloc_func = alloc_functions.last()!!
    ret add_task_visit_function(ctx, alloc_func)
}

// Check if a type that implements a tag matches the final type that will be used at runtime
fun WasmBackend.tag_type_matches_final_type(tag_type: Type, final_tag_type: FinalType): Boolean {
    if tag_type.is_generic() {
        ret true
    }

    let tag_type_params = tag_type.type_params
    if tag_type_params.len != final_tag_type.type_params.len {
        ret false
    }

    repeat tag_type.params.len {
        if !tag_type_matches_final_type(tag_type_params[it]!!, final_tag_type.type_params[it]!!) {
            ret false
        }
    }

    when {
        tag_type.kind is TypeKind::Struct && final_tag_type.kind is FinalTypeKind::Struct -> {
            ret (tag_type.kind as TypeKind::Struct).instance.id == (final_tag_type.kind as FinalTypeKind::Struct).instance.id
        }
        tag_type.kind is TypeKind::Option && final_tag_type.kind is FinalTypeKind::Option -> {
            ret (tag_type.kind as TypeKind::Option).instance.id == (final_tag_type.kind as FinalTypeKind::Option).instance.id
        }
        tag_type.kind is TypeKind::OptionItem && final_tag_type.kind is FinalTypeKind::Struct -> {
            ret (tag_type.kind as TypeKind::OptionItem).instance.id == (final_tag_type.kind as FinalTypeKind::Struct).instance.id
        }
        tag_type.kind is TypeKind::Lambda && final_tag_type.kind is FinalTypeKind::Lambda -> {
            ret (tag_type.kind as TypeKind::Lambda).instance.id == (final_tag_type.kind as FinalTypeKind::Lambda).instance.id
        }
    }

    ret false
}

fun WasmBackend.find_tag_type_replacements(left: Type, right: FinalType, ctx: TypeMappingCtx) {
    if left.is_generic() {
        let instance = (left.kind as TypeKind::Generic).instance
        ctx.add_generic(instance, right)
        ret
    }

    let left_params = left.type_params
    let right_params = right.type_params

    repeat min(left_params.len, right_params.len) {
        find_tag_type_replacements(left_params[it]!!, right_params[it]!!, ctx)
    }
}

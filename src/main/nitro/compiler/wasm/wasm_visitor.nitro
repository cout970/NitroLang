
fun WasmBackend.visit_program(main: NFunction): Id {
    // Start visiting the main function
    let index = add_task_visit_function(root_ctx.new_child(main.span), main)

    // Run the task queue
    while task_queue.is_not_empty() {
        let task = task_queue.remove_first()!!
        when {
            task is CompilationTask::VisitFunction -> {
                let t = task as CompilationTask::VisitFunction
                visit_function(t.ctx, t.key, t.instance, t.index)
            }
            task is CompilationTask::VisitLambda -> {
                let t = task as CompilationTask::VisitLambda
                visit_lambda(t.ctx, t.key, t.instance, t.index, t.lambda_index)
            }
            task is CompilationTask::VisitConst -> {
                let t = task as CompilationTask::VisitConst
                visit_const(t.key, t.instance, t.index)
            }
        }
    }

    ret index
}

fun WasmBackend.add_task_visit_function(ctx: TypeMappingCtx, instance: NFunction): Id {
    let key = get_key_for_function(ctx, instance)
    let log = already_visited[key]

    // Already queued or done
    if log.is_some() {
        ret log!!
    }

    let index = function_indices.next()

    task_queue[] = CompilationTask::VisitFunction @[
        key,
        index,
        instance,
        ctx,
    ]

    // Prevent duplicates
    already_visited[key] = index
    ret index
}

fun WasmBackend.add_task_visit_lambda(ctx: TypeMappingCtx, instance: NLambda, lambda_type: FinalType): Id {
    let index = function_indices.next()
    let lambda_index = Id::uninitialized()
    let key = MonomorphizationKey @[
        name: "lambda_${instance.id}",
        final_type: lambda_type,
    ]

    task_queue[] = CompilationTask::VisitLambda @[key, index, lambda_index, instance, ctx,]
    ret lambda_index
}

fun WasmBackend.add_task_visit_const(instance: NConst): Id {
    let key = get_key_for_const(instance)
    let log = already_visited[key]

    // Already queued or done
    if log.is_some() {
        ret log!!
    }

    let index = const_id_provider.next()
    task_queue[] = CompilationTask::VisitConst @[
        key,
        index,
        instance,
    ]

    already_visited[key] = index
    ret index
}

fun WasmBackend.visit_function(ctx: TypeMappingCtx, key: MonomorphizationKey, instance: NFunction, index: Id) {
//    Log::debug("Visiting function $key")
    let header = get_function_header(key, index)

    // Wasm Function
    let wasm_func = WFunction @[
        index,
        name: instance.full_name,
        source: WFunctionSource::Function @[instance],
        code: instance.code,
        header,
        let_declarations: #[],
        function_calls: #[],
        lambda_instances: #[],
        constants: #[],
        ctx,
        locals_provider: IdProvider::new(),
        locals: [],
        bytecode: WasmEmitter::new(),
    ]
    wasm_program.functions[] = wasm_func

    visit_code(ctx, wasm_func, instance.code)
}

fun WasmBackend.visit_lambda(ctx: TypeMappingCtx, key: MonomorphizationKey, instance: NLambda, index: Id, lambda_index: Id) {
//    Log::debug("Visiting function $key")
    let header = get_function_header(key, index)
    // First argument is the lambda itself, this is implicit
    header.params.add_first(WType::I32)

    // Wasm Function
    let wasm_func = WFunction @[
        index,
        name: header.name
        source: WFunctionSource::Lambda @[instance],
        code: instance.code,
        header,
        let_declarations: #[],
        function_calls: #[],
        lambda_instances: #[],
        constants: #[],
        ctx,
        locals_provider: IdProvider::new(),
        locals: [],
        bytecode: WasmEmitter::new(),
    ]
    wasm_program.functions[] = wasm_func

    // Lambda index inside the table
    lambda_index.update(wasm_program.lambda_table.len)
    wasm_program.lambda_table[] = index

    wasm_func.add_param("lambda_instance", WType::I32)

    visit_code(ctx, wasm_func, instance.code)
}

fun WasmBackend.visit_const(key: MonomorphizationKey, instance: NConst, index: Id) {
    // Log::debug("Visiting const $key")
    let const_type = key.final_type
    let const_size = get_size_of(const_type)
    let const_init = false
    let data: List<Byte> = List::new(const_size)

    // Constant values that don't need to be initialized
    if instance.code.inst_list.len == 1 {
        let inst = instance.code.inst_list.first()!!

        if inst.kind is NInstKind::Literal {
            let expr: NConstExpr = (inst.kind as NInstKind::Literal).value

            when {
                expr is NConstExpr::NConstInt -> {
                    let value: Int = (expr as NConstExpr::NConstInt).value
                    // Little endian
                    data[] = (value >> 24).to_byte()
                    data[] = (value >> 16).to_byte()
                    data[] = (value >> 8).to_byte()
                    data[] = value.to_byte()
                }
                expr is NConstExpr::NConstLong -> {
                    let value: Long = (expr as NConstExpr::NConstLong).value
                    // Little endian
                    data[] = (value >> 56L).to_byte()
                    data[] = (value >> 48L).to_byte()
                    data[] = (value >> 40L).to_byte()
                    data[] = (value >> 32L).to_byte()
                    data[] = (value >> 24L).to_byte()
                    data[] = (value >> 16L).to_byte()
                    data[] = (value >> 8L).to_byte()
                    data[] = value.to_byte()
                }
                expr is NConstExpr::NConstFloat -> {
                    let float_value: Float = (expr as NConstExpr::NConstFloat).value
                    let value: Int = float_value.reinterpret_as_int()
                    // Little endian
                    data[] = (value >> 24).to_byte()
                    data[] = (value >> 16).to_byte()
                    data[] = (value >> 8).to_byte()
                    data[] = value.to_byte()
                }
                expr is NConstExpr::NConstString -> {
                    let string_value: String = (expr as NConstExpr::NConstString).value
                    let address: Int = push_string(string_value)
                    // Little endian
                    data[] = (address >> 24).to_byte()
                    data[] = (address >> 16).to_byte()
                    data[] = (address >> 8).to_byte()
                    data[] = address.to_byte()
                }
                expr is NConstExpr::NConstBoolean -> {
                    let value: Boolean = (expr as NConstExpr::NConstBoolean).value
                    data[] = if value { 0x01.to_byte() } else { 0x00.to_byte() }
                }
                expr is NConstExpr::NConstNothing -> {
                    // Nothing has 0 size
                }
            }
            const_init = true
        }
    }

    // Initialize data with 0x00
    if !const_init {
        data.add_multiple_times(0x00.to_byte(), const_size)
    }

    // Allocate a memory section
    let section = wasm_program.memory.add_section(data, "const ${instance.full_name}")

    // Store the header for later use
    let wasm_const = WConst @[
        index,
        instance,
        final_type: const_type,
        section,
        init_function: None(),
    ]
    consts[] = wasm_const

    if const_init {
        ret
    }

    // Initialize the constant in the init function
    let func_index = function_indices.next()

    let header = WFunctionHeader @[
        index: func_index,
        key,
        name: "init_const_${instance.full_name}",
        params: [],
        results: [],
    ]

    // Wasm Function
    let wasm_func = WFunction @[
        index: func_index,
        name: header.name,
        source: WFunctionSource::Const @[instance],
        code: instance.code,
        header,
        let_declarations: #[],
        function_calls: #[],
        lambda_instances: #[],
        constants: #[],
        ctx: root_ctx,
        locals_provider: IdProvider::new(),
        locals: [],
        bytecode: WasmEmitter::new(),
    ]
    wasm_program.functions[] = wasm_func

    visit_code(root_ctx, wasm_func, instance.code)
}

fun WasmBackend.visit_import(ctx: TypeMappingCtx, instance: NFunction, lib: String, name: String): Id {
    let key = get_key_for_function(ctx, instance)
    let log = already_visited[key]

    // Already visited
    if log.is_some() {
        ret log!!
    }

    let index = import_indices.next()
    let header = get_function_header(key, index)

    wasm_program.imports[] = WImport @[
        module_name: lib,
        name: name,
        header,
    ]

    already_visited[key] = index
    ret index
}

fun WasmBackend.visit_code(ctx: TypeMappingCtx, wasm_func: WFunction, code: NCode) {
    code.calculate_back_references()

    for inst in code.inst_list {
        visit_instruction(ctx, wasm_func, code, inst)
    }
}

fun WasmBackend.visit_instruction(ctx: TypeMappingCtx, wasm_func: WFunction, code: NCode, inst: NInst) {
    when {
        inst.kind is NInstKind::Let -> {
            let nvar: NVar = code.find_var((inst.kind as NInstKind::Let).variable)
            let nvar_type = nvar.type_token!!.find_type()
            let final_type = ctx.convert_type(nvar_type)
            let wasm_type = encode_to_wasm_type(final_type)

            // Upvalues are presented with Ptr<#T>
            if nvar.is_upvalue {
                wasm_type = WType::I32

                // Call to alloc function
                let alloc_index = get_alloc_function(ctx)
                wasm_func.function_calls[inst.id] = WFuncCall::WFunction @[value: alloc_index]
            }

            let wvar = if nvar.is_parameter {
                wasm_func.add_param(nvar.name, wasm_type)
            } else {
                wasm_func.add_local(nvar.name, wasm_type)
            }

            wasm_func.let_declarations[nvar.id] = wvar
        }
        inst.kind is NInstKind::FunCall -> {
            let call_site = (inst.kind as NInstKind::FunCall).call_site!!
            let func: NFunction = call_site.func

            // Use a inline wasm instruction
            let inline_annotation = call_site.func.get_annotation("WasmInline")
            if inline_annotation.is_some() {
                let opcode = inline_annotation!!.get_arg("opcode")!!.get_string()!!

                wasm_func.function_calls[inst.id] = WFuncCall::WOpcode @[value: opcode]
                ret
            }

            // Replace the generic types
            let sub_ctx = ctx.new_child(inst.span)

            let generics = call_site.call_site_generics
            let generic_replacements = generics.resolved.find_types()
            let final_types = generic_replacements.map @{ i -> ctx.convert_type(i) }

            sub_ctx.add_generics(generics.generic_params, final_types)

            // External declaration
            let extern = func.get_extern_annotation()
            if extern.is_some() && !extern!!.autogenerate {
                let index = visit_import(sub_ctx, func, extern!!.lib, extern!!.name)
                wasm_func.function_calls[inst.id] = WFuncCall::WImport @[value: index]
                ret
            }

            let intrinsic_annotation = func.get_annotation("Intrinsic")
            if intrinsic_annotation.is_some() && func.full_name == "call" {
                let final_lambda_type = sub_ctx.convert_type(func.parameters.first()!!.param_type!!)
                let header = get_indirect_function_header(final_lambda_type)

                wasm_func.function_calls[inst.id] = WFuncCall::WLambda @[type_id: header.index, table_id: 0]
                ret
            }

            // Schedule the function for compilation
            let index = add_task_visit_function(sub_ctx, func)
            wasm_func.function_calls[inst.id] = WFuncCall::WFunction @[value: index]
        }
        inst.kind is NInstKind::LoadVar -> {
            let constant = (inst.kind as NInstKind::LoadVar).constant
            if constant.is_none() {
                ret
            }

            wasm_func.constants[inst.id] = add_task_visit_const(constant!!)
        }
        inst.kind is NInstKind::Alloc -> {
            let alloc_index = get_alloc_function(ctx)

            wasm_func.function_calls[inst.id] = WFuncCall::WFunction @[value: alloc_index]
        }
        inst.kind is NInstKind::Lambda -> {
            let lambda = (inst.kind as NInstKind::Lambda).instance
            let sub_ctx = ctx.new_child(inst.span)
            let lambda_type = sub_ctx.convert_type(inst.type_token!!.find_type())

            // Instantiation of the lambda as wasm function
            let index = add_task_visit_lambda(sub_ctx, lambda, lambda_type)
            wasm_func.lambda_instances[inst.id] = index

            // Call to alloc function
            let alloc_index = get_alloc_function(ctx)

            wasm_func.function_calls[inst.id] = WFuncCall::WFunction @[value: alloc_index]
        }
    }
}

fun WasmBackend.get_alloc_function(ctx: TypeMappingCtx): Id {
    // let func = program.functions.find @{ it -> it.full_name == "memory_alloc_internal" }!!
    // DEBUG allows to test the alloc instruction without including all the memory management code
    let alloc_func = program.functions.find @{ it -> it.full_name == "memory_alloc_internal2" }!!
    ret add_task_visit_function(ctx, alloc_func)
}

fun WFunction.add_local(name: String, wasm_type: WType): WVar {
    let index = locals_provider.next()
    let wvar = WVar @[
        index,
        kind: WVarKind::Local,
        name,
        wasm_type,
    ]
    locals[] = wvar
    ret wvar
}

fun WFunction.add_param(name: String, wasm_type: WType): WVar {
    let index = locals_provider.next()
    let wvar = WVar @[
        index,
        kind: WVarKind::Param,
        name,
        wasm_type,
    ]
    locals[] = wvar
    ret wvar
}
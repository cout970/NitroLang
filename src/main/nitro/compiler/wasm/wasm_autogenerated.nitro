
fun WasmBackend.visit_autogenerated_function(ctx: TypeMappingCtx, instance: NFunction, wasm_func: WFunction) {
    let name = instance.get_extern_annotation()!!.name

    when name {
        "int_get_ordering" -> {
            let ordering_values: List<NConst> = program.consts.filter @{ it -> it.path == "Ordering" }
            for nconst in ordering_values {
                add_task_visit_const(nconst)
            }
        }
        else -> {}
    }
}

fun WasmBackend.compile_autogenerated_function(ctx: TypeMappingCtx, instance: NFunction, wasm_func: WFunction) {
    let name = instance.get_extern_annotation()!!.name

    when name {
        "array_new" -> wasm_func.bytecode.compile_array_new(ctx, instance, wasm_func, this)
        "array_len" -> wasm_func.bytecode.compile_array_len(ctx, instance, wasm_func, this)
        "array_get" -> wasm_func.bytecode.compile_array_get(ctx, instance, wasm_func, this)
        "array_set" -> wasm_func.bytecode.compile_array_set(ctx, instance, wasm_func, this)
        "array_fill" -> wasm_func.bytecode.compile_array_fill(ctx, instance, wasm_func, this)
        "int_get_ordering" -> wasm_func.bytecode.compile_int_get_ordering(ctx, instance, wasm_func, this)
        else -> crash("Unknown autogenerated function: $name")
    }

//    if wasm_func.bytecode.debug_print {
//        println("------------------------------------------------------------------------------")
//        println("Compiled autogenerated function ${wasm_func.index}: ${wasm_func.header}")
//        println(wasm_func.bytecode.debug_buffer)
//        println("------------------------------------------------------------------------------")
//    }
}

fun WasmEmitter.compile_array_new(ctx: TypeMappingCtx, instance: NFunction, wasm_func: WFunction, backend: WasmBackend) {
    let array_item_type = wasm_func.header.key.final_type.type_params.first()!!
    let size = backend.get_ref_size_of(array_item_type)

    let alloc_index = backend.get_alloc_function(ctx)
    let len_local = 0
    let dup_local = wasm_func.add_local("dup", WType::I32).index.to_int()

    // Calculate size
    add_local_get(len_local)
    add_i32_const(size)
    add_i32_mul()
    add_i32_const(4)
    add_i32_add()

    // Alloc array
    add_call(alloc_index.to_int())

    // Store len in the first 4 bytes
    add_local_tee(dup_local)
    add_local_get(len_local)
    add_i32_store(0)

    // Return array
    add_local_get(dup_local)
    add_return()
}

fun WasmEmitter.compile_array_len(ctx: TypeMappingCtx, instance: NFunction, wasm_func: WFunction, backend: WasmBackend) {
    let this_local = 0

    add_local_get(this_local)
    add_i32_load(0)
    add_return()
}

fun WasmEmitter.compile_array_get(ctx: TypeMappingCtx, instance: NFunction, wasm_func: WFunction, backend: WasmBackend) {
    let array_type = wasm_func.header.key.final_type.type_params.first()!!
    let array_item_type = array_type.type_params.first()!!
    let size = backend.get_ref_size_of(array_item_type)
    let this_local = 0
    let index_local = 1

    if size == 0 {
        add_return()
    }

    // Pointer to the beginning of the array
    add_local_get(this_local)
    add_i32_const(4)
    add_i32_add()

    // Offset into the array
    add_local_get(index_local)
    add_i32_const(size)
    add_i32_mul()

    // Add the offset to the pointer
    add_i32_add()

    // Load the value
    add_load_by_type(array_item_type, backend)
    add_return()
}

fun WasmEmitter.compile_array_set(ctx: TypeMappingCtx, instance: NFunction, wasm_func: WFunction, backend: WasmBackend) {
    let array_type = wasm_func.header.key.final_type.type_params.first()!!
    let array_item_type = array_type.type_params.first()!!
    let size = backend.get_ref_size_of(array_item_type)
    let this_local = 0
    let index_local = 1
    let value_local = 2

    if size == 0 {
        add_return()
    }

    // Pointer to the beginning of the array
    add_local_get(this_local)
    add_i32_const(4)
    add_i32_add()

    // Offset into the array
    add_local_get(index_local)
    add_i32_const(size)
    add_i32_mul()

    // Add the offset to the pointer to get the address of the item
    add_i32_add()

    // Load the value
    add_local_get(value_local)
    add_store_by_type(array_item_type, backend)
    add_return()
}

fun WasmEmitter.compile_array_fill(ctx: TypeMappingCtx, instance: NFunction, wasm_func: WFunction, backend: WasmBackend) {
    let array_type = wasm_func.header.key.final_type.type_params.first()!!
    let array_item_type = array_type.type_params.first()!!
    let size = backend.get_ref_size_of(array_item_type)

    let this_local = 0
    let value_local = 1

    if size == 0 {
        add_return()
    }

    let index_local = wasm_func.add_local("index", WType::I32).index.to_int()
    let limit_local = wasm_func.add_local("limit", WType::I32).index.to_int()
    let ptr_local = wasm_func.add_local("ptr", WType::I32).index.to_int()

    // Pointer to the beginning of the array
    add_local_get(this_local)
    add_i32_const(4)
    add_i32_add()
    // Save current ptr, and keep a copy for the loop
    add_local_set(ptr_local)

    // Max value of ptr to break the loop
    add_local_get(this_local)
    add_i32_load(0)
    add_i32_const(size)
    add_i32_mul()
    add_local_get(ptr_local)
    add_i32_add()
    add_local_set(limit_local)

    // Loop
    add_block(0x40)
    add_loop(0x40)

    // if (ptr >= limit) break
    add_local_get(ptr_local)
    add_local_get(limit_local)
    add_i32_ge_s()

    add_if(0x40)
    add_br(2)
    add_end()

    // Load the item and store it
    add_local_get(ptr_local)
    add_local_get(value_local)
    add_store_by_type(array_item_type, backend)

    // ptr++
    add_local_get(ptr_local)
    add_i32_const(size)
    add_i32_add()
    add_local_set(ptr_local)

    // goto loop
    add_br(0)

    // loop end
    add_end()
    add_end()

    add_return()
}

fun WasmEmitter.compile_int_get_ordering(ctx: TypeMappingCtx, instance: NFunction, wasm_func: WFunction, backend: WasmBackend) {
    let equals = backend.consts.find @{ it -> it.instance.full_name == "Ordering::Equals" }!!
    let less = backend.consts.find @{ it -> it.instance.full_name == "Ordering::Less" }!!
    let greater = backend.consts.find @{ it -> it.instance.full_name == "Ordering::Greater" }!!

    // this == other
    add_local_get(0)
    add_local_get(1)
    add_i32_eq()
    add_if(0x40)
    add_i32_const(equals.section.offset)
    add_i32_load(0)
    add_return()
    add_end()

    // this < other
    add_local_get(0)
    add_local_get(1)
    add_i32_lt_s()
    add_if(0x40)
    add_i32_const(less.section.offset)
    add_i32_load(0)
    add_return()
    add_end()

    // else
    add_i32_const(greater.section.offset)
    add_i32_load(0)
    add_return()
}

fun WasmBackend.autogenerate_function_start_main() {
    let nothing_struct = program.structs.find @{ it -> it.full_name == "Nothing" }!!
    let key = MonomorphizationKey @[
        name: "_start_main",
        final_type: final_types.create_final_type(FinalTypeKind::Struct @[instance: nothing_struct], []),
    ]
    let index = function_indices.next()
    let header = WFunctionHeader @[
        index,
        key,
        name: "_start_main",
        params: [],
        results: [],
    ]
    let func = WFunction @[
        index,
        name: header.name,
        source: WFunctionSource::Autogenerated @[],
        code: NCode::new(Span::none(), header.name),
        header,
        let_declarations: #[],
        function_calls: #[],
        lambda_instances: #[],
        constants: #[],
        ctx: root_ctx,
        locals_provider: IdProvider::new(),
        locals: [],
        bytecode: WasmEmitter::new(),
    ]
    wasm_program.functions[] = func
}

fun WasmBackend.compile_function_start_main() {
    let func = wasm_program.functions.find @{ it -> it.header.name == "_start_main" }!!
    let main_func = wasm_program.functions.find @{ it -> it.header.name == "main" }!!

    for init_func in wasm_program.functions {
        if init_func.source is WFunctionSource::Const {
            let wconst = (init_func.source as WFunctionSource::Const).wconst

            func.bytecode.add_i32_const(wconst.section.offset)
            func.bytecode.add_call(init_func.index.to_int())
            func.bytecode.add_store_by_type(wconst.final_type, this)
        }
    }

    func.bytecode.add_call(main_func.index.to_int())
}
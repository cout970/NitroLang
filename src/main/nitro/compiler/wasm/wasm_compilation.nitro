
option InstResultAction {
    // The result of the instruction is not used
    Drop,
    // Keep the result on the stack
    Keep,
    // Save in a var for multiple uses or a use later
    Save {
        variable: WVar
    }
}

fun InstResultAction.to_string(): String {
    ret when {
        this is InstResultAction::Drop -> "Drop"
        this is InstResultAction::Keep -> "Keep"
        this is InstResultAction::Save -> "Save"
        else -> unreachable()
    }
}

// Compile the code for a function
fun WasmEmitter.compile_code(func: WFunction, backend: WasmBackend) {
    let code = func.code
    let map: Map<NInstId, InstResultAction> = #[]
    func.check_stack_allocation(backend, map)

    for inst in code.inst_list {
        if debug_print {
            debug_buffer[] = "--- #${inst.id} | ${inst} ---\n"
        }

        if inst.kind is NInstKind::Let {
            if debug_print {
                let nvar = (inst.kind as NInstKind::Let).variable
                let wvar = func.let_declarations[nvar]!!
                debug_print_line("local ${wvar.index.id} ${wvar.name}: ${wvar.wasm_type}")
            }
            continue
        }
        if inst.kind is NInstKind::IfStart {
            let kind = inst.kind as NInstKind::IfStart
            push(kind.condition, map)
            add_if(0x40)
            continue
        }
        if inst.kind is NInstKind::IfElse {
            add_else()
            continue
        }
        if inst.kind is NInstKind::IfEnd {
            add_end()
            continue
        }
        if inst.kind is NInstKind::IfChoose {
            let kind = inst.kind as NInstKind::IfChoose
            push(kind.condition, map)
            push(kind.if_true, map)
            push(kind.if_false, map)
            add_select()
            pop(inst.id, map)
            continue
        }
        if inst.kind is NInstKind::LoopStart {
            add_block(0x40)
            add_loop(0x40)
            continue
        }
        if inst.kind is NInstKind::BlockJump {
            let kind = inst.kind as NInstKind::BlockJump
            check(kind.block.is_some()) @{ "BlockJump without a block! #${inst.id} $inst\n$code" }

            let jump_to_block = code.find_block(kind.block!!)
            let curr_block = code.find_block(inst.block)

            add_br(curr_block.depth - jump_to_block.depth)
            continue
        }
        if inst.kind is NInstKind::LoopEnd {
            add_end()
            add_end()
            continue
        }
        if inst.kind is NInstKind::WhenStart {
            add_block(0x40)
            continue
        }
        if inst.kind is NInstKind::WhenEnd {
            add_end()
            continue
        }

        if inst.kind is NInstKind::FunCall {
            let kind = inst.kind as NInstKind::FunCall

            for arg in kind.arguments {
                push(arg, map)
            }

            let opt = func.function_calls[inst.id]!!

            when {
                opt is WFuncCall::WFunction -> {
                    let id_wrapper = (opt as WFuncCall::WFunction).value
                    add_call(id_wrapper.id)
                }
                opt is WFuncCall::WImport -> {
                    let id_wrapper = (opt as WFuncCall::WImport).value
                    add_call(id_wrapper.id)
                }
                opt is WFuncCall::WOpcode -> {
                    let opcode = (opt as WFuncCall::WOpcode).value
                    emit_opcode_by_name(opcode)
                }
                else -> unreachable()
            }

            pop(inst.id, map)
            continue
        }

        if inst.kind is NInstKind::Literal {
            let expr: NConstExpr = (inst.kind as NInstKind::Literal).value

            if expr is NConstExpr::NConstInt {
                let const_value = expr as NConstExpr::NConstInt
                add_i32_const(const_value.value)
                pop(inst.id, map)
                continue
            }
            if expr is NConstExpr::NConstLong {
                let const_value = expr as NConstExpr::NConstLong
                add_i64_const(const_value.value)
                pop(inst.id, map)
                continue
            }
            if expr is NConstExpr::NConstFloat {
                let const_value = expr as NConstExpr::NConstFloat
                add_f32_const(const_value.value)
                pop(inst.id, map)
                continue
            }
//            if expr is NConstExpr::NConstDouble {
//                let value = expr as NConstExpr::NConstDouble
//                add_f64_const(value.value)
//                continue
//            }
            if expr is NConstExpr::NConstString {
                let const_value = expr as NConstExpr::NConstString
                let ptr = backend.push_string(const_value.value)
                add_i32_const(ptr)
                pop(inst.id, map)
                continue
            }
            if expr is NConstExpr::NConstBoolean {
                let const_value = expr as NConstExpr::NConstBoolean
                add_i32_const(if const_value.value {1} else {0})
                pop(inst.id, map)
                continue
            }
            if expr is NConstExpr::NConstNothing {
                // Nothing has 0 size
                continue
            }
            crash("Unknown literal type: ${expr}")
        }

        if inst.kind is NInstKind::Return {
            let kind = inst.kind as NInstKind::Return
            push(kind.value, map)
            add_return()
            continue
        }

        if inst.kind is NInstKind::IsType {
            compile_inst_is_type(inst, func, backend, map, code)
            continue
        }
        // TODO
        if inst.kind is NInstKind::AsType {
            let kind = inst.kind as NInstKind::AsType
            push(kind.value, map)
            pop(inst.id, map)
            continue
        }
        if inst.kind is NInstKind::LoadVar {
            let kind = inst.kind as NInstKind::LoadVar

            if kind.constant.is_some() {
                let id_wrapper = func.constants[inst.id]!!
                let wconst = backend.find_const(id_wrapper.id)

                add_i32_const(wconst.section.offset)
                let size = add_load_by_type(wconst.final_type, backend)

                if size > 0 {
                    pop(inst.id, map)
                }
                continue
            }

            let wvar = func.let_declarations[kind.variable!!]!!

            add_local_get(wvar.index.id)
            pop(inst.id, map)
            continue
        }

        if inst.kind is NInstKind::StoreVar {
            let kind = inst.kind as NInstKind::StoreVar
            let wvar = func.let_declarations[kind.variable!!]!!

            push(kind.value, map)
            add_local_set(wvar.index.id)
            continue
        }

        if inst.kind is NInstKind::LoadField {
            let kind = inst.kind as NInstKind::LoadField
            check(kind.field.is_some()) @{ "LoadField without field! #${inst.id} $inst\n$code" }
            check(kind.field_type_token.is_some()) @{ "LoadField without field_type_token! #${inst.id} $inst\n$code" }

            let field = kind.field!!
            let field_type = func.ctx.convert_type(kind.field_type_token!!.find_type())

            // Zero size type, no need to load
            if backend.get_size_of(field_type) == 0 {
                continue
            }

            let instance_type = func.ctx.convert_type(code.find_inst_type_token(kind.instance)!!.find_type())
            let final_struct = backend.get_final_struct(field.parent_struct, instance_type)

            // Offset in the struct
            let offset = 0
            for field in final_struct.fields {
                if field.name == kind.name {
                    break
                }
                offset += field.size
            }

            push(kind.instance, map)
            add_i32_const(offset)
            add_i32_add()
            add_load_by_type(field_type, backend)
            pop(inst.id, map)
            continue
        }

        if inst.kind is NInstKind::StoreField {
            let kind = inst.kind as NInstKind::StoreField
            check(kind.field.is_some()) @{ "StoreField without field! #${inst.id} $inst\n$code" }
            check(kind.field_type_token.is_some()) @{ "StoreField without field_type_token! #${inst.id} $inst\n$code" }

            let field = kind.field!!
            let field_type = func.ctx.convert_type(kind.field_type_token!!.find_type())

            // Zero size type, no need to store
            if backend.get_size_of(field_type) == 0 {
                continue
            }

            let instance_type_token = code.find_inst_type_token(kind.instance)
            check(instance_type_token.is_some()) @{ "StoreField instance has not type! #${kind.instance}\n$code" }

            let instance_type = func.ctx.convert_type(instance_type_token!!.find_type())
            let final_struct = backend.get_final_struct(field.parent_struct, instance_type)

            // Offset in the struct
            let offset = 0
            for field in final_struct.fields {
                if field.name == kind.name {
                    break
                }
                offset += field.size
            }

            push(kind.instance, map)
            add_i32_const(offset)
            add_i32_add()
            push(kind.value, map)
            add_store_by_type(field_type, backend)
            continue
        }

        if inst.kind is NInstKind::SizeOf {
            let kind = inst.kind as NInstKind::SizeOf
            let final_type = func.ctx.convert_type(kind.type_token!!.find_type())
            let size = backend.get_size_of(final_type)
            add_i32_const(size)
            pop(inst.id, map)
            continue
        }

        if inst.kind is NInstKind::Alloc {
            let kind = inst.kind as NInstKind::Alloc
            let final_type = func.ctx.convert_type(kind.type_token!!.find_type())
            let size = backend.get_size_of(final_type)
            let call = func.function_calls[inst.id]!! as WFuncCall::WFunction

            add_i32_const(size)
            add_call(call.value.id)

            if final_type.kind is FinalTypeKind::Struct {
                let instance = (final_type.kind as FinalTypeKind::Struct).instance

                if instance.parent.is_some() {
                    let option_instance: NOption = instance.parent!!
                    let index = option_instance.get_index_of_item(instance)!!
                    let wvar = func.add_local("tmp_${inst.id}", WType::I32)

                    if debug_print {
                        debug_print_line("local ${wvar.index.id} ${wvar.name}: ${wvar.wasm_type}")
                    }

                    // Fill variant field
                    add_local_tee(wvar.index.id)
                    add_i32_const(index)
                    add_i32_store(0) // ptr: i32, value: i32 -> void
                    add_local_get(wvar.index.id)
                }
            }

            pop(inst.id, map)
            continue
        }

        if inst.kind is NInstKind::Lambda {
            // TODO
        }

        if inst.kind is NInstKind::Link {
            let kind = inst.kind as NInstKind::Link
            push(kind.linked_id, map)
            pop(inst.id, map)
            continue
        }

        if inst.kind is NInstKind::Comment || inst.kind is NInstKind::Noop {
            continue
        }

        crash("Found unknown instruction: $inst")
    }

    if debug_print && func.source is WFunctionSource::Function {
        let instance = (func.source as WFunctionSource::Function).instance
        let rtype = func.ctx.convert_type(instance.return_type!!)
        let ptypes = []

        for param in instance.parameters {
            ptypes[] = func.ctx.convert_type(param.param_type!!)
        }
        let ptypes_str = ptypes.join(", ")
        let header = "${instance.full_name}($ptypes_str) -> $rtype"
        println("------------------------------------------------------------------------------")
        println("Compiled ${func.index.id}: ${header}")
        println(debug_buffer)
        println(code)
        println("------------------------------------------------------------------------------")
    }
}

fun WasmEmitter.compile_inst_is_type(inst: NInst, func: WFunction, backend: WasmBackend, map: Map<NInstId, InstResultAction>, code: NCode) {
    let kind = inst.kind as NInstKind::IsType
    let final_type = func.ctx.convert_type(code.find_inst_type_token(kind.value)!!.find_type())
    let final_pattern = func.ctx.convert_pattern(kind.type_pattern.resolved!!)

    // Always true
    if final_pattern.kind is FinalTypePatternKind::Any {
        push(kind.value, map)
        add_drop()
        add_i32_const(1)
        pop(inst.id, map)
        ret
    }

    // Pattern info
    let final_type_kind: FinalTypeKind = (final_pattern.kind as FinalTypePatternKind::FinalType).final_type_kind
    let pattern_is_option_item = final_type_kind is FinalTypeKind::Struct && (final_type_kind as FinalTypeKind::Struct).instance.parent.is_some()

    // Type info
    let type_is_option = final_type.kind is FinalTypeKind::Option
    let type_is_option_item = final_type.kind is FinalTypeKind::Struct && (final_type.kind as FinalTypeKind::Struct).instance.parent.is_some()

    // If the type pattern is an option-item and the expression type is an option or item
    // The check is performed at runtime
    if pattern_is_option_item && (type_is_option || type_is_option_item) {
        let item_instance: NStruct = (final_type_kind as FinalTypeKind::Struct).instance
        let option_instance = item_instance.parent!!
        let index: Int = option_instance.get_index_of_item(item_instance)!!

        // Variant field
        push(kind.value, map)
        add_i32_load(STRUCT_HEADER_SIZE)
        // Expected value
        add_i32_const(index)
        // equal?
        add_i32_eq()
        pop(inst.id, map)
        ret
    }

    // If the type pattern is not an option item, or the expression type is not an option or item
    // The check is performed at compile time
    push(kind.value, map)
    add_drop()
    add_i32_const(if final_pattern.matches_type(final_type) { 1 } else { 0 })
    pop(inst.id, map)
}

// Compute whether an instruction should save its result in a local, keep it on the stack, or drop it
fun WFunction.check_stack_allocation(backend: WasmBackend, map: Map<NInstId, InstResultAction>) {

    for inst in code.inst_list {
        let final_type = ctx.convert_type(inst.type_token!!.find_type())
        let size = backend.get_size_of(final_type)

        // Zero size types don't exist on runtime,
        // if an expression returns nothing, the stack is already empty, we keep it that way
        if size == 0 {
            map[inst.id] = InstResultAction::Keep @[]
            continue
        }

        if size == 0 || inst.back_references.is_empty() {
            map[inst.id] = InstResultAction::Drop @[]
            continue
        }

        // No working as intended, left for future improvements
//        if inst.back_references.len == 1 {
//            let usage: NInstId = inst.back_references.first()!!
//            let inst_index = code.index_of(inst.id)!!
//            let usage_index = code.index_of(usage)!!
//
//            // Used in the next instruction, avoid saving and loading from a local
//            if inst_index.current + 1 == usage_index.current {
//                map[inst.id] = InstResultAction::Keep @[]
//                continue
//            }
//        }

        let variable = add_local("tmp_${inst.id}", backend.encode_to_wasm_type(final_type))
        map[inst.id] = InstResultAction::Save @[variable]
    }
}

// Generate the required code to push the result of an instruction to the stack
fun WasmEmitter.push(id: NInstId, map: Map<NInstId, InstResultAction>) {
    let remote_action: InstResultAction = map[id]!!

    // Original instruction did not save its result
    if remote_action is InstResultAction::Drop {
        ret
    }

    // Original instruction left its result on the stack, so it's already there
    if remote_action is InstResultAction::Keep {
        ret
    }

    // Original instruction saved its result in a local, so we need to load it
    if remote_action is InstResultAction::Save {
        let variable = (remote_action as InstResultAction::Save).variable
        add_local_get(variable.index.id)
        ret
    }
    unreachable()
}

// Generate the required code to save a value from the stack to a local, or keep the value, or discard it
fun WasmEmitter.pop(id: NInstId, map: Map<NInstId, InstResultAction>) {
    let local_action: InstResultAction = map[id]!!

    // Discard the result
    if local_action is InstResultAction::Drop {
        add_drop()
        ret
    }
    // Keep the result on the stack
    if local_action is InstResultAction::Keep {
        ret
    }
    // Save the result in a local
    if local_action is InstResultAction::Save {
        let variable = (local_action as InstResultAction::Save).variable

        if debug_print {
            debug_print_line("local ${variable.index.id} ${variable.name}: ${variable.wasm_type}")
        }

        add_local_set(variable.index.id)
        ret
    }
    unreachable()
}

// Add a load instruction based on the size of the type
fun WasmEmitter.add_load_by_type(final_type: FinalType, backend: WasmBackend): Int {
    let size = backend.get_size_of(final_type)

    when size {
        // Zero size types are not loaded
        0 -> {}
        // Load a single byte
        1 -> add_i32_load8_u(0)
        // Load two bytes
        2 -> add_i32_load16_u(0)
        // Load a 4 byte value: i32 or f32
        4 -> {
            if final_type.is_float() {
                add_f32_load(0)
            } else {
                add_i32_load(0)
            }
        }
        // Load an 8 byte value: i64
        8 -> add_i64_load(0)

        else -> crash("Unsupported size: $size")
    }

    ret size
}

// Add a store instruction based on the size of the type
fun WasmEmitter.add_store_by_type(final_type: FinalType, backend: WasmBackend): Int {
    let size = backend.get_size_of(final_type)

    when size {
        // Zero size types are not loaded
        0 -> {}
        // Load a single byte
        1 -> add_i32_store8(0)
        // Load two bytes
        2 -> add_i32_store16(0)
        // Load a 4 byte value: i32 or f32
        4 -> {
            if final_type.is_float() {
                add_f32_store(0)
            } else {
                add_i32_store(0)
            }
        }
        // Load an 8 byte value: i64
        8 -> add_i64_store(0)

        else -> crash("Unsupported size: $size")
    }

    ret size
}
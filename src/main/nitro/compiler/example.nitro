// Example to test code generation and execution

struct Example {
    a: Int,
    b: Int,
}

option AB {
    A {}
    B {}
}

@Extern [lib: "core", name: "i32_store"]
@WasmInline [opcode: "i32.store"]
fun i32_store(ptr: Int, value: Int) {}

@Extern [lib: "core", name: "i32_load"]
@WasmInline [opcode: "i32.load"]
fun i32_load(ptr: Int): Int {}

// Temporary extremely simple memory allocator
fun memory_alloc_internal2(size: Int): Int {
    let curr = i32_load(79996)

    if curr.is_equal(0) {
        curr = 80000
    }

    // align to 4 bytes boundary
    let alloc = (curr + 3) & -4
    curr = curr + size

    i32_store(79996, curr)
    ret alloc
}

fun main() {
//    if false {
//        println(1)
//    } else {
//        println(0)
//    }
//
//    if true {
//        println(2)
//    }
//
//    println(if true { 1 } else { 0 })
//
//    let a = 5
//    loop {
//        if 0.is_equal(a) {
//            break
//        }
//
//        println(a)
//        a -= 1
//    }
//
//    when true {
//        true -> println(1)
//        false -> println(0)
//    }
//    when {
//        true -> println(1)
//        else -> println(0)
//    }
//
//    println(when {
//        false -> 1
//        else -> 0
//    })
//
//    let example = Example @[a: 1, b: 2]
//    println(example.a)
//    println(example.b)
//
//    println("Hello world!")
//
//    println(second_function(3))
//
//    println("---")
//    println(1)
//    println(1L)
//    println(true)
//    println(false)
//    println(3.14f)
//    println(nothing)
//
//    println(size_of<Nothing>())
//    println(size_of<Boolean>())
//    println(size_of<Int>())
//    println(size_of<Long>())
//
//    let ab = AB::A @[]
//
//    println(ab is AB::A)
//    println(ab is AB::B)
//    println(ab is AB)
//
//    println(is_int(42))
//    println(is_int(42f))
//    println(is_int("42"))
//    println(two_args(42, 69L))
//
//    let res = give_me_lambda @{ it: Int ->
//        println("Hello from lambda!")
//        println(it)
//        ret it + 27
//    }
//
//    println(res)

    let a = 10
    let b = 11


    repeat 3 {
        update_upvalue @{ it: Int ->
            println(a)
            println(b)
            a += it
            b += it
            println(a)
            println(b)
        }

        println(a)
        println(b)
    }
}

fun update_upvalue(l: (Int) -> Nothing) {
    l.call(100)
}

//fun give_me_lambda(l: (Int) -> Int): Int {
//    ret l.call(42)
//}
//
//fun two_args(a: Int, b: Long): Float {
//    ret 1f
//}
//
//fun <#T> is_int(a: #T): Boolean {
//    ret a is Int
//}
//
//fun second_function(arg: Float): Int {
//    ret arg.to_int()
//}

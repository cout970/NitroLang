// Example to test code generation and execution

//struct Example {
//    a: Int,
//    b: Int,
//}
//
//option AB {
//    A {}
//    B {}
//}

@Extern [lib: "core", name: "i32_store"]
@WasmInline [opcode: "i32.store"]
fun i32_store(ptr: Int, value: Int) {}

@Extern [lib: "core", name: "i32_load"]
@WasmInline [opcode: "i32.load"]
fun i32_load(ptr: Int): Int {}

// Temporary extremely simple memory allocator
fun memory_alloc_internal2(size: Int): Int {
    let curr = i32_load(79996)

    if curr.is_equal(0) {
        curr = 80000
    }

    // align to 4 bytes boundary
    let alloc = (curr + 3) & -4
    curr = curr + size

    i32_store(79996, curr)
    ret alloc
}

fun main() {
//    if false {
//        println(1)
//    } else {
//        println(0)
//    }
//
//    if true {
//        println(2)
//    }
//
//    println(if true { 1 } else { 0 })
//
//    let a = 5
//    loop {
//        if 0.is_equal(a) {
//            break
//        }
//
//        println(a)
//        a -= 1
//    }
//
//    when true {
//        true -> println(1)
//        false -> println(0)
//    }
//    when {
//        true -> println(1)
//        else -> println(0)
//    }
//
//    println(when {
//        false -> 1
//        else -> 0
//    })
//
//    let example = Example @[a: 1, b: 2]
//    println(example.a)
//    println(example.b)
//
//    println("Hello world!")
//
//    println(second_function(3))
//
//    println("---")
//    println(1)
//    println(1L)
//    println(true)
//    println(false)
//    println(3.14f)
//    println(nothing)
//
//    println(size_of<Nothing>())
//    println(size_of<Boolean>())
//    println(size_of<Int>())
//    println(size_of<Long>())
//
//    let ab = AB::A @[]
//
//    println(ab is AB::A)
//    println(ab is AB::B)
//    println(ab is AB)
//
//    println(is_int(42))
//    println(is_int(42f))
//    println(is_int("42"))
//    println(two_args(42, 69L))
//
//    let res = give_me_lambda @{ it: Int ->
//        println("Hello from lambda!")
//        println(it)
//        ret it + 27
//    }
//
//    println(res)
//
//    let a = 0
//    let b = 1
//
//    repeat 3 {
//        update_upvalue @{ c: Float, d: Long ->
//            println(a)
//            println(b)
//            a += c.to_int()
//            b += d.to_int()
//            println(a)
//            println(b)
//        }
//
//        println(a)
//        println(b)
//    }

    let array = Array::new<Long>(10)

    repeat 10 {
        array[it] = (5 * it * it * it * it * it * 2).to_long()
    }

    repeat array.len {
        println(array[it])
    }

    println("---")
//
//    array.fill(-1L)
//
//    repeat array.len {
//        println(array[it])
//    }
//
    // DEBUG
    memory_alloc_internal2(0)
    println(2 * 3 * 4 * 5 * 6 * 7)
}

//fun update_upvalue(l: (Float, Long) -> Nothing) {
//    l.call(100f, 1000L)
//}

//fun give_me_lambda(l: (Int) -> Int): Int {
//    ret l.call(42)
//}
//
//fun two_args(a: Int, b: Long): Float {
//    ret 1f
//}
//
//fun <#T> is_int(a: #T): Boolean {
//    ret a is Int
//}
//
//fun second_function(arg: Float): Int {
//    ret arg.to_int()
//}

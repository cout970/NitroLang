
// definition
//      : annotation* definitionChoice NL* ;
//
// definitionChoice
//      : structDefinition
//      | optionDefinition
//      | functionDefinition
//      | includeDefinition
//      | useDefinition # Ignored for now
//      | aliasDefinition
//      | moduleDefinition
//      | constDefinition
//      | tagDefinition # Ignored for now
//      | typeAliasDefinition
//      | enumDefinition # Ignored for now
//      | testDefinition # Ignored for now
//      ;

fun Parser.read_definition(): Parsed<Nothing> {
    let annotations: List<NAnnotation> = []

    while lexer.current_token_kind == TokenKind::AT {
        let parsed = parse_annotation()

        if parsed.is_error() {
            recover_from_error()
            continue
        }

        annotations[] = parsed!!
    }

    skip_nl()

    when (lexer.current_token_kind) {
        TokenKind::STRUCT -> read_struct_definition(annotations)?
        TokenKind::OPTION -> read_option_definition(annotations)?
        TokenKind::INCLUDE -> read_include_definition(annotations)?
        TokenKind::TYPE_ALIAS -> read_type_alias_definition(annotations)?
        TokenKind::MODULE -> read_module_definition(annotations)?
        TokenKind::LET -> read_const_definition(annotations)?
        TokenKind::FUN -> read_function_definition(annotations)?
        TokenKind::TEST -> read_test_definition(annotations)?
        else -> {
            ret parse_error(ParseError::ExpectedDefinition, lexer.current_token)
        }
    }

    ret found(nothing)
}

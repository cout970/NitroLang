
// E.g. expr @{ }
// E.g. expr[index]
// E.g. expr.field
// E.g. expr
// E.g. true()
// E.g. expr.field()
// E.g. func()()
// E.g. break()
// E.g. result!!
// E.g. result?
// expressionWithSuffix
//     : expressionWithSuffix QUESTION_MARK
//     | expressionWithSuffix BANGBANG
//     | expressionWithSuffix LBRACKET NL* expression NL* (COMMA NL* expression NL*)* RBRACKET
//     | expressionWithSuffix NL? DOT anyName
//     | expressionWithSuffix NL? DOT modulePath? anyName callSuffix
//     | expressionBase
//     ;

fun Parser.read_expression_with_suffix(code: NCode): Parsed<NInstId> {
    let last = read_expression_base(code)?

    loop {
        let span = lexer.current_token_span

        if lexer.current_token_kind == TokenKind::QUESTION_MARK {
            // `last?`
            // Becomes:
            // ```
            // if last.is_returnable_error() {
            //    return last.convert_error()
            // }
            // last.get_or_crash()
            // ```

            lexer.next_token()
            let call = code.add_fun_call(span, "", "is_returnable_error", [last], [])

            code.add_if_start(span, call.id)
            let call2 = code.add_fun_call(span, "", "convert_error", [last], [])
            code.add_return(span, call2.id)
            code.add_if_end(span)

            let call3 = code.add_fun_call(span, "", "get_or_crash", [last], [])
            last = call3.id
            continue
        }

        if lexer.current_token_kind == TokenKind::BANGBANG {
            // `last!!`
            // Becomes:
            // ```
            // last.get_or_crash()
            // ```

            lexer.next_token()
            let call = code.add_fun_call(span, "", "get_or_crash", [last], [])
            last = call.id
            continue
        }

        if lexer.current_token_kind == TokenKind::LBRACKET {
            // `last[1, 2, 3, 4]`
            // Becomes:
            // ```
            // last.get(1, 2, 3, 4)
            // ```

            lexer.next_token()
            let args = [last]

            read_until_delimited(TokenKind::RBRACKET) @{
                args[] = read_expression(code)?
                ret found(nothing)
            }?

            let call = code.add_fun_call(span, "", "get", args, [])
            last = call.id
            continue
        }

        if lexer.next_non_nl_token_kind == TokenKind::DOT {
            skip_nl()
            lexer.next_token()

            let path = read_module_path()?
            let name = read_name()?

            let type_param_args = []

            // Function call with type arguments, i.e. my_func<A, B, C>()
            if lexer.current_token_kind == TokenKind::LTH {
                type_param_args = read_type_param_args()?
            }

            // Function call
            if lexer.current_token_kind == TokenKind::LPAREN {
                let args = read_expression_function_call_params(code)?
                args.add_first(last)

                if lexer.current_token_kind == TokenKind::LAMBDA_START {
                    args[] = read_expression_function_call_end(code)?
                }

                let call = code.add_fun_call(span, path, name, args, type_param_args)
                last = call.id
                continue
            }

            // Function call end
            if lexer.current_token_kind == TokenKind::LAMBDA_START {
                let args = [last]
                args[] = read_expression_function_call_end(code)?

                let call = code.add_fun_call(span, path, name, args, type_param_args)
                last = call.id
                continue
            }

            // Field access
            if type_param_args.len() > 0 {
                report_error("Type arguments are only allowed in field access", span)
            }

            if path != "" {
                report_error("Field access cannot use a module path prefix", span)
            }

            let access = code.add_load_field(span, last, name)
            last = access.id
            continue
        }

        break
    }

    ret found(last)
}


// structDefinition
//      : STRUCT modulePath? anyName typeParamsDef? NL* structBody;
//
// E.g. { a: Int, b: Int }
// structBody
//      : LBRACE NL* (structField (commaOrNl structField)* COMMA?)? NL* RBRACE ;
//
// E.g. value: Int,
// structField
//      : INTERNAL? anyName COLON typeUsage;

struct NStruct {
    id: Id
    span: Span
    annotations: List<NAnnotation>
    path: String
    name: String
    fields: List<NStructField>
    generics: NGenericParams
    parent: Optional<NOption>
    is_enum: Boolean
    full_name_cache: Optional<String>
}

struct NStructField {
    span: Span
    name: String
    parent_struct: NStruct
    offset: Int
    type_usage: NTypeUsage
    field_type: Optional<Type>
}

fun Parser.read_struct_definition(annotations: List<NAnnotation>): Parsed<Nothing> {
    skip_token_kind(TokenKind::STRUCT)?
    let span = lexer.current_token_span
    let path = read_declaration_module_path()?
    let name = read_name()?

    let def = NStruct @[
        id: id_provider.next(),
        span,
        annotations,
        path,
        name,
        generics: NGenericParams::new(),
        fields: [],
        parent: None(),
        is_enum: false,
        full_name_cache: None(),
    ]
    program.structs[] = def
    declare_name(Path::join(def.path, def.name), def.span)

    start_generics_collection(def.generics, NGenericSource::Struct)
    defer { stop_generics_collection() }

    read_type_params_def()?

    skip_nl()
    skip_token_kind(TokenKind::LBRACE)?
    skip_nl()
    read_until_delimited(TokenKind::RBRACE) @{
        def.fields[] = read_struct_field(def)?
        ret found(nothing)
    }?

    ret found(nothing)
}

fun Parser.read_struct_field(def: NStruct): Parsed<NStructField> {
    let span = lexer.current_token_span
    let name = read_name()?

    skip_token_kind(TokenKind::COLON)?

    let type_usage = read_type_usage()?

    ret found(NStructField @[
        span,
        name,
        parent_struct: def,
        offset: def.fields.len,
        type_usage,
        field_type: None(),
    ])
}

fun NStruct.get_full_name(): String {
    if full_name_cache.is_some() {
        ret full_name_cache!!
    }

    let full_name = Path::join(path, name)
    full_name_cache = Some(full_name)
    ret full_name
}

fun NStruct.get_ordering(other: NStruct): Ordering = this.id <=> other.id

fun NStruct.to_string(): String {
    let prefix = ""

    for a in annotations {
        prefix = "$prefix$a\n"
    }

    let fields_str = if fields.len > 0 { "{\n" } else { "{" }

    for field in fields {
        fields_str += "  ${field.name}: ${field.type_usage}\n"
    }
    fields_str = fields_str + "}"
    let full_name = Path::join(path, name)

    ret "${prefix}struct $full_name $fields_str  // $span"
}

fun ByteBuffer.serialize_struct(value: NStruct) {
    let frame = start_frame(true)
    serialize_id(value.id)
    serialize_span(value.span)
    write_int(value.annotations.len)
    for a in value.annotations {
        serialize_annotation(a)
    }
    write_string(value.path)
    write_string(value.name)
//    serialize_generics(value.generics)
    write_boolean(value.is_enum)

    write_int(value.fields.len)
    for f in value.fields {
        serialize_struct_field(f)
    }

    end_frame(frame)
}

fun ByteBuffer.deserialize_struct(): NStruct {
    let frame = start_frame(false)
    let id = deserialize_id()
    let span = deserialize_span()

    let annotations = []
    repeat read_int() {
        annotations[] = deserialize_annotation()
    }

    let path = read_string()
    let name = read_string()

    let generics = NGenericParams::new()
    let fields = []


    let is_enum = read_boolean()
    let parent = None()
    let full_name_cache = None()

    let instance = NStruct @[id, span, annotations, path, name, generics, fields, parent, is_enum, full_name_cache]

    repeat read_int() {
        fields[] = deserialize_struct_field(instance)
    }

    end_frame(frame)
    ret instance
}

fun ByteBuffer.serialize_struct_field(value: NStructField) {
    let frame = start_frame(true)
    serialize_span(value.span)
    write_string(value.name)
    write_int(value.offset)
    serialize_type_usage(value.type_usage)
    end_frame(frame)
}

fun ByteBuffer.deserialize_struct_field(parent_struct: NStruct): NStructField {
    let frame = start_frame(false)
    let span = deserialize_span()
    let name = read_string()
    let offset = read_int()
    let type_usage = deserialize_type_usage()
    end_frame(frame)

    ret NStructField @[
        span,
        name,
        parent_struct,
        offset,
        type_usage,
        field_type: None(),
    ]
}
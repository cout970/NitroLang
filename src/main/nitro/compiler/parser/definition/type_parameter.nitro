
// typeParamsDef
//      : LTH NL* typeParamDef (commaOrNl typeParamDef)* COMMA? NL* GTH ;
//
// typeParamDef
//       : typeParameter COLON typeUsage (COMMA typeUsage)*
//       | typeParameter
//       ;
//
// // #T, #A, #B, List<#A>
// typeParameter
//       : HASH anyName ;

// <#T, #A>
fun Parser.read_type_params_def(): Parsed<Nothing> {
    if lexer.current_token_kind != TokenKind::LTH {
        ret found(nothing)
    }

    // Skip `<`
    lexer.next_token()

    read_until_delimited(TokenKind::GTH) @{
        current_generics.definitions[] = read_type_param_def()?
        ret found(nothing)
    }?

    ret found(nothing)
}

fun Parser.read_type_param_def(): Parsed<NGeneric> {
    // `#A: Type1 | Type2` or just `#B`
    // Also `#A: tag Type1 | tag Type2` is valid
    let span = lexer.current_token_span
    let name = read_type_parameter()?

    let def = NGeneric @[
        id: id_provider.next(),
        span,
        name,
        source: current_generics.source,
        bounds: []
    ]

    if lexer.current_token_kind != TokenKind::COLON {
        ret found(def)
    }

    // Skip `:`
    lexer.next_token()

    // Read list of tag bounds delimited by `|`
    loop {
        // Skip tag
        if lexer.current_token_kind == TokenKind::TAG {
            lexer.next_token()
        }

        def.bounds[] = NGenericBounds @[name: read_name()?, tag_instance: None()]

        // End of the list
        if lexer.current_token_kind != TokenKind::OR {
            break
        }

        // Skip `|`
        lexer.next_token()
    }

    ret found(def)
}

fun Parser.read_type_parameter(): Parsed<String> {
    if lexer.current_token_kind != TokenKind::HASH {
        ret parse_error(ParseError::ExpectedTypeParameter, lexer.current_token)
    }

    // Skip `#`
    lexer.next_token()

    ret read_name()
}

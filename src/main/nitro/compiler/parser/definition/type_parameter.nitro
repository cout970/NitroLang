
// typeParamsDef
//      : LTH NL* typeParamDef (commaOrNl typeParamDef)* COMMA? NL* GTH ;
//
// typeParamDef
//       : typeParameter COLON typeUsage (COMMA typeUsage)*
//       | typeParameter
//       ;
//
// // #T, #A, #B, List<#A>
// typeParameter
//       : HASH anyName ;

struct NGeneric {
    span: Span
    name: String
    constraints: List<NTypeUsage>
}

struct NGenericParams {
    definitions: List<NGeneric>
}

fun NGenericParams::new(): NGenericParams {
    ret NGenericParams @[
        definitions: []
    ]
}

// <#T, #A>
fun Parser.read_type_params_def(generics: NGenericParams): Parsed<Nothing> {
    if lexer.current_token_kind != TokenKind::LTH {
        ret found(nothing)
    }

    // Skip `<`
    lexer.next_token()

    read_until_delimited(TokenKind::GTH) @{
        generics.definitions[] = read_type_param_def()?
        ret found(nothing)
    }?

    ret found(nothing)
}

fun Parser.read_type_param_def(): Parsed<NGeneric> {
    // `#A: Type1, Type2` or just `#B`
    let span = lexer.current_token_span
    let name = read_type_parameter()?

    let def = NGeneric @[
        span,
        name,
        constraints: []
    ]

    if lexer.current_token_kind != TokenKind::COLON {
        ret found(def)
    }

    lexer.next_token()

    def.constraints[] = read_type_usage()?

    loop {
        // End of the list
        if lexer.current_token_kind != TokenKind::COMMA {
            break
        }

        // Break so read_type_params_def() can read the next item
        if lexer.next_token_kind == TokenKind::HASH {
            break
        }

        // Skip comma
        lexer.next_token()

        // Found new constraint
        if lexer.current_token_kind != TokenKind::HASH {
            def.constraints[] = read_type_usage()?
        }
    }

    ret found(def)
}

fun Parser.read_type_parameter(): Parsed<String> {
    if lexer.current_token_kind != TokenKind::HASH {
        ret parse_error(ParseError::ExpectedTypeParameter, lexer.current_token)
    }

    // Skip `#`
    lexer.next_token()

    ret read_name()
}

fun NGeneric.get_hash(): Int = span.get_hash()
fun NGeneric.get_ordering(other: NGeneric): Ordering = span.get_ordering(other.span)

fun NGeneric.to_string(): String {
    if constraints.is_empty() {
        ret "#$name"
    }
    let s = constraints.join(", ")

    ret "#$name: s"
}

fun NGenericParams.to_string(): String {
    if definitions.is_empty() {
        ret ""
    }

    let s = ""

    for def in definitions {
        if s.is_not_empty() {
            s += ", "
        }
        s += def.to_string()
    }

    ret "<$s>"
}
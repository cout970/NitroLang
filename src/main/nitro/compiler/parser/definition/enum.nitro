
// E.g. enum Direction { Up, Down, Left, Right, Front, Back }
// enumDefinition
//     : ENUM modulePath? anyName NL* LBRACE NL* enumFields? NL* enumValue (commaOrNl enumValue)* COMMA? NL* RBRACE
//     | ENUM modulePath? anyName NL* LBRACE NL* enumValue (commaOrNl enumValue)* COMMA? NL* enumFields? NL* RBRACE
//     ;

// enumFields
//     : enumField (commaOrNl enumField)* COMMA? ;

// E.g. let name: String = "John"
// enumField
//     : LET anyName COLON typeUsage ;

// E.g. Up, Down, Left, Right, Front, Back
// E.g. Red $[rgb: 0xFF0000], Green $[rgb: 0x00FF00], Blue $[rgb: 0x0000FF
// enumValue
//     : anyName
//     | anyName STRUCT_START NL* (enumValueInit (commaOrNl enumValueInit)* COMMA?)? NL* RBRACKET
//     ;

// E.g. rgb: 0xFF0000
// enumValueInit
//     : anyName COLON NL* expression ;

struct NEnumEntry {
    span: Span
    name: String
    variant: Int
    value_init: List<NEnumValueInit>
    constant: Optional<NConst>
}

struct NEnumValueInit {
    field_name: String
    code: NCode
}

fun Parser.read_enum_definition(annotations: List<NAnnotation>): Parsed<Nothing> {
    // Enums are desugared into a struct and a module with the same name
    // enum Direction {
    //    Up      @[name: "up"]
    //    Down    @[name: "down"]
    //    Left    @[name: "left"]
    //    Right   @[name: "right"]
    //    Front   @[name: "front"]
    //    Back    @[name: "back"]
    //
    //    let name: String
    // }
    // ---
    // struct Direction {
    //    let name: String
    // }
    // mod Direction {
    //    let Up: Direction = Direction @[name: "up"]
    //    let Down: Direction = Direction @[name: "down"]
    //    let Left: Direction = Direction @[name: "left"]
    //    let Right: Direction = Direction @[name: "right"]
    //    let Front: Direction = Direction @[name: "front"]
    //    let Back: Direction = Direction @[name: "back"]
    //
    //    // Autogenerated:
    //    fun values(): List<Direction> = #[Up, Down, Left, Right, Front, Back]
    //    fun from_variant(index: Int): Optional<Direction> {}
    //    fun Direction.to_string(): String {}
    // }
    skip_token_kind(TokenKind::ENUM)?
    let span = lexer.current_token_span
    let path = read_declaration_module_path()?
    let name = read_name()?
    skip_nl()

    skip_token_kind(TokenKind::LBRACE)?
    skip_nl()

    let def = NStruct @[
        id: id_provider.next(),
        span,
        annotations,
        path,
        name,
        full_name: Path::join(path, name),
        generics: NGenericParams::new(NGenericSource::Struct),
        fields: [],
        parent: None(),
        is_enum: true,
    ]
    program.structs[] = def
    declare_name(Path::join(def.path, def.name), def.span)

    def.fields[] = NStructField @[
        span,
        name: VARIANT_FIELD_NAME,
        offset: 0,
        parent_struct: def,
        type_usage: NTypeUsage::simple(span, "Int"),
        field_type: None(),
    ]

    let module_path = Path::join(path, name)

    read_enum_fields(def)?
    let enum_entries: List<NEnumEntry> = read_enum_entries(def)?
    read_enum_fields(def)?

    skip_token_kind(TokenKind::RBRACE)?

    let all_field_names: List<String> = []

    for field in def.fields {
        if field.name in all_field_names {
            report_error("Duplicate field name: ${field.name}", span)
            continue
        }
        all_field_names[] = field.name
    }

    let enum_type_usage = NTypeUsage::simple_with_path(span, path, name)

     // Autogenerated constants
    for entry in enum_entries {

        let full_name = Path::join(module_path, entry.name)
        let const_id = id_provider.next()
        let const_code = NCode::new(program, NCodeContainer::None @[])

        program.codes[] = const_code

        let const_def = NConst @[
            program,
            id: const_id,
            span: entry.span,
            annotations: [],
            path: module_path,
            name: entry.name,
            generics: NGenericParams::new(NGenericSource::Const),
            type_usage: enum_type_usage,
            const_type: None(),
            code_id: const_code.id,
            full_name,
        ]

        const_code.container = NCodeContainer::Const @[def: const_def]
        program.consts[] = const_def
        declare_name(Path::join(const_def.path, const_def.name), const_def.span)

        entry.constant = Some(const_def)

        let alloc = const_code.add_alloc(entry.span, enum_type_usage)
        (alloc.kind as NInstKind::Alloc).is_enum = true

        let used_field_names: List<String> = []

        // Alloc initializes the variant field for options, but enums are regular structs,
        // so we need to initialize it manually
        let variant_value = const_code.add_lit_int(entry.span, entry.variant)
        const_code.add_store_field(entry.span, alloc.id, VARIANT_FIELD_NAME, variant_value.id)
        // Variant field
        used_field_names[] = VARIANT_FIELD_NAME

        // Rest of fields
        for i in entry.value_init {
            const_code.merge(i.code)
            used_field_names[] = i.field_name

            if const_code.last_expression.is_none() {
                report_error("Expecting expression, not found", entry.span)
                continue
            }

            const_code.add_store_field(entry.span, alloc.id, i.field_name, const_code.last_expression!!)
        }

        let return_inst = const_code.add_return(entry.span, alloc.id)
        const_code.last_expression = Some(return_inst.id)

        // Missing fields to init?
        if all_field_names.len > used_field_names.len {
            let missing_fields: List<String> = []
            for field in all_field_names {
                if !used_field_names.contains(field) {
                    missing_fields[] = field
                }
            }

            let missing_fields_str = missing_fields.join(", ")
            report_error("Missing fields: $missing_fields_str", entry.span)
        }
    }

    autogenerate_enum_default_methods(def, enum_entries)

    ret found(nothing)
}

fun Parser.read_enum_fields(def: NStruct): Parsed<Nothing> {
    while lexer.current_token_kind == TokenKind::LET {
        let span = lexer.current_token_span
        skip_token_kind(TokenKind::LET)?
        let field_name = read_name()?
        skip_token_kind(TokenKind::COLON)?
        let type_usage = read_type_usage()?

        def.fields[] = NStructField @[
            span,
            name: field_name,
            parent_struct: def,
            offset: def.fields.len,
            type_usage,
            field_type: None(),
        ]

        skip_nl()
    }

    ret found(nothing)
}

fun Parser.read_enum_entries(def: NStruct): Parsed<List<NEnumEntry>> {
    let enum_entries: List<NEnumEntry> = []
    let variant = 0

    loop {
        if lexer.current_token_kind == TokenKind::LET || lexer.current_token_kind == TokenKind::RBRACE {
            break
        }

        let span = lexer.current_token_span
        let entry_name = read_name()?
        let entry = NEnumEntry @[
            span,
            name: entry_name,
            variant,
            value_init: [],
            constant: None(),
        ]
        variant += 1
        enum_entries[] = entry

        if lexer.current_token_kind == TokenKind::STRUCT_START {
            skip_token_kind(TokenKind::STRUCT_START)?
            skip_nl()

            read_until_delimited(TokenKind::RBRACKET) @{
                let span = lexer.current_token_span
                let field_name = read_name()?
                skip_token_kind(TokenKind::COLON)?
                skip_nl()
                let code = NCode::new(program, NCodeContainer::None @[])
                read_expression(code)?

                entry.value_init[] = NEnumValueInit @[
                    field_name,
                    code,
                ]
                ret found(nothing)
            }?
        }

        if lexer.current_token_kind == TokenKind::COMMA {
            lexer.next_token()
            skip_nl()
            continue
        }

        if lexer.current_token_kind == TokenKind::NL {
            // At least one NL
            lexer.next_token()
            skip_nl()
            continue
        }

        // No delimiter, end of the loop
        break
    }

    ret found(enum_entries)
}

fun Parser.autogenerate_enum_default_methods(struct_def: NStruct, enum_entries: List<NEnumEntry>) {
    // fun Direction.to_string(): String {
    //     if (this.variant == Direction::Up.variant) {
    //         return "Up"
    //     }
    //     if (this.variant == Direction::Down.variant) {
    //         return "Down"
    //     }
    //     // ... Rest of cases
    //     unreachable()
    // }
    autogenerate_enum_method_to_string(struct_def, enum_entries)

    // fun values(): List<Direction> = #[Up, Down, Left, Right, Front, Back]
    autogenerate_enum_method_values(struct_def, enum_entries)

    // fun Direction.is_equal(other: Direction): Boolean {
    //     ret this.variant.is_equal(other.variant)
    // }
    autogenerate_enum_method_is_equal(struct_def, enum_entries)

    // fun Direction.get_ordering(other: Direction): Ordering {
    //     ret this.variant.get_ordering(other.variant)
    // }
    autogenerate_enum_method_get_ordering(struct_def, enum_entries)

    // fun from_variant(index: Int): Optional<Direction> {
    //    if (index == 1) {
    //       return Some(Up)
    //    }
    //    ...
    //    return None()
    //  }
    autogenerate_enum_method_from_variant(struct_def, enum_entries)
}

fun Parser.autogenerate_enum_method_values(struct_def: NStruct, enum_entries: List<NEnumEntry>) {
    let span = struct_def.span
    let return_type = NTypeUsage::simple_with_params(span, "List", [NTypeUsage::simple(span, struct_def.full_name)])
    let annotations = [NAnnotation @[span, name: "AutoGenerated", args: []]]
    let func = create_function(NFunctionHeader::new(span, struct_def.full_name, "values", return_type), annotations)
    register_nitro_function(func)

    let code = func.code
    let list = code.add_fun_call(span, "List", "new", false, [], [NTypeUsage::unresolved(span)])

    for entry in enum_entries {
        let variant_const = entry.constant!!
        let aux = code.add_load_const(span, variant_const.path, variant_const.name, Some(variant_const.id))
        code.add_fun_call(span, "", "add", true, [list.id, aux.id], [])
    }

    code.add_return(span, list.id)
}

fun Parser.autogenerate_enum_method_to_string(struct_def: NStruct, enum_entries: List<NEnumEntry>) {
    let span = struct_def.span
    let annotations = [NAnnotation @[span, name: "AutoGenerated", args: []]]
    let func = create_function(NFunctionHeader::new(span, struct_def.full_name, "to_string", NTypeUsage::simple(span, "String")), annotations)
    func.add_parameter(span, "this", NTypeUsage::simple(span, struct_def.full_name))
    func.register_params()
    register_nitro_function(func)

    let code = func.code

    for entry in enum_entries {
        // if (this.variant == Direction::Up.variant) {
        //    return "Up"
        // }
        let aux = code.add_load_var(span, "", "this", None())
        let variant_field = code.add_load_field(span, aux.id, VARIANT_FIELD_NAME)
        let variant_lit = code.add_lit_int(span, entry.variant)
        let equals = code.add_fun_call(span, "", "is_equal", true, [variant_lit.id, variant_field.id], [])
        code.add_if_start(span, equals.id)

        let string = code.add_lit_string(span, entry.name)
        code.add_return(span, string.id)
        code.add_if_end(span)
    }

    code.add_fun_call(span, "", "unreachable", false, [], [])
}

fun Parser.autogenerate_enum_method_is_equal(struct_def: NStruct, enum_entries: List<NEnumEntry>) {
    let span = struct_def.span
    let annotations = [NAnnotation @[span, name: "AutoGenerated", args: []]]
    let func = create_function(NFunctionHeader::new(span, struct_def.full_name, "is_equal", NTypeUsage::simple(span, "Boolean")), annotations)
    func.add_parameter(span, "this", NTypeUsage::simple(span, struct_def.full_name))
    func.add_parameter(span, "other", NTypeUsage::simple(span, struct_def.full_name))
    func.register_params()
    register_nitro_function(func)

    let code = func.code

    let this_var = code.add_load_var(span, "", "this", None())
    let this_variant = code.add_load_field(span, this_var.id, VARIANT_FIELD_NAME)

    let other_var = code.add_load_var(span, "", "other", None())
    let other_variant = code.add_load_field(span, other_var.id, VARIANT_FIELD_NAME)

    let equals = code.add_fun_call(span, "", "is_equal", true, [this_variant.id, other_variant.id], [])
    code.add_return(span, equals.id)
}

fun Parser.autogenerate_enum_method_get_ordering(struct_def: NStruct, enum_entries: List<NEnumEntry>) {
    let span = struct_def.span
    let annotations = [NAnnotation @[span, name: "AutoGenerated", args: []]]
    let func = create_function(NFunctionHeader::new(span, struct_def.full_name, "get_ordering", NTypeUsage::simple(span, "Ordering")), annotations)
    func.add_parameter(span, "this", NTypeUsage::simple(span, struct_def.full_name))
    func.add_parameter(span, "other", NTypeUsage::simple(span, struct_def.full_name))
    func.register_params()
    register_nitro_function(func)

    let code = func.code

    let this_var = code.add_load_var(span, "", "this", None())
    let this_variant = code.add_load_field(span, this_var.id, VARIANT_FIELD_NAME)

    let other_var = code.add_load_var(span, "", "other", None())
    let other_variant = code.add_load_field(span, other_var.id, VARIANT_FIELD_NAME)

    let equals = code.add_fun_call(span, "", "get_ordering", true, [this_variant.id, other_variant.id], [])
    code.add_return(span, equals.id)
}

fun Parser.autogenerate_enum_method_from_variant(struct_def: NStruct, enum_entries: List<NEnumEntry>) {
    let span = struct_def.span
    let annotations = [NAnnotation @[span, name: "AutoGenerated", args: []]]
    let return_type = NTypeUsage::simple_with_params(span, "Optional", [NTypeUsage::simple(span, struct_def.full_name)])
    let func = create_function(NFunctionHeader::new(span, struct_def.full_name, "from_variant", return_type), annotations)
    func.add_parameter(span, "variant", NTypeUsage::simple(span, "Int"))
    func.register_params()
    register_nitro_function(func)

    let code = func.code

    for entry in enum_entries {
        // if (variant == 1) { ret Some(Direction::Up) }
        let variant_var = code.add_load_var(span, "", "variant", None())
        let variant_lit = code.add_lit_int(span, entry.variant)
        let equals = code.add_fun_call(span, "", "is_equal", true, [variant_var.id, variant_lit.id], [])
        code.add_if_start(span, equals.id)

        let variant_const = entry.constant!!
        let aux = code.add_load_const(span, variant_const.path, variant_const.name, Some(variant_const.id))
        let aux2 = code.add_fun_call(span, "", "Some", false, [aux.id], [])
        code.add_return(span, aux2.id)
        code.add_if_end(span)
    }

    let none = code.add_fun_call(span, "", "None", false, [], [])
    code.add_return(span, none.id)
}

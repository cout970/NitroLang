
// E.g. enum Direction { Up, Down, Left, Right, Front, Back }
// enumDefinition
//     : ENUM modulePath? anyName NL* LBRACE NL* enumFields? NL* enumValue (commaOrNl enumValue)* COMMA? NL* RBRACE
//     | ENUM modulePath? anyName NL* LBRACE NL* enumValue (commaOrNl enumValue)* COMMA? NL* enumFields? NL* RBRACE
//     ;

// enumFields
//     : enumField (commaOrNl enumField)* COMMA? ;

// E.g. let name: String = "John"
// enumField
//     : LET anyName COLON typeUsage ;

// E.g. Up, Down, Left, Right, Front, Back
// E.g. Red $[rgb: 0xFF0000], Green $[rgb: 0x00FF00], Blue $[rgb: 0x0000FF
// enumValue
//     : anyName
//     | anyName STRUCT_START NL* (enumValueInit (commaOrNl enumValueInit)* COMMA?)? NL* RBRACKET
//     ;

// E.g. rgb: 0xFF0000
// enumValueInit
//     : anyName COLON NL* expression ;

struct NEnumEntry {
    span: Span
    name: String
    variant: Int
    value_init: List<NEnumValueInit>
}

struct NEnumValueInit {
    field_name: String
    code: NCode
}

fun Parser.read_enum_definition(annotations: List<NAnnotation>): Parsed<Nothing> {
    // Enums are desugared into a struct and a module with the same name
    // enum Direction {
    //    Up      @[name: "up"]
    //    Down    @[name: "down"]
    //    Left    @[name: "left"]
    //    Right   @[name: "right"]
    //    Front   @[name: "front"]
    //    Back    @[name: "back"]
    //
    //    let name: String
    // }
    // ---
    // struct Direction {
    //    let name: String
    // }
    // mod Direction {
    //    let Up: Direction = Direction @[name: "up"]
    //    let Down: Direction = Direction @[name: "down"]
    //    let Left: Direction = Direction @[name: "left"]
    //    let Right: Direction = Direction @[name: "right"]
    //    let Front: Direction = Direction @[name: "front"]
    //    let Back: Direction = Direction @[name: "back"]
    //
    //    // Autogenerated:
    //    fun values(): List<Direction> = #[Up, Down, Left, Right, Front, Back]
    //    fun from_variant(index: Int): Optional<Direction> {}
    //    fun Direction.to_string(): String {}
    // }
    skip_token_kind(TokenKind::ENUM)?
    let span = lexer.current_token_span
    let path = read_declaration_module_path()?
    let name = read_name()?
    skip_nl()

    skip_token_kind(TokenKind::LBRACE)?
    skip_nl()

    let def = NStruct @[
        id: id_provider.next(),
        span,
        annotations,
        path,
        name,
        generics: NGenericParams::new(),
        fields: [],
        parent: None(),
        is_enum: true,
        full_name_cache: None(),
    ]
    program.structs[] = def
    declare_name(get_full_path(def.path, def.name), def.span)

    def.fields[] = NStructField @[
        span,
        name: VARIANT_FIELD_NAME,
        offset: 0,
        parent_struct: def,
        type_usage: NTypeUsage::simple(span, "Int"),
        field_type: None(),
    ]

    let module_def = NModule @[
        span,
        annotations,
        path,
        name,
    ]
    program.modules[] = module_def
    let module_path = get_full_path(path, name)

    read_enum_fields(def)?
    let enum_entries: List<NEnumEntry> = read_enum_entries(def)?
    read_enum_fields(def)?

    skip_token_kind(TokenKind::RBRACE)?

    let all_field_names: List<String> = []

    for field in def.fields {
        if field.name in all_field_names {
            report_error("Duplicate field name: ${field.name}", span)
            continue
        }
        all_field_names[] = field.name
    }

    let enum_type_usage = NTypeUsage::simple_with_path(span, path, name)

     // Autogenerated constants
    for entry in enum_entries {

        let const_code = NCode::new(entry.span, get_full_path(module_path, entry.name))
        let const_def = NConst @[
            id: id_provider.next(),
            span: entry.span,
            path: module_path,
            name: entry.name,
            type_usage: enum_type_usage,
            const_type: None(),
            code: const_code,
            full_name_cache: None(),
        ]
        program.consts[] = const_def
        declare_name(get_full_path(const_def.path, const_def.name), const_def.span)

        let alloc = const_code.add_alloc(entry.span, enum_type_usage)
        (alloc.kind as NInstKind::Alloc).is_enum = true

        let used_field_names: List<String> = []

        // Alloc initializes the variant field for options, but enums are regular structs,
        // so we need to initialize it manually
        let variant_value = const_code.add_lit_int(entry.span, entry.variant)
        const_code.add_store_field(entry.span, alloc.id, VARIANT_FIELD_NAME, variant_value.id)
        // Variant field
        used_field_names[] = VARIANT_FIELD_NAME

        // Rest of fields
        for i in entry.value_init {
            const_code.merge(i.code)
            used_field_names[] = i.field_name

            if const_code.last_expression.is_none() {
                report_error("Expecting expression, not found", entry.span)
                continue
            }

            const_code.add_store_field(entry.span, alloc.id, i.field_name, const_code.last_expression!!)
        }

        let return_inst = const_code.add_return(entry.span, alloc.id)
        const_code.last_expression = Some(return_inst.id)

        // Missing fields to init?
        if all_field_names.len > used_field_names.len {
            let missing_fields: List<String> = []
            for field in all_field_names {
                if !used_field_names.contains(field) {
                    missing_fields[] = field
                }
            }

            let missing_fields_str = missing_fields.join(", ")
            report_error("Missing fields: $missing_fields_str", entry.span)
        }

        // TODO: Autogenerated functions
        // fun values(): List<Direction> = #[Up, Down, Left, Right, Front, Back]
        // fun Direction.to_string(): String {
        //     if (this.variant == Direction::Up.variant) {
        //         return "Up"
        //     }
        //     if (this.variant == Direction::Down.variant) {
        //         return "Down"
        //     }
        //     // ... Rest of cases
        //     unreachable()
        // }
        // fun from_variant(index: Int): Optional<Direction> {
        //    if (index == 1) {
        //       return Optional::Some(Up)
        //    }
        //    ...
        //    return Optional::None
        //  }
        // fun Direction.get_ordering(other: Direction): Ordering {
        //     ret this.variant.get_ordering(other.variant)
        // }
        // fun Direction.is_equal(other: Direction): Boolean {
        //     ret this.variant.is_equal(other.variant)
        // }
    }

    ret found(nothing)
}

fun Parser.read_enum_fields(def: NStruct): Parsed<Nothing> {
    while lexer.current_token_kind == TokenKind::LET {
        let span = lexer.current_token_span
        skip_token_kind(TokenKind::LET)?
        let field_name = read_name()?
        skip_token_kind(TokenKind::COLON)?
        let type_usage = read_type_usage()?

        def.fields[] = NStructField @[
            span,
            name: field_name,
            parent_struct: def,
            offset: def.fields.len,
            type_usage,
            field_type: None(),
        ]

        skip_nl()
    }

    ret found(nothing)
}

fun Parser.read_enum_entries(def: NStruct): Parsed<List<NEnumEntry>> {
    let enum_entries: List<NEnumEntry> = []
    let variant = 0

    loop {
        if lexer.current_token_kind == TokenKind::LET || lexer.current_token_kind == TokenKind::RBRACE {
            break
        }

        let span = lexer.current_token_span
        let entry_name = read_name()?
        let entry = NEnumEntry @[
            span,
            name: entry_name,
            variant,
            value_init: [],
        ]
        variant += 1
        enum_entries[] = entry

        if lexer.current_token_kind == TokenKind::STRUCT_START {
            skip_token_kind(TokenKind::STRUCT_START)?
            skip_nl()

            read_until_delimited(TokenKind::RBRACKET) @{
                let span = lexer.current_token_span
                let field_name = read_name()?
                skip_token_kind(TokenKind::COLON)?
                skip_nl()
                let code = NCode::new(span, "${def.full_name}::$field_name")
                read_expression(code)?

                entry.value_init[] = NEnumValueInit @[
                    field_name,
                    code,
                ]
                ret found(nothing)
            }?
        }

        if lexer.current_token_kind == TokenKind::COMMA {
            lexer.next_token()
            skip_nl()
            continue
        }

        if lexer.current_token_kind == TokenKind::NL {
            // At least one NL
            lexer.next_token()
            skip_nl()
            continue
        }

        // No delimiter, end of the loop
        break
    }

    ret found(enum_entries)
}
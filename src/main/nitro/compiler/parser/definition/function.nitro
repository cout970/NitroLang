
// E.g. fun Int.sum(other: Int): Int {}
// functionDefinition
//     : functionHeader NL* functionBody
//     | functionHeader
//     ;

// functionHeader
//     : FUN NL* functionReceiver? modulePath? anyName NL* typeParamsDef? NL*
//         LPAREN NL* (functionParameter (commaOrNl functionParameter)* COMMA?)? NL* RPAREN NL* functionReturnType?
//     | FUN NL* typeParamsDef? NL* functionReceiver? modulePath? anyName NL*
//         LPAREN NL* (functionParameter (commaOrNl functionParameter)* COMMA?)? NL* RPAREN NL* functionReturnType?;


// E.g. Int.
// functionReceiver
//     : varModifier typeUsage DOT ;

// E.g. count: Int,
// functionParameter
//     : varModifier anyName NL* COLON NL* typeUsage
//     | varModifier UNDERSCORE NL* COLON NL* typeUsage;

// E.g. {}
// E.g. = 3.14
// functionBody
//     : statementBlock
//     | ASSIGN NL* expression
//     ;

// E.g. : Int
// functionReturnType
//     : COLON typeUsage
//     | ARROW typeUsage
//     ;

fun Parser.read_function_definition(annotations: List<NAnnotation>): Parsed<Nothing> {
    let def = read_function_header(annotations)?

    skip_nl()

    def.register_params()

    // Read every statement/expression in the function body
    read_code_block(def.code)?

    ret found(nothing)
}

fun Parser.read_code_block(code: NCode): Parsed<Nothing> {
    when lexer.current_token_kind {
        TokenKind::LBRACE -> {
            read_statement_block(code)?
        }
        TokenKind::ASSIGN -> {
            let span = lexer.current_token_span
            skip_token_kind(TokenKind::ASSIGN)?
            let value = read_expression(code)?

            if code.find_inst(value).kind is NInstKind::Return {
                code.last_expression = Some(value)
            } else {
                let ret_inst = code.add_return(span, value)
                code.last_expression = Some(ret_inst.id)
            }
        }
    }

    // Sanity checks
    check(code.current_block.to_int() == 0, "Block stack is not empty")

    // Execute deferred actions
    if !code.jumped_out_of_block {
        code.execute_deferred_actions(code.current_block, true)
    }

    // Check there are no break/continue jumps unlinked
    code.check_jump_points()

    ret found(nothing)
}

fun Parser.read_function_header(annotations: List<NAnnotation>): Parsed<NFunction> {
    skip_token_kind(TokenKind::FUN)?
    skip_nl()
    let generics = NGenericParams::new()
    let parameters: List<NFunctionParameter> = []
    let has_receiver = false

    start_generics_collection(generics, NGenericSource::Function)
    defer { stop_generics_collection() }

    // Type parameters
    if lexer.current_token_kind == TokenKind::LTH {
        read_type_params_def()?
        skip_nl()
    }

    // Optional receiver
    if lexer.find_token_kind_before(TokenKind::DOT, TokenKind::LPAREN) {
        let receiver_span = lexer.current_token_span
        let receiver_tu = read_type_usage()?

        parameters[] = NFunctionParameter @[
            span: receiver_span,
            name: "this",
            type_usage: receiver_tu,
            param_type: None(),
        ]
        has_receiver = true

        skip_token_kind(TokenKind::DOT)?
    }

    // Full name
    let span = lexer.current_token_span
    let path = read_declaration_module_path()?
    let name = read_name()?

    // Register function
    let def = create_nitro_function(span, path, name, NTypeUsage::simple(span, "Nothing"))
    def.annotations = annotations
    def.has_receiver = has_receiver
    def.parameters = parameters
    def.generics = generics
    def.code.generics = generics
    register_nitro_function(def)

    // Type parameters
    skip_nl()
    if lexer.current_token_kind == TokenKind::LTH {
        read_type_params_def()?
        skip_nl()
    }

    // Function args
    skip_token_kind(TokenKind::LPAREN)?
    skip_nl()
    read_until_delimited(TokenKind::RPAREN) @{
        read_function_parameter(def)?
        ret found(nothing)
    }?

    // Return Type
    skip_nl()
    when lexer.current_token_kind {
        TokenKind::COLON -> {
            skip_token_kind(TokenKind::COLON)?
            def.return_type_usage = read_type_usage()?
        }
        TokenKind::ARROW -> {
            skip_token_kind(TokenKind::ARROW)?
            def.return_type_usage = read_type_usage()?
        }
    }

    ret found(def)
}

fun Parser.read_function_parameter(func: NFunction): Parsed<Nothing> {
    let span = lexer.current_token_span
    read_var_modifier()?

    let name = if lexer.current_token_kind == TokenKind::UNDERSCORE {
        skip_token_kind(TokenKind::UNDERSCORE)?
        "_"
    } else {
        read_name()?
    }
    skip_nl()

    skip_token_kind(TokenKind::COLON)?
    let type_usage = read_type_usage()?

    func.add_parameter(span, name, type_usage)

    ret found(nothing)
}

fun Parser.read_var_modifier(): Parsed<Nothing> {
    if lexer.current_token_kind == TokenKind::MUT {
        skip_token_kind(TokenKind::MUT)?
    }
    ret found(nothing)
}

fun NFunction.get_param_types(): List<Type> {
    let result = []
    for p in parameters {
        if p.param_type.is_none() {
            continue
        }
        result += p.param_type!!
    }
    ret result
}

fun NFunction.get_full_name(): String {
    if full_name_cache.is_some() {
        ret full_name_cache!!
    }

    let full_name = get_full_path(path, name)
    full_name_cache = Some(full_name)
    ret full_name
}

fun NFunction.is_auto_generated(): Boolean {
    ret has_annotation("AutoGenerated")
}

fun NFunction.get_annotation(name: String): Optional<NAnnotation> {
    for a in annotations {
        if a.name == name {
            ret Some(a)
        }
    }
    ret None()
}

fun NFunction.has_annotation(name: String): Boolean {
    ret get_annotation(name).is_some()
}

fun NFunction.to_string(): String {
    let prefix = if annotations.is_empty() { "" } else { annotations.join("\n") + "\n" }
    let full_name = get_full_path(path, name)

    let args = ""
    for p in parameters {
        if !args.is_empty() {
            args += ", "
        }
        args += "${p.name}: ${p.type_usage}"
    }

    return "${prefix}fun $full_name($args): $return_type_usage $code // $span"
}

struct ExternAnnotation {
    lib: String
    name: String
    autogenerate: Boolean
}

fun NFunction.get_extern_annotation(): Optional<ExternAnnotation> {
    let extern_annotation = get_annotation("Extern")
    if extern_annotation.is_none() {
        ret None()
    }

    let a: NAnnotation = extern_annotation!!
    let lib: Optional<NConstExpr> = a.get_arg("lib")
    let name: Optional<NConstExpr> = a.get_arg("name")

    if lib.is_none() || name.is_none() {
        ret None()
    }

    let lib_str: Optional<String> = lib!!.get_string()
    let name_str: Optional<String> = name!!.get_string()

    if lib_str.is_none() || name_str.is_none() {
        ret None()
    }

    let autogenerate: Boolean = false
    let autogenerate_arg: Optional<NConstExpr> = a.get_arg("autogenerate")

    if autogenerate_arg.is_some() && autogenerate_arg!!.get_boolean().is_some() {
        autogenerate = autogenerate_arg!!.get_boolean()!!
    }

    ret Some(ExternAnnotation @[
        lib: lib_str!!,
        name: name_str!!,
        autogenerate,
    ])
}

// E.g. fun Int.sum(other: Int): Int {}
// functionDefinition
//     : functionHeader NL* functionBody
//     | functionHeader
//     ;

// functionHeader
//     : FUN NL* functionReceiver? modulePath? anyName NL* typeParamsDef? NL*
//         LPAREN NL* (functionParameter (commaOrNl functionParameter)* COMMA?)? NL* RPAREN NL* functionReturnType?
//     | FUN NL* typeParamsDef? NL* functionReceiver? modulePath? anyName NL*
//         LPAREN NL* (functionParameter (commaOrNl functionParameter)* COMMA?)? NL* RPAREN NL* functionReturnType?;


// E.g. Int.
// functionReceiver
//     : varModifier typeUsage DOT ;

// E.g. count: Int,
// functionParameter
//     : varModifier anyName NL* COLON NL* typeUsage
//     | varModifier UNDERSCORE NL* COLON NL* typeUsage;

// E.g. {}
// E.g. = 3.14
// functionBody
//     : statementBlock
//     | ASSIGN NL* expression
//     ;

// E.g. : Int
// functionReturnType
//     : COLON typeUsage
//     | ARROW typeUsage
//     ;

struct NFunction {
    id: Id
    span: Span
    annotations: List<NAnnotation>
    generics: NGenericParams
    has_receiver: Boolean
    path: String
    name: String
    parameters: List<NFunctionParameter>
    return_type_usage: NTypeUsage
    return_type: Optional<Type>
    parent_tag: Optional<NTag>
    code: NCode
    full_name_cache: Optional<String>
}

struct NFunctionParameter {
    span: Span
    name: String
    type_usage: NTypeUsage
    param_type: Optional<Type>
}

fun Parser.read_function_definition(annotations: List<NAnnotation>): Parsed<Nothing> {
    let def = read_function_header(annotations)?

    skip_nl()

    // Create a local variable per function parameter
    for param in def.parameters {
        let variable = def.code.add_let(param.span, param.name, Some(param.type_usage))
        variable.is_parameter = true
    }

    // Read every statement/expression in the function body
    read_code_block(def.code)?

    ret found(nothing)
}

fun Parser.read_code_block(code: NCode): Parsed<Nothing> {
    when lexer.current_token_kind {
        TokenKind::LBRACE -> {
            read_statement_block(code)?
        }
        TokenKind::ASSIGN -> {
            skip_token_kind(TokenKind::ASSIGN)?
            code.last_expression = Some(read_expression(code)?)
        }
    }

    // Sanity checks
    check(code.current_block.to_int() == 0, "Block stack is not empty")

    // Execute deferred actions
    if !code.jumped_out_of_block {
        code.execute_deferred_actions(code.current_block, true)
    }

    // Check there are no break/continue jumps unlinked
    code.check_jump_points()

    ret found(nothing)
}

fun Parser.read_function_header(annotations: List<NAnnotation>): Parsed<NFunction> {
    skip_token_kind(TokenKind::FUN)?
    skip_nl()
    let generics = NGenericParams::new()
    let parameters: List<NFunctionParameter> = []
    let has_receiver = false

    start_generics_collection(generics, NGenericSource::Function)
    defer { stop_generics_collection() }

    // Type parameters
    if lexer.current_token_kind == TokenKind::LTH {
        read_type_params_def()?
        skip_nl()
    }

    // Optional receiver
    if lexer.find_token_kind_before(TokenKind::DOT, TokenKind::LPAREN) {
        let receiver_span = lexer.current_token_span
        let receiver_tu = read_type_usage()?

        parameters[] = NFunctionParameter @[
            span: receiver_span,
            name: "this",
            type_usage: receiver_tu,
            param_type: None(),
        ]
        has_receiver = true

        skip_token_kind(TokenKind::DOT)?
    }

    // Full name
    let span = lexer.current_token_span
    let path = read_declaration_module_path()?
    let name = read_name()?

    // Register function
    let def = NFunction @[
        id: id_provider.next(),
        span,
        annotations,
        generics,
        has_receiver,
        path,
        name,
        parameters,
        return_type_usage: NTypeUsage::simple(span, "Nothing"),
        return_type: None(),
        parent_tag: None(),
        code: NCode::new(span, get_full_path(path, name)),
        full_name_cache: None(),
    ]
    program.functions[] = def

    // Pass generics to the code block to resolve inner references
    def.code.generics = def.generics

    // Type parameters
    skip_nl()
    if lexer.current_token_kind == TokenKind::LTH {
        read_type_params_def()?
        skip_nl()
    }

    // Function args
    skip_token_kind(TokenKind::LPAREN)?
    skip_nl()
    read_until_delimited(TokenKind::RPAREN) @{
        def.parameters += read_function_parameter()?
        ret found(nothing)
    }?

    // Return Type
    skip_nl()
    when lexer.current_token_kind {
        TokenKind::COLON -> {
            skip_token_kind(TokenKind::COLON)?
            def.return_type_usage = read_type_usage()?
        }
        TokenKind::ARROW -> {
            skip_token_kind(TokenKind::ARROW)?
            def.return_type_usage = read_type_usage()?
        }
    }

    ret found(def)
}

fun Parser.read_function_parameter(): Parsed<NFunctionParameter> {
    let span = lexer.current_token_span
    read_var_modifier()?

    let name = if lexer.current_token_kind == TokenKind::UNDERSCORE {
        skip_token_kind(TokenKind::UNDERSCORE)?
        "_"
    } else {
        read_name()?
    }
    skip_nl()

    skip_token_kind(TokenKind::COLON)?
    let type_usage = read_type_usage()?

    let def = NFunctionParameter @[
        span,
        name,
        type_usage,
        param_type: None(),
    ]

    ret found(def)
}

fun Parser.read_var_modifier(): Parsed<Nothing> {
    if lexer.current_token_kind == TokenKind::MUT {
        skip_token_kind(TokenKind::MUT)?
    }
    ret found(nothing)
}

fun NFunction.get_param_types(): List<Type> {
    let result = []
    for p in parameters {
        if p.param_type.is_none() {
            continue
        }
        result += p.param_type!!
    }
    ret result
}

fun NFunction.get_full_name(): String {
    if full_name_cache.is_some() {
        ret full_name_cache!!
    }

    let full_name = get_full_path(path, name)
    full_name_cache = Some(full_name)
    ret full_name
}

fun NFunction.is_auto_generated(): Boolean {
    ret has_annotation("AutoGenerated")
}

fun NFunction.get_annotation(name: String): Optional<NAnnotation> {
    for a in annotations {
        if a.name == name {
            ret Some(a)
        }
    }
    ret None()
}

fun NFunction.has_annotation(name: String): Boolean {
    ret get_annotation(name).is_some()
}

fun NFunction.to_string(): String {
    let prefix = if annotations.is_empty() { "" } else { annotations.join("\n") + "\n" }
    let full_name = get_full_path(path, name)

    let args = ""
    for p in parameters {
        if !args.is_empty() {
            args += ", "
        }
        args += "${p.name}: ${p.type_usage}"
    }

    return "${prefix}fun $full_name($args): $return_type_usage $code // $span"
}



struct Parser {
    lexer: Lexer
    reporter: Reporter
    program: Program
    id_provider: IdProvider
    allow_defer: Boolean
    module_path_stack: List<String>
    current_generics: NGenericParams
    allow_expression_assignment: Boolean
    allow_generics_collection: Boolean
}

fun Parser::new(lexer: Lexer, reporter: Reporter, program: Program): Parser {
    ret Parser @[
        lexer,
        reporter,
        program,
        id_provider: IdProvider::new(),
        allow_defer: true,
        module_path_stack: [],
        current_generics: NGenericParams::new(),
        allow_expression_assignment: false,
        allow_generics_collection: false,
    ]
}

// Parse a program
fun Parser.read_file() {
    // parseFile : NL* definition* EOF;
    skip_nl()

    while has_remaining_tokens() {
        let res: Parsed<Nothing> = read_definition()
        skip_nl()

        if res is Parsed::Error<Nothing> {
            let span = lexer.span_of(lexer.current_token)
            let error = res as Parsed::Error<Nothing>

            // DEBUG
            println("Reporting error: ${res.to_string()}")
            lexer.print_debug_info()

            reporter.report_parse_error(res.to_string(), span, error.stack_trace)
            recover_from_error()
            break
        }
    }
}

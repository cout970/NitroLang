// TODO Rewrite

struct Lexer {
    tokens: List<Int>
    token_count: Int
    source: String
    cursor: Int
}

fun Lexer::new(source: String): Lexer {
    ret Lexer @[
        source: source,
        token_count: 0,
        tokens: List::new<Int>(),
        cursor: 0,
    ]
}

fun Lexer.add_token(ty: Int, offset: Int, extra: Int) {
    this.tokens[] = ty
    this.tokens[] = offset
    this.tokens[] = extra
    this.token_count = this.token_count + 1
}

fun Lexer.add_single_token(ty: Int) {
    this.add_token(ty, this.cursor, 0)
    this.cursor = this.cursor + 1
}

fun Lexer.get_token_type(index: Int): Int {
    ret this.tokens[index / 3]!!
}

fun Lexer.get_token_offset(index: Int): Int {
    ret this.tokens[index / 3 + 1]!!
}

fun Lexer.get_token_extra(index: Int): Int {
    ret this.tokens[index / 3 + 2]!!
}

fun Lexer.add_string() {
    this.add_token(TOKEN_TYPE_PLAIN_STRING, this.cursor, 0)
}

fun Lexer.add_identifier() {
    this.add_token(TOKEN_TYPE_IDENTIFIER, this.cursor, 0)
}

fun Lexer.add_number() {
    this.add_token(TOKEN_TYPE_INT_NUMBER, this.cursor, 0)
}

fun Lexer.process() {
    this.cursor = 0
    loop {
        if this.cursor >= this.source.byte_len() {
            ret nothing
        }

        let byte: Int = this.source.get_byte(this.cursor).to_int()

        while byte == 32 {
            this.cursor = this.cursor + 1

            if this.cursor >= this.source.byte_len() {
                ret nothing
            }

            byte = this.source.get_byte(this.cursor).to_int()
        }

        when(byte) {
            /* ! */ 33 -> this.add_single_token(TOKEN_TYPE_NOT)
            /* " */ 34 -> this.add_string()
            /* # */ 35 -> this.add_single_token(TOKEN_TYPE_RPAREN)
            /* $ */ 36 -> this.add_single_token(TOKEN_TYPE_RPAREN)
            /* % */ 37 -> this.add_single_token(TOKEN_TYPE_RPAREN)
            /* & */ 38 -> this.add_single_token(TOKEN_TYPE_RPAREN)
            /* ' */ 39 -> this.add_single_token(TOKEN_TYPE_RPAREN)
            /* ( */ 40 -> this.add_single_token(TOKEN_TYPE_RPAREN)
            /* ) */ 41 -> this.add_single_token(TOKEN_TYPE_RPAREN)
            /* * */ 42 -> this.add_single_token(TOKEN_TYPE_RPAREN)
            /* + */ 43 -> this.add_single_token(TOKEN_TYPE_RPAREN)
            /* , */ 44 -> this.add_single_token(TOKEN_TYPE_RPAREN)
            /* - */ 45 -> this.add_single_token(TOKEN_TYPE_RPAREN)
            /* . */ 46 -> this.add_single_token(TOKEN_TYPE_RPAREN)
            /* / */ 47 -> this.add_single_token(TOKEN_TYPE_RPAREN)
            /* 0 */ 48 -> this.add_number()
            /* 1 */ 49 -> this.add_number()
            /* 2 */ 50 -> this.add_number()
            /* 3 */ 51 -> this.add_number()
            /* 4 */ 52 -> this.add_number()
            /* 5 */ 53 -> this.add_number()
            /* 6 */ 54 -> this.add_number()
            /* 7 */ 55 -> this.add_number()
            /* 8 */ 56 -> this.add_number()
            /* 9 */ 57 -> this.add_number()
            /* : */ 58 -> this.add_single_token(TOKEN_TYPE_RPAREN)
            /* ; */ 59 -> this.add_single_token(TOKEN_TYPE_RPAREN)
            /* < */ 60 -> this.add_single_token(TOKEN_TYPE_RPAREN)
            /* = */ 61 -> this.add_single_token(TOKEN_TYPE_RPAREN)
            /* > */ 62 -> this.add_single_token(TOKEN_TYPE_RPAREN)
            /* ? */ 63 -> this.add_single_token(TOKEN_TYPE_RPAREN)
            /* @ */ 64 -> this.add_single_token(TOKEN_TYPE_RPAREN)
            /* A */ 65 -> this.add_identifier()
            /* B */ 66 -> this.add_identifier()
            /* C */ 67 -> this.add_identifier()
            /* D */ 68 -> this.add_identifier()
            /* E */ 69 -> this.add_identifier()
            /* F */ 70 -> this.add_identifier()
            /* G */ 71 -> this.add_identifier()
            /* H */ 72 -> this.add_identifier()
            /* I */ 73 -> this.add_identifier()
            /* J */ 74 -> this.add_identifier()
            /* K */ 75 -> this.add_identifier()
            /* L */ 76 -> this.add_identifier()
            /* M */ 77 -> this.add_identifier()
            /* N */ 78 -> this.add_identifier()
            /* O */ 79 -> this.add_identifier()
            /* P */ 80 -> this.add_identifier()
            /* Q */ 81 -> this.add_identifier()
            /* R */ 82 -> this.add_identifier()
            /* S */ 83 -> this.add_identifier()
            /* T */ 84 -> this.add_identifier()
            /* U */ 85 -> this.add_identifier()
            /* V */ 86 -> this.add_identifier()
            /* W */ 87 -> this.add_identifier()
            /* X */ 88 -> this.add_identifier()
            /* Y */ 89 -> this.add_identifier()
            /* Z */ 90 -> this.add_identifier()
            /* [ */ 91 -> this.add_single_token(TOKEN_TYPE_RPAREN)
            /* \ */ 92 -> this.add_single_token(TOKEN_TYPE_RPAREN)
            /* ] */ 93 -> this.add_single_token(TOKEN_TYPE_RPAREN)
            /* ^ */ 94 -> this.add_single_token(TOKEN_TYPE_RPAREN)
            /* _ */ 95 -> this.add_single_token(TOKEN_TYPE_RPAREN)
            /* ` */ 96 -> this.add_single_token(TOKEN_TYPE_RPAREN)
            /* a */ 97 -> this.add_identifier()
            /* b */ 98 -> this.add_identifier()
            /* c */ 99 -> this.add_identifier()
            /* d */ 100 -> this.add_identifier()
            /* e */ 101 -> this.add_identifier()
            /* f */ 102 -> this.add_identifier()
            /* g */ 103 -> this.add_identifier()
            /* h */ 104 -> this.add_identifier()
            /* i */ 105 -> this.add_identifier()
            /* j */ 106 -> this.add_identifier()
            /* k */ 107 -> this.add_identifier()
            /* l */ 108 -> this.add_identifier()
            /* m */ 109 -> this.add_identifier()
            /* n */ 110 -> this.add_identifier()
            /* o */ 111 -> this.add_identifier()
            /* p */ 112 -> this.add_identifier()
            /* q */ 113 -> this.add_identifier()
            /* r */ 114 -> this.add_identifier()
            /* s */ 115 -> this.add_identifier()
            /* t */ 116 -> this.add_identifier()
            /* u */ 117 -> this.add_identifier()
            /* v */ 118 -> this.add_identifier()
            /* w */ 119 -> this.add_identifier()
            /* x */ 120 -> this.add_identifier()
            /* y */ 121 -> this.add_identifier()
            /* z */ 122 -> this.add_identifier()
            /* { */ 123 -> this.add_single_token(TOKEN_TYPE_RPAREN)
            /* | */ 124 -> this.add_single_token(TOKEN_TYPE_RPAREN)
            /* } */ 125 -> this.add_single_token(TOKEN_TYPE_RPAREN)
            /* ~ */ 126 -> this.add_single_token(TOKEN_TYPE_RPAREN)
            else -> this.add_single_token(TOKEN_TYPE_ERROR_CHARACTER)
        }
    }
}

fun Lexer.debug_print() {
    Log::info("Lexer @[token_count: ${this.token_count}, cursor: ${this.cursor}]")
    repeat this.token_count {
        Log::info(" - ${this.get_token_offset(it)}: ${this.get_token_type(it)}")
    }
}

let MODE_NORMAL: Int  = 0
let MODE_STRING: Int  = 1
let MODE_BLOCK: Int   = 2

enum Token {
    RANGE_IN,
    RANGE_EX,
    LAMBDA_START,
    SET_START,
    MAP_START,
    LIST_START,
    STRUCT_START,
    STRING_INTERP,
    DOUBLE_COLON,
    ARROW,
    OROR,
    ANDAND,
    XORXOR,
    COMPARE,
    EQ,
    NEQ,
    LEQ,
    GEQ,
    DOT,
    LPAREN,
    RPAREN,
    LBRACE,
    LBRACKET,
    RBRACKET,
    COMMA,
    COLON,
    ADD,
    SUB,
    MUL,
    DIV,
    XOR,
    DOLAR,
    MOD,
    AT,
    HASH,
    OR,
    AND,
    NOT,
    ASSIGN,
    LTH,
    GTH,
    THIS,
    THIS_TYPE,
    FUN,
    LET,
    MODULE,
    STRUCT,
    RETURN,
    SIZE_OF,
    PTR_OF,
    MEMORY_WRITE,
    MEMORY_READ,
    OPTION,
    REC,
    TAG,
    NOTHING,
    WHEN,
    MATCH,
    EITHER,
    ALIAS,
    IF,
    ELSE,
    FOR,
    IN,
    NOT_IN,
    WHILE,
    REPEAT,
    LOOP,
    IS,
    NOT_IS,
    AS,
    TRUE,
    FALSE,
    NULL,
    INCLUDE,
    BREAK,
    CONTINUE,
    JSON,
    USE,
    MUT,
    REF,
    REF_MUT,
    COPY,
    BLOCK_START,
    WHITE_SPACE,
    NL,
    LINE_COMMENT,
    DOC_COMMENT,
    BLOCK_COMMENT,
    INT_NUMBER,
    FLOAT_NUMBER,
    IDENTIFIER,
    PLAIN_STRING,
    RBRACE,
    STRING_ESCAPE,
    STRING_INTERP_START,
    STRING_INTERP_END,
    STRING_VAR,
    STRING_BLOB,
    STRING_END,
    BLOCK_END,
    BLOCK_BLOB,
    BLOCK_OTHER,
    ERROR_CHARACTER,
}

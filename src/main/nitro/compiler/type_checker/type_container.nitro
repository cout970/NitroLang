
struct TypeContainer {
    all_types: Map<TypeId, Type>
    type_tokens: Map<TypeToken, TypeId>
    last_type_id: TypeId
    last_type_token: TypeToken
    last_unresolved_id: Int
}

fun TypeContainer::new(): TypeContainer {
    let instance = TypeContainer @[
        all_types: #[],
        type_tokens: #[],
        last_type_id: 0,
        last_type_token: 0,
        last_unresolved_id: 0,
    ]

    ret instance
}

fun TypeContainer.wrap(arg: Optional<TypeToken>): Optional<TypeWrapper> {
    if arg.is_none() {
        ret None()
    }

    ret Some(TypeWrapper @[
        type_token: arg!!,
        container: this,
    ])
}

fun TypeContainer.create_type(kind: TypeKind, params: List<TypeToken>): TypeToken {
    // Create type
    last_type_id += 1
    let ty = Type @[
        id: last_type_id,
        kind,
        params,
    ]
    all_types[last_type_id] = ty

    // Create type token
    last_type_token += 1
    type_tokens[last_type_token] = last_type_id
    ret last_type_token
}

fun TypeContainer.create_union(left: TypeToken, right: TypeToken): TypeToken {
    if left == right {
        ret left
    }
    let left_ty = get_type(left)
    let right_ty = get_type(right)

    if left_ty.kind is TypeKind::Union && right_ty.kind is TypeKind::Union {
        let set: Set<TypeToken> = %[]

        set.add_all(left_ty.params)
        set.add_all(right_ty.params)

        ret create_type(left_ty.kind, set.to_list())
    }

    if left_ty.kind is TypeKind::Union {
        let set: Set<TypeToken> = %[]

        set.add_all(left_ty.params)
        set.add(right)

        ret create_type(left_ty.kind, set.to_list())
    }

    if right_ty.kind is TypeKind::Union {
        let set: Set<TypeToken> = %[]

        set.add_all(right_ty.params)
        set.add(left)

        ret create_type(right_ty.kind, set.to_list())
    }

    ret create_type(TypeKind::Union @[span: left_ty.kind.span], [left, right])
}

fun TypeContainer.get_type(token: TypeToken): Type {
    let id = type_tokens[token]!!
    ret get_type_by_id(id)
}

fun TypeContainer.get_type_by_id(id: TypeId): Type {
    ret all_types[id]!!
}

fun TypeContainer.replace(original: TypeToken, new_value: TypeToken) {
    // TODO detect if all aliases are gone before removing the type
    // all_types.remove(type_tokens[original]!!)
    type_tokens[original] = type_tokens[new_value]!!
}

fun TypeContainer.are_equal(a: TypeToken, b: TypeToken): Boolean {
    ret type_tokens[a]!! == type_tokens[b]!!
}

fun TypeContainer.contains_param(curr: TypeToken, find: TypeToken): Boolean {
    let ty = get_type(curr)

    for param in ty.params {
        if param == find {
            ret true
        }

        if contains_param(param, find) {
            ret true
        }
    }

    ret false
}

// Remove [find] from the list of params of Unions, returning [curr] is no changes were made
fun TypeContainer.remove_unresolved(curr: TypeToken, find: TypeToken): TypeToken {
    let ty = get_type(curr)
    let changed = false
    let new_params = []

    // Union: remove [find] from the list of params
    if ty.kind is TypeKind::Union {
        for param in ty.params {
            if param == find {
                changed = true
                continue
            }
            new_params[] = remove_unresolved(param, find)
        }

        if changed {
            ret create_type(ty.kind, new_params)
        }

        ret curr
    }

    // Any other type, update params calling remove_unresolved() recursively
    for param in ty.params {
        let new_param = remove_unresolved(param, find)
        new_params[] = remove_unresolved(param, find)

        if param != new_param {
            changed = true
        }
    }

    if changed {
        ret get_or_create_type(ty.kind, new_params)
    }

    ret curr
}

fun TypeContainer.is_unresolved(tt: TypeToken): Boolean {
    ret get_type(tt).kind is TypeKind::Unresolved
}

fun TypeContainer.is_unresolved_function(tt: TypeToken): Boolean {
    ret get_type(tt).kind is TypeKind::UnresolvedFunction
}

fun TypeContainer.has_unresolved(tt: TypeToken): Boolean {
    let ty = get_type(tt)

    if ty.kind is TypeKind::Unresolved || ty.kind is TypeKind::UnresolvedFunction {
        ret true
    }

    for p in ty.params {
        if has_unresolved(p) {
            ret true
        }
    }
    ret false
}

fun TypeContainer.is_generic(tt: TypeToken): Boolean {
    ret get_type(tt).kind is TypeKind::Generic
}

fun TypeContainer.is_union(tt: TypeToken): Boolean {
    ret get_type(tt).kind is TypeKind::Union
}

fun TypeContainer.is_invalid(tt: TypeToken): Boolean {
    ret get_type(tt).kind is TypeKind::Invalid
}

fun TypeContainer.is_composite(tt: TypeToken): Boolean {
    let kind = get_type(tt).kind
    ret kind is TypeKind::Struct || kind is TypeKind::Option || kind is TypeKind::OptionItem
}

fun TypeContainer.is_named(tt: TypeToken, name: String): Boolean {
    let ty = get_type(tt)

    if ty.kind is TypeKind::Struct {
        ret (ty.kind as TypeKind::Struct).instance.full_name == name
    }

    if ty.kind is TypeKind::Option {
        ret (ty.kind as TypeKind::Option).instance.full_name == name
    }

    if ty.kind is TypeKind::OptionItem {
        ret (ty.kind as TypeKind::OptionItem).instance.full_name == name
    }

    ret false
}

fun TypeContainer.is_boolean(tt: TypeToken): Boolean = this.is_named(tt, "Boolean")
fun TypeContainer.is_byte(tt: TypeToken): Boolean = this.is_named(tt, "Byte")
fun TypeContainer.is_char(tt: TypeToken): Boolean = this.is_named(tt, "Char")
fun TypeContainer.is_float(tt: TypeToken): Boolean = this.is_named(tt, "Float")
fun TypeContainer.is_function(tt: TypeToken): Boolean = this.is_named(tt, "Function")
fun TypeContainer.is_int(tt: TypeToken): Boolean = this.is_named(tt, "Int")
fun TypeContainer.is_long(tt: TypeToken): Boolean = this.is_named(tt, "Long")
fun TypeContainer.is_never(tt: TypeToken): Boolean = this.is_named(tt, "Never")
fun TypeContainer.is_nothing(tt: TypeToken): Boolean = this.is_named(tt, "Nothing")
fun TypeContainer.is_string(tt: TypeToken): Boolean = this.is_named(tt, "String")

fun TypeContainer.find_type(kind: TypeKind, params: List<TypeToken>): Optional<TypeToken> {
    for tt_entry in type_tokens {
        let tt = tt_entry.first
        let ty = all_types[tt_entry.second]!!

        if ty.params == params && ty.kind == kind {
            ret Some(tt)
        }
    }
    ret None()
}

fun TypeContainer.get_or_create_type(kind: TypeKind, params: List<TypeToken>): TypeToken {
    let opt = find_type(kind, params)
    ret if opt.is_some() { opt!! } else { create_type(kind, params) }
}

fun TypeContainer.common_type(left: TypeToken, right: TypeToken): Optional<TypeToken> {
    if are_equal(left, right) {
        ret Some(left)
    }

    // Invalid
    if is_invalid(left) {
        ret Some(right)
    }
    if is_invalid(right) {
        ret Some(left)
    }

    // Never
    if is_never(left) {
        ret Some(right)
    }
    if is_never(right) {
        ret Some(left)
    }

    // Union
    if is_union(left) && is_union(right) {
        let left_ty = get_type(left)
        let right_ty = get_type(right)
        let set = %[]

        set.add_all(left_ty.params)
        set.add_all(right_ty.params)

        ret common_type_of_list(set.to_list())
    }
    if is_union(left) {
        let left_ty = get_type(left)
        let set = %[]

        set.add_all(left_ty.params)
        set.add(right)

        ret common_type_of_list(set.to_list())
    }
    if is_union(right) {
        let right_ty = get_type(right)
        let set = %[]

        set.add_all(right_ty.params)
        set.add(left)

        ret common_type_of_list(set.to_list())
    }

    // Composite
    if is_composite(left) && is_composite(right) {
        let left_ty = get_type(left)
        let right_ty = get_type(right)

        if left_ty.params.len != right_ty.params.len {
            ret None()
        }

        let opt = common_kind_type(left_ty.kind, right_ty.kind)

        if opt.is_none() {
            ret None()
        }

        let params = []

        repeat left_ty.params.len {
            let aux = common_type(left_ty.params[it]!!, right_ty.params[it]!!)

            if aux.is_none() {
                ret None()
            }
            params[] = aux!!
        }

        ret Some(get_or_create_type(opt!!, params))
    }

    ret None()
}

fun TypeContainer.common_type_of_list(list: List<TypeToken>): Optional<TypeToken> {
    ret when list.len {
        0 -> None()
        1 -> list.first()
        2 -> common_type(list[0]!!, list[1]!!)
        else -> {
            let curr: TypeToken = list.first()!!

            for other in list.rest() {
                let aux = common_type(curr, other)

                if aux.is_none() {
                    ret None()
                }
                curr = aux!!
            }

            ret Some(curr)
        }
    }
}

fun TypeContainer.common_kind_type(left: TypeKind, right: TypeKind): Optional<TypeKind> {
    if left == right {
        ret Some(left)
    }

    if left is TypeKind::Struct && (left as TypeKind::Struct).instance.full_name == "Never" {
        ret Some(right)
    }
    if right is TypeKind::Struct && (right as TypeKind::Struct).instance.full_name == "Never" {
        ret Some(left)
    }

    // Ordering and Ordering::Equals => Ordering
    if left is TypeKind::Option && right is TypeKind::OptionItem {
        let left_option: NOption = (left as TypeKind::Option).instance
        let right_struct = (right as TypeKind::OptionItem).instance

        for item in left_option.items {
            if item.def == right_struct {
                ret Some(left)
            }
        }

        ret None()
    }

    // Ordering::Equals and Ordering => Ordering
    if left is TypeKind::OptionItem && right is TypeKind::Option {
        let left_struct = (left as TypeKind::OptionItem).instance
        let right_option: NOption = (right as TypeKind::Option).instance

        for item in right_option.items {
            if item.def == left_struct {
                ret Some(right)
            }
        }

        ret None()
    }

    // Ordering::Less and Ordering::Equals => Ordering
    if left is TypeKind::OptionItem && right is TypeKind::OptionItem {
        let left_struct = (left as TypeKind::OptionItem).instance
        let right_struct = (right as TypeKind::OptionItem).instance

        if left_struct == right_struct {
            ret Some(left)
        }

        ret None()
    }

    // Function and Lambda => Function
    if left is TypeKind::Struct && (left as TypeKind::Struct).instance.full_name == "Function" && right is TypeKind::Lambda {
        ret Some(left)
    }
    if right is TypeKind::Struct && (right as TypeKind::Struct).instance.full_name == "Function" && left is TypeKind::Lambda {
        ret Some(right)
    }

    ret None()
}

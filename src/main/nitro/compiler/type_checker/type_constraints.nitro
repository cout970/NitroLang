
struct TypeConstraints {
    all: List<TypeConstraint>
    actions: List<DeferredActions>
    codes: List<NCode>
    last_constraint_id: Int
}

option TypeConstraint {
    Unify { id: Int, left: TypeToken, right: TypeToken, span: Span }
    Bounds { id: Int, arg: TypeToken, required_tags: List<NTag>, span: Span }
}

struct DeferredActions {
    arg: TypeToken
    action: (TypeToken) -> Nothing
}

fun TypeConstraints::new(): TypeConstraints {
    ret TypeConstraints @[
        all: [],
        actions: [],
        codes: [],
        last_constraint_id: 0,
    ]
}

// Assert that 2 types are related by equality
fun TypeConstraints.add_unify(left: TypeToken, right: TypeToken, span: Span) {
    last_constraint_id += 1
    all[] = TypeConstraint::Unify @[ id: last_constraint_id, left, right, span ]
}

fun TypeConstraints.add_unify(left: Type, right: Type, span: Span) {
    last_constraint_id += 1
    all[] = TypeConstraint::Unify @[
        id: last_constraint_id,
        left: left.to_token(),
        right: right.to_token(),
        span
    ]
}

// Same as add_unify but with lists
fun TypeConstraints.add_unify_list(left: List<Type>, right: List<Type>, span: Span) {
    repeat min(left.len, right.len) {
        add_unify(left[it]!!.to_token(), right[it]!!.to_token(), span)
    }
}

// Assert that a type has the required tags
fun TypeConstraints.add_bounds(arg: TypeToken, required_tags: List<NTag>, span: Span) {
    last_constraint_id += 1
    all[] = TypeConstraint::Bounds @[ id: last_constraint_id, arg, required_tags, span ]
}

// Run an action once all argument types are resolved
fun TypeConstraints.once_resolved(arg: TypeToken, action: (TypeToken) -> Nothing) {
    actions[] = DeferredActions @[ arg, action ]
}

fun TypeConstraints.add_code_to_check(code: NCode) {
    codes[] = code
}

fun TypeConstraints.resolve(type_checker: TypeChecker, code: NCode, current_inst: NInstId, span: Span) {
    let changes = false
    loop {
        let ctx = UnifyCtx @[
            reporter: type_checker.reporter,
            types: type_checker.types,
            current_inst,
            span,
            code,
            cons: this,
            unresolved_types: #[],
        ]

        // Find types for unresolved
        for constraint in all {
            if constraint is TypeConstraint::Unify {
                let c = constraint as TypeConstraint::Unify

                ctx.unify(c.left.find_type(), c.right.find_type())
            }
        }

        // Apply substitutions
        for pair in ctx.unresolved_types {
            ctx.types.replace_all(pair.first, pair.second.find_type())
            changes = true
        }

        // Remove resolved constraints
        changes = type_checker.remove_obsolete_constraints() || changes

        // Execute deferred actions, to add new constraints and advance the type checking
        changes = type_checker.execute_deferred_actions() || changes

        // Stop when no progress is made
        if !changes {
            break
        }

        changes = false
    }
}

fun TypeChecker.remove_obsolete_constraints(): Boolean {
    let changes = false
    let index = 0

    while index < cons.all.len {
        let constraint = cons.all[index]!!

        if constraint is TypeConstraint::Unify {
            let c = constraint as TypeConstraint::Unify

            if c.left == c.right {
                cons.all.remove_at(index)
                changes = true
                continue
            }
            if !c.left.find_type().has_unresolved() && !c.right.find_type().has_unresolved() {
                cons.all.remove_at(index)
                changes = true
                continue
            }
        }

        index += 1
    }

    ret changes
}

fun TypeChecker.execute_deferred_actions(): Boolean {
    let changes = false
    let index = 0

    while index < cons.actions.len {
        let deferred = cons.actions[index]!!
        let ty = deferred.arg.find_type()

        if !ty.is_unresolved() && !ty.is_unresolved_function() {
            deferred.action.call(deferred.arg)
            cons.actions.remove_at(index)
            changes = true
            continue
        }

        index += 1
    }

    ret changes
}

fun TypeConstraint.to_string(): String {
    if this is TypeConstraint::Unify {
        let c = this as TypeConstraint::Unify
        ret "Unify ${c.id}: ${c.left} == ${c.right}"
    }
    if this is TypeConstraint::Bounds {
        let c = this as TypeConstraint::Bounds
        ret "Bounds ${c.id}: ${c.arg}, ${c.required_tags}"
    }

    unreachable()
}
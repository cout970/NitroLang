
struct TypeConstraints {
    all: List<TypeConstraint>
    actions: List<DeferredActions>
}

option TypeConstraint {
    Unify { left: TypeToken, right: TypeToken, span: Span }
}

struct DeferredActions {
    arg: TypeToken
    action: (TypeToken) -> Nothing
}

fun TypeConstraints::new(): TypeConstraints {
    ret TypeConstraints @[
        all: [],
        actions: [],
    ]
}

// Assert that 2 types are related by equality
fun TypeConstraints.unify(left: TypeToken, right: TypeToken, span: Span) {
    all[] = TypeConstraint::Unify @[ left, right, span ]
}

// Run an action once all argument types are resolved
fun TypeConstraints.once_resolved(arg: TypeToken, action: (TypeToken) -> Nothing) {
    actions[] = DeferredActions @[ arg, action ]
}


fun TypeConstraints.resolve(type_checker: TypeChecker, code: NCode, span: Span) {
    if all.is_empty() {
        ret
    }

    let changes = false
    loop {
        let ctx = UnifyCtx @[
            span,
            code,
            reporter: type_checker.reporter,
            cons: this,
            types: type_checker.types,
            unresolved_types: #[],
        ]

        // Find types for unresolved
        for constraint in all {
            if constraint is TypeConstraint::Unify {
                let c = constraint as TypeConstraint::Unify

                ctx.unify(c.left, c.right)
            }
        }

        // Apply substitutions
        for pair in ctx.unresolved_types {
            ctx.types.replace(pair.first, pair.second)
            changes = true
        }

        // Remove resolved constraints
        changes = type_checker.remove_obsolete_constraints() || changes

        // Execute deferred actions, to add new constraints and advance the type checking
        changes = type_checker.execute_deferred_actions() || changes

        // Stop when no progress is made
        if !changes {
            break
        }

        changes = false
    }
}

fun TypeChecker.remove_obsolete_constraints(): Boolean {
    let changes = false
    let index = 0

    while index < cons.all.len {
        let constraint = cons.all[index]!!

        if constraint is TypeConstraint::Unify {
            let c = constraint as TypeConstraint::Unify

            if types.are_equal(c.left, c.right) {
                cons.all.remove_at(index)
                changes = true
                continue
            }
            if !types.has_unresolved(c.left) && !types.has_unresolved(c.right) {
                cons.all.remove_at(index)
                changes = true
                continue
            }
        }

        index += 1
    }

    ret changes
}

fun TypeChecker.execute_deferred_actions(): Boolean {
    let changes = false
    let index = 0

    while index < cons.actions.len {
        let deferred = cons.actions[index]!!

        if !types.has_unresolved(deferred.arg) {
            deferred.action.call(deferred.arg)
            cons.actions.remove_at(index)
            changes = true
            continue
        }

        index += 1
    }

    ret changes
}

fun TypeChecker.finalize(code: NCode, span: Span) {
    if !cons.all.is_empty() {
        reporter.report_error("Unresolved type constraints: ${cons.all.len}", span)
    }

    for i in code.inst {
        if i.type_wrapper.is_none() {
            reporter.report_error("Corrupt instruction", i.span)
            continue
        }

        let tt = i.type_wrapper!!.type_token

        if types.has_unresolved(tt) {
            reporter.report_error("Not enough context information to infer type", i.span)
        }
    }

}

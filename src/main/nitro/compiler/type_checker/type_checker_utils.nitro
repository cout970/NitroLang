
fun TypeChecker.create_error_type(message: String, span: Span): TypeToken {
    report_error(message, span)
    ret types.create_type(TypeKind::Invalid @[message, span], [])
}

fun TypeChecker.create_unresolved_type(span: Span): TypeToken {
    types.last_unresolved_id += 1
    ret types.create_type(TypeKind::Unresolved @[span, id: types.last_unresolved_id], [])
}

fun TypeChecker.create_unresolved_function_type(span: Span): TypeToken {
    types.last_unresolved_id += 1
    ret types.create_type(TypeKind::UnresolvedFunction @[span, id: types.last_unresolved_id], [])
}

fun TypeChecker.get_or_create_generic_type(generic: NGeneric): TypeToken {
    let cache = type_generic_cache[generic]
    if cache.is_some() {
        ret cache!!
    }

    let kind = TypeKind::Generic @[instance: generic]
    let tt = types.create_type(kind, [])

    type_generic_cache[generic] = tt
    ret tt
}

fun TypeChecker.replace_generics(type_token: TypeToken, generics: List<NGeneric>, args: List<TypeToken>): TypeToken {
    if generics.is_empty() || args.is_empty() {
        ret type_token
    }

    let replacements: Map<NGeneric, TypeToken> = #[]

    repeat min(generics.len, args.len) {
        replacements[generics[it]!!] = args[it]!!
    }

    let t = type_token.find_type()
    let new_params = []

    for param_token in t.params {
        let param = param_token.find_type()
        let kind = param.kind

        if kind is TypeKind::Generic {
            let replacement = replacements[(kind as TypeKind::Generic).instance]

            if replacement.is_some() {
                new_params[] = replacement!!
            } else {
                new_params[] = param_token
            }
        } else {
            new_params[] = param_token
        }
    }

    ret types.create_type(t.kind, new_params)
}

fun TypeChecker.report_error(msg: String, span: Span) {
    reporter.report_error(msg, span)
}

fun TypeChecker.report_warning(msg: String, span: Span) {
    reporter.report_warning(msg, span)
}

fun create_path_segments(full_name: String): List<String> {
    if "::" !in full_name {
        ret [full_name]
    }

    let parts = full_name.split("::")
    let result: List<String> = []

    repeat parts.len {
        let segments = parts.to_sublist(it, parts.len)
        result[] = segments.join("::")
    }

    ret result
}
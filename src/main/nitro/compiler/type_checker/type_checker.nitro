
struct TypeChecker {
    reporter: Reporter
    program: Program
    types: TypeContainer
    type_cache: Map<String, TypeToken>
    type_kind_cache: Map<String, TypeKind>
    type_generic_cache: Map<NGeneric, TypeKind>
    cons: TypeConstraints
    property_cache: PropertyCache
    current_code: Optional<NCode>
}

fun TypeChecker::new(reporter: Reporter, program: Program): TypeChecker {
    ret TypeChecker @[
        reporter,
        program,
        types: TypeContainer::new(),
        type_cache: #[],
        type_kind_cache: #[],
        type_generic_cache: #[],
        cons: TypeConstraints::new(),
        property_cache: PropertyCache::new(),
        current_code: None(),
    ]
}

fun TypeChecker.check_all() {
    // Step 1: Definitions
    for s in program.structs {
        check_struct(s)
    }
    for s in program.options {
        check_option(s)
    }
    for s in program.type_aliases {
        check_type_alias(s)
    }
    for s in program.consts {
        check_const_header(s)
    }
    for s in program.functions {
        check_function_header(s)
        collect_getters_and_setters(s)
    }

    // Step 2: Code
    for s in program.consts {
        check_code(s.code)
    }
    for s in program.functions {
        check_code(s.code)
    }

    // Step 3: implicit return
}

fun TypeChecker.check_struct(s: NStruct) {
    check_generics(s.generics)
    for field in s.fields {
        field.type_token = Some(check_type_usage(field.type_usage))
    }
}

fun TypeChecker.check_option(s: NOption) {
    check_generics(s.generics)
    for item in s.items {
        check_struct(item.def)
    }
}

fun TypeChecker.check_type_alias(s: NTypeAlias) {
    check_generics(s.generics)
    s.type_token = Some(check_type_usage(s.type_usage))
}

fun TypeChecker.check_const_header(s: NConst) {
    s.type_token = Some(check_type_usage(s.type_usage))
}

fun TypeChecker.check_function_header(s: NFunction) {
    check_generics(s.generics)
    for param in s.parameters {
        param.type_token = Some(check_type_usage(param.type_usage))
    }
    s.return_type_token = Some(check_type_usage(s.return_type_usage))
}

fun TypeChecker.check_generics(generics: NGenericParams) {
    for def in generics.definitions {
        generics.type_tokens[] = get_or_create_generic_type(def)

        for constraint in def.constraints {
            let found = false

            for tag_def in program.tags {
                if tag_def.name == constraint.name {
                    found = true
                    constraint.tag_definition = Some(tag_def)
                    break
                }
            }

            if !found {
                report_error("Tag not found: ${constraint.name}", def.span)
            }
        }
    }
}


struct TypeChecker {
    reporter: Reporter
    program: Program
    types: TypeContainer
    type_cache: Map<String, TypeToken>
    type_kind_cache: Map<String, TypeKind>
    type_generic_cache: Map<NGeneric, TypeKind>
    type_ctx: TypeContext
    cons: TypeConstraints
}

struct TypeContext {
    parent: Optional<TypeContext>
}

fun TypeChecker::new(reporter: Reporter, program: Program): TypeChecker {
    ret TypeChecker @[
        reporter,
        program,
        types: TypeContainer::new(),
        type_cache: #[],
        type_kind_cache: #[],
        type_generic_cache: #[],
        type_ctx: TypeContext @[parent: None()],
        cons: TypeConstraints::new(),
    ]
}

fun TypeChecker.check_all() {
    // Step 1: Definitions
    for s in program.structs {
        check_struct(s)
    }
    for s in program.options {
        check_option(s)
    }
    for s in program.type_aliases {
        check_type_alias(s)
    }
    for s in program.consts {
        check_const_header(s)
    }
    for s in program.functions {
        check_function_header(s)
        collect_getters_and_setters(s)
    }

    // Step 2: Code
    for s in program.consts {
        check_code(s.code)
    }
    for s in program.functions {
        check_code(s.code)
    }

    // Step 3: implicit return
}

fun TypeChecker.check_struct(s: NStruct) {
    check_generics(s.generics)
    for field in s.fields {
        field.type_token = Some(check_type_usage(field.type_usage))
    }
}

fun TypeChecker.check_option(s: NOption) {
    check_generics(s.generics)
    for item in s.items {
        check_struct(item.def)
    }
}

fun TypeChecker.check_type_alias(s: NTypeAlias) {
    check_generics(s.generics)
    s.type_token = Some(check_type_usage(s.type_usage))
}

fun TypeChecker.check_const_header(s: NConst) {
    s.type_token = Some(check_type_usage(s.type_usage))
}

fun TypeChecker.check_function_header(s: NFunction) {
    check_generics(s.generics)
    for param in s.parameters {
        param.type_token = Some(check_type_usage(param.type_usage))
    }
    s.return_type_token = Some(check_type_usage(s.return_type_usage))
}

fun TypeChecker.check_generics(generics: NGenericParams) {
    for def in generics.definitions {
        generics.type_tokens[] = get_or_create_generic_type(def)

        for constraint in def.constraints {
            let found = false

            for tag_def in program.tags {
                if tag_def.name == constraint.name {
                    found = true
                    constraint.tag_definition = Some(tag_def)
                    break
                }
            }

            if !found {
                report_error("Tag not found: ${constraint.name}", def.span)
            }
        }
    }
}

fun TypeChecker.collect_getters_and_setters(func: NFunction) {
    if func.name.starts_with("get_") && func.parameters.len == 1 && func.has_receiver {
        let ret_ty = func.return_type_token!!

        if !types.is_nothing(ret_ty) && !types.is_never(ret_ty) {
            let property_name = func.name.slice(4, func.name.len - 4)
            let receiver_type = check_type_usage(func.parameters.first()!!.type_usage)

            program.property_getters[] = NPropertyAccessor @[receiver_type, property_name, func]
            ret
        }
    }

    if func.name.starts_with("set_") && func.parameters.len == 2 && func.has_receiver {
        let ret_ty = func.return_type_token!!
        let receiver_type = check_type_usage(func.parameters.first()!!.type_usage)

        if types.is_nothing(ret_ty) || types.is_equal(ret_ty, receiver_type) {
            let property_name = func.name.slice(4, func.name.len - 4)

            program.property_setters[] = NPropertyAccessor @[receiver_type, property_name, func]
        }
    }
}


type_alias TypeId = Int

struct Type {
    id: TypeId
    kind: TypeKind
    params: List<TypeToken>
}

option TypeKind {
    Struct {
        instance: NStruct
    }
    Option {
        instance: NOption
    }
    OptionItem {
        instance: NStruct
    }
    Lambda {
        instance: NLambda
    }
    Generic {
        instance: NGeneric
    }
    Union {
        span: Span
    }
    Unresolved {
        id: Int
        span: Span
    }
    UnresolvedFunction {
        id: Int
        span: Span
    }
    Invalid {
        message: String
        span: Span
    }
}

fun TypeKind.get_kind_name(): String {
    ret when {
        this is TypeKind::Struct -> "Struct"
        this is TypeKind::Option -> "Option"
        this is TypeKind::OptionItem -> "OptionItem"
        this is TypeKind::Lambda -> "Lambda"
        this is TypeKind::Generic -> "Generic"
        this is TypeKind::Union -> "Union"
        this is TypeKind::Unresolved -> "Unresolved"
        this is TypeKind::UnresolvedFunction -> "UnresolvedFunction"
        this is TypeKind::Invalid -> "Invalid"
        else -> crash("Unknown type kind")
    }
}

fun TypeKind.get_span(): Span {
    ret when {
        this is TypeKind::Struct -> (this as TypeKind::Struct).instance.span
        this is TypeKind::Option -> (this as TypeKind::Option).instance.span
        this is TypeKind::OptionItem -> (this as TypeKind::OptionItem).instance.span
        this is TypeKind::Lambda -> (this as TypeKind::Lambda).instance.span
        this is TypeKind::Generic -> (this as TypeKind::Generic).instance.span
        this is TypeKind::Union -> (this as TypeKind::Union).span
        this is TypeKind::Unresolved -> (this as TypeKind::Unresolved).span
        this is TypeKind::UnresolvedFunction -> (this as TypeKind::UnresolvedFunction).span
        this is TypeKind::Invalid -> (this as TypeKind::Invalid).span
        else -> crash("Unknown type kind")
    }
}

fun TypeKind.is_equal(other: TypeKind): Boolean {
    ret this.kind_name == other.kind_name && this.span == other.span
}

fun Type.is_equal(other: Type): Boolean {
    if !this.kind.is_equal(other.kind) {
        ret false
    }

    if this.params.len != other.params.len {
        ret false
    }

    repeat params.len {
        if !this.params[it]!!.is_equal(other.params[it]!!) {
            ret false
        }
    }

    ret true
}

fun TypeKind.get_ordering(other: TypeKind): Ordering {
    let ord = this.kind_name <=> other.kind_name

    if ord != Ordering::Equals {
        ret ord
    }

    if this is TypeKind::Unresolved && other is TypeKind::Unresolved {
        let this_unresolved = this as TypeKind::Unresolved
        let other_unresolved = other as TypeKind::Unresolved
        ret this_unresolved.id <=> other_unresolved.id
    }

    if this is TypeKind::UnresolvedFunction && other is TypeKind::UnresolvedFunction {
        let this_unresolved = this as TypeKind::UnresolvedFunction
        let other_unresolved = other as TypeKind::UnresolvedFunction
        ret this_unresolved.id <=> other_unresolved.id
    }

    ret this.span <=> other.span
}

fun Type.to_string(): String {
    let result = kind.to_string()

    if params.len > 0 {
        result += "<"
        repeat params.len {
            result += params[it]!!.to_string()
            if it < params.len - 1 {
                result += ", "
            }
        }
        result += ">"
    }

    ret result
}

fun TypeKind.to_string(): String {
    if this is TypeKind::Struct {
        let kind = this as TypeKind::Struct
        let instance: NStruct = kind.instance
        ret instance.full_name
//        ret "[struct ${instance.full_name}]"
    }
    if this is TypeKind::Option {
        let kind = this as TypeKind::Option
        let instance: NOption = kind.instance
        ret instance.full_name
//        ret "[option ${instance.full_name}]"
    }
    if this is TypeKind::OptionItem {
        let kind = this as TypeKind::OptionItem
        let instance: NStruct = kind.instance
        ret instance.full_name
//        ret "[option-item ${instance.full_name}]"
    }
    if this is TypeKind::Lambda {
        let kind = this as TypeKind::Lambda
        ret "[lambda ${kind.instance.span}]"
    }
    if this is TypeKind::Generic {
        let kind = this as TypeKind::Generic
        let instance: NGeneric = kind.instance
//        ret "#${instance.name}"
        ret "[generic #${instance.name} ${instance.source} ${instance.span.link}]"
    }
    if this is TypeKind::Union {
        let kind = this as TypeKind::Union
        ret "[union]"
    }
    if this is TypeKind::Unresolved {
        let kind = this as TypeKind::Unresolved
        ret "[unresolved ${kind.id}]"
    }
    if this is TypeKind::UnresolvedFunction {
        let kind = this as TypeKind::UnresolvedFunction
        ret "[unresolved-function ${kind.id}]"
    }
    if this is TypeKind::Invalid {
        let kind = this as TypeKind::Invalid
        ret "[invalid \"${kind.message}\"]"
    }
    crash("Unknown type kind")
}
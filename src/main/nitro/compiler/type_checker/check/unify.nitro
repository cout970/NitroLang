
struct UnifyCtx {
    reporter: Reporter
    types: TypeContainer
    cons: TypeConstraints
    code: NCode
    span: Span
    unresolved_types: Map<TypeToken, TypeToken>
}


fun UnifyCtx.unify(left: TypeToken, right: TypeToken) {
    if types.is_unresolved(left) || types.is_unresolved_function(left) {
        add_substitution(left, right)
        ret
    }
    if types.is_unresolved(right) || types.is_unresolved_function(right){
        add_substitution(left, right)
        ret
    }

    if types.is_invalid(left) {
        ret
    }
    if types.is_invalid(right) {
        ret
    }

    if types.is_generic(left) {
        if types.is_never(right) {
            ret
        }

        if !types.are_equal(left, right) {
            report_type_mismatch(left, right)
        }
        ret
    }

    if types.is_generic(right) {
        if types.is_never(left) {
            ret
        }

        if !types.are_equal(left, right) {
            report_type_mismatch(left, right)
        }
        ret
    }

    if types.is_composite(left) && types.is_composite(right) {
        let left_type = types.get_type(left)
        let right_type = types.get_type(right)

        repeat min(left_type.params.len, right_type.params.len) {
            unify(left_type.params[it]!!, right_type.params[it]!!)
        }

        if left_type.params.len != right_type.params.len {
            report_type_mismatch(left, right)
            ret
        }

        if left_type.kind != right_type.kind && types.common_kind_type(left_type.kind, right_type.kind).is_none() {
            report_type_mismatch(left, right)
        }
        ret
    }

    report_type_mismatch(left, right)
}

fun UnifyCtx.add_substitution(key: TypeToken, value: TypeToken) {
    // Equal? nothing to do
    if types.are_equal(key, value) {
        ret
    }

    // Handle recursive types
    if types.contains_param(value, key) {
        let new_value = types.remove_unresolved(value, key)

        if types.contains_param(new_value, key) {
            crash("Recursive type: $key -> $value")
        }

        add_substitution(key, new_value)
        ret
    }

    // Add a substitution
    if key !in unresolved_types {
        unresolved_types[key] = value
        ret
    }

    // In case of conflict
    let prev = unresolved_types[key]!!
    let next = value

    // No conflict, actually
    if types.are_equal(prev, next) {
        ret
    }

    let common = types.common_type(prev, next)

    if common.is_some() {
        unresolved_types[key] = common!!
        ret
    }

    // Conflict
    if !types.has_unresolved(prev) && !types.has_unresolved(next) {
        report_type_mismatch(prev, next)
        ret
    }

    // Partial conflict
    let sub_ctx = UnifyCtx @[
        reporter,
        types,
        cons,
        span,
        code,
        unresolved_types: #[],
    ]

    sub_ctx.unify(prev, next)
    sub_ctx.merge_into(this)
}

fun UnifyCtx.report_type_mismatch(a: TypeToken, b: TypeToken) {
    let ty_a = types.get_type(a)
    let ty_b = types.get_type(b)

    if ty_a.kind is TypeKind::Generic && ty_b.kind is TypeKind::Generic {
        let a_generic: NGeneric = (ty_a.kind as TypeKind::Generic).instance
        let b_generic: NGeneric = (ty_b.kind as TypeKind::Generic).instance

        reporter.report_error("Type mismatch: ${ty_a} (${a_generic.id_wrapper.id}) != ${ty_b} (${b_generic.id_wrapper.id})", span)
        ret
    }

    reporter.report_error("Type mismatch: ${ty_a} != ${ty_b}", span)
}

fun UnifyCtx.merge_into(other: UnifyCtx) {
    // Copy unresolved types
    for entry in other.unresolved_types {

        if entry.first !in this.unresolved_types {
            this.unresolved_types[entry.first] = entry.second
            continue
        }

        let prev = this.unresolved_types[entry.first]!!

        this.unresolved_types[entry.first] = types.create_union(prev, entry.second)
    }
}
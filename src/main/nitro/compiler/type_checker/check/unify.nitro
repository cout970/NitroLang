
struct UnifyCtx {
    reporter: Reporter
    current_inst: NInstId
    types: TypeContainer
    cons: TypeConstraints
    code: NCode
    span: Span
    unresolved_types: Map<Type, TypeToken>
}

fun UnifyCtx.unify(left: Type, right: Type) {
    if left.is_unresolved() || left.is_unresolved_function() {
        add_substitution(left, right)
        ret
    }
    if right.is_unresolved() || right.is_unresolved_function() {
        add_substitution(right, left)
        ret
    }

    if left.is_invalid() {
        ret
    }
    if right.is_invalid() {
        ret
    }

    if left.is_generic() {
        if right.is_never() {
            ret
        }

        if left != right {
            report_type_mismatch(left, right)
        }
        ret
    }

    if right.is_generic() {
        if left.is_never() {
            ret
        }

        if left != right {
            report_type_mismatch(left, right)
        }
        ret
    }

    if left.is_composite() && right.is_composite() {
        let left_params = left.type_params
        let right_params = right.type_params

        repeat min(left_params.len, right_params.len) {
            unify(left_params[it]!!, right_params[it]!!)
        }

        let need_same_params = !(left.is_never() || left.is_never() || left.is_function() || left.is_function())

        if need_same_params && left_params.len != right_params.len {
            report_type_mismatch(left, right)
            ret
        }

        if left.kind != right.kind && types.common_kind_type(left.kind, right.kind).is_none() {
            report_type_mismatch(left, right)
        }
        ret
    }

    if (left.is_lambda() && right.is_function()) || (right.is_lambda() && left.is_function()) {
        let left_params = left.type_params
        let right_params = right.type_params

        repeat min(left_params.len, right_params.len) {
            unify(left_params[it]!!, right_params[it]!!)
        }

        if left_params.len != right_params.len {
            report_type_mismatch(left, right)
        }
        ret
    }

    report_type_mismatch(left, right)
}

fun UnifyCtx.add_substitution(key: Type, value: Type) {
    // Equal? nothing to do
    if key == value {
        ret
    }

    // Handle recursive types
    if value.contains_type_param(key) {
        let new_value = value.remove_unresolved(key)

        check_not(new_value.contains_type_param(key)) @{
            "Recursive type: $key -> $value"
        }

        add_substitution(key, new_value)
        ret
    }

    // Add a substitution
    if key !in unresolved_types {
        unresolved_types[key] = value.to_token()
        ret
    }

    // In case of conflict
    let prev = unresolved_types[key]!!.find_type()
    let next = value

    // No conflict, actually
    if prev == next {
        ret
    }

    let common = types.common_type(prev, next)

    if common.is_some() {
        unresolved_types[key] = common!!.to_token()
        ret
    }

    // Conflict
    if !prev.has_unresolved() && !next.has_unresolved() {
        report_type_mismatch(prev, next)
        ret
    }

    // Partial conflict
    let sub_ctx = UnifyCtx @[
        reporter,
        current_inst,
        types,
        cons,
        span,
        code,
        unresolved_types: #[],
    ]

    sub_ctx.unify(prev, next)
    sub_ctx.merge_into(this)
}

fun UnifyCtx.report_type_mismatch(a: Type, b: Type) {
    reporter.report_error("Type mismatch: $a != $b", span)
}

fun UnifyCtx.merge_into(other: UnifyCtx) {
    // Copy unresolved types
    for entry in other.unresolved_types {

        if entry.first !in this.unresolved_types {
            this.unresolved_types[entry.first] = entry.second
            continue
        }

        let prev = this.unresolved_types[entry.first]!!.find_type()

        this.unresolved_types[entry.first] = types.create_union(prev, entry.second.find_type()).to_token()
    }
}
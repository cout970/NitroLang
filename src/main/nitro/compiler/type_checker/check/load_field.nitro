

fun TypeChecker.check_inst_load_field(kind: NInstKind::LoadField, inst: NInst, code: NCode) {
    let instance_tt = code.find_type(kind.instance)

    check(instance_tt.is_some()) @{ "Instance must have a type (#${kind.instance})" }

    let inst_type = create_unresolved_type(inst.span)
    inst.type_token = Some(inst_type)

    let checker = this
    cons.once_resolved(instance_tt!!) @{ instance_tt: TypeToken ->
        checker.check_inst_load_field_post(kind, inst, code, inst_type, instance_tt)
    }
}

fun TypeChecker.check_inst_load_field_post(kind: NInstKind::LoadField, inst: NInst, code: NCode, inst_type: TypeToken, instance_tt: TypeToken) {
    // Direct struct field
    let field_name = kind.name
    let field: Optional<NStructField> = find_field(instance_tt, field_name)

    if field.is_some() {
        let field_type_token = field!!.type_token!!
        let generics = field!!.parent_struct.generics
        let type_parameters = []

        let instance_ty = instance_tt.find_type()

        // Convert every generic type defined in the struct to a unresolved type at the call site
        for generic_tt in generics.type_tokens {
            let un = create_unresolved_type(inst.span)
            type_parameters[] = un
            // TODO type bounds

            field_type_token = types.replace(field_type_token, generic_tt, un)
        }

        cons.add_unify_list(types.create_type_tokens(instance_ty.params), type_parameters, inst.span)
        cons.add_unify(inst_type, field_type_token, inst.span)
        ret
    }

    // Getter function
    let getter = find_getter(instance_tt, field_name)

    if getter.is_some() {
        // Overwrite with a FunCall
        inst.kind = NInstKind::FunCall @[
            path: "",
            name: "get_$field_name",
            arguments: [kind.instance],
            explicit_type_arguments: [],
            call_site: None(),
        ]
        let index = code.index_of(inst.id)!!
        inst.type_token = None()
        check_inst(index, inst, code)
        cons.add_unify(inst_type, inst.type_token!!, inst.span)
        ret
    }

    let instance_type = instance_tt.find_type()
    let error = create_error_type("Field not found '$field_name' on $instance_type", inst.span)
    cons.add_unify(inst_type, error, inst.span)
}

fun TypeChecker.check_inst_store_field(kind: NInstKind::StoreField, inst: NInst, code: NCode) {
    let instance_tt = code.find_type(kind.instance)

    check(instance_tt.is_some()) @{ "Instance must have a type (#${kind.instance})" }

    inst.type_token = type_cache["Nothing"]

    let checker = this
    cons.once_resolved(instance_tt!!) @{ instance_tt: TypeToken ->
        checker.check_inst_store_field_post(kind, inst, code, instance_tt)
    }
}

fun TypeChecker.check_inst_store_field_post(kind: NInstKind::StoreField, inst: NInst, code: NCode, instance_tt: TypeToken) {
    // Direct struct field
    let field_name = kind.name
    let field: Optional<NStructField> = find_field(instance_tt, field_name)

    if field.is_some() {
        let field_type_token = field!!.type_token!!
        let generics = field!!.parent_struct.generics
        let type_parameters = []

        let instance_ty = instance_tt.find_type()

        // Convert every generic type defined in the struct to a unresolved type at the call site
        for generic_tt in generics.type_tokens {
            let un = create_unresolved_type(inst.span)
            type_parameters[] = un
            // TODO type bounds

            field_type_token = types.replace(field_type_token, generic_tt, un)
        }

        kind.field_type_token = Some(field_type_token)

        cons.add_unify_list(instance_ty.type_tokens, type_parameters, inst.span)

        let value_tt = code.find_type(kind.value)
        if value_tt.is_some() {
            cons.add_unify(value_tt!!, field_type_token, inst.span)
        }
        ret
    }

    // Getter function
    let setter = find_setter(instance_tt, field_name)

    if setter.is_some() {
        // Overwrite with a FunCall
        inst.kind = NInstKind::FunCall @[
            path: "",
            name: "set_$field_name",
            arguments: [kind.instance, kind.value],
            explicit_type_arguments: [],
            call_site: None(),
        ]
        let index = code.index_of(inst.id)!!
        inst.type_token = None()
        check_inst(index, inst, code)
        ret
    }

    let instance_type = instance_tt.find_type()
    let error = create_error_type("Field not found '$field_name' on $instance_type", inst.span)
    inst.type_token = Some(error)
}
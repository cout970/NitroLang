

fun TypeChecker.check_type_usage(tu: NTypeUsage): TypeToken {
    if tu.type_token.is_some() {
        ret tu.type_token!!
    }

    let params: List<TypeToken> = []

    for tp in tu.params {
        params[] = check_type_usage(tp)
    }

    when tu.kind {
        TypeUsageKind::TYPE_SIMPLE -> {
            let full_name = get_full_path(tu.path, tu.name)
            let path_segments = create_path_segments(full_name)

            for segment in path_segments {
                // type_cache only works by name, it doesn't take into account the type arguments
                // so it's limited on what it can cache
                if params.is_empty() {
                    let cache = type_cache[segment]
                    if cache.is_some() {
                        let tt = cache!!
                        tu.type_token = Some(tt)
                        ret tt
                    }
                }

                // Type alias
                for i in program.type_aliases {
                    if get_full_path(i.path, i.name) == segment {
                        let alias_type = check_type_usage(i.type_usage)
                        let tt = replace_generics(alias_type, i.generics.definitions, params)

                        if params.is_empty() {
                            type_cache[segment] = tt
                        }

                        tu.type_token = Some(tt)
                        ret tt
                    }
                }

                // Cache for type kinds
                let kind_cache = type_kind_cache[segment]
                if kind_cache.is_some() {
                    let kind = kind_cache!!
                    let tt = types.create_type(kind, params)

                    if params.is_empty() {
                        type_cache[segment] = tt
                    }

                    tu.type_token = Some(tt)
                    ret tt
                }

                // Is an Option?
                for i in program.options {
                    if i.full_name == segment {
                        let kind: TypeKind = TypeKind::Option @[instance: i]
                        type_kind_cache[segment] = kind

                        let tt = types.create_type(kind, params)

                        if params.is_empty() {
                            type_cache[segment] = tt
                        }

                        tu.type_token = Some(tt)
                        ret tt
                    }
                }

                // Is a Struct?
                for i in program.structs {
                    if i.full_name == segment {
                        let kind: TypeKind = if i.parent.is_some() {
                            TypeKind::OptionItem @[instance: i]
                        } else {
                            TypeKind::Struct @[instance: i]
                        }

                        type_kind_cache[segment] = kind

                        let tt = types.create_type(kind, params)

                        if params.is_empty() {
                            type_cache[segment] = tt
                        }

                        tu.type_token = Some(tt)
                        ret tt
                    }
                }
            }

            // Not found
            let tt = create_error_type("Type '$full_name' not found", tu.span)
            tu.type_token = Some(tt)
            ret tt
        }
        TypeUsageKind::TYPE_PARAM -> {
            let generic: Optional<NGeneric> = tu.generic_definition

            // Usage in definition
            if generic.is_some() {
                let tt = get_or_create_generic_type(generic!!)
                tu.type_token = Some(tt)
                ret tt
            }

            // Usage in code
            if current_code.is_some() {
                let opt = find_generic_by_name(current_code!!, tu.name)

                if opt.is_some() {
                    tu.type_token = opt
                    ret opt!!
                }
            }

            // Not found
            let tt = create_error_type("Generic not found: ${tu.name}", tu.span)
            tu.type_token = Some(tt)
            ret tt
        }
        TypeUsageKind::TYPE_UNRESOLVED -> {
            let tt = create_unresolved_type(tu.span)
            tu.type_token = Some(tt)
            ret tt
        }
    }

    unreachable()
}

fun TypeChecker.find_generic_by_name(code: NCode, name: String): Optional<TypeToken> {
    repeat code.generics.definitions.len {
       let def: NGeneric = code.generics.definitions[it]!!

       // Safety check
       if def.source != NGenericSource::Function && def.source != NGenericSource::Lambda {
           crash("Invalid generic source $def\n$code")
       }

       if def.name == name {
           ret code.generics.type_tokens[it]
       }
   }

   if code.parent_code.is_some() {
       ret find_generic_by_name(code.parent_code!!, name)
   }

   ret None()
}

struct Index {
    current: Int
}

fun TypeChecker.finalize() {
    let index = 0
    while index < cons.codes.len {
        check_code(cons.codes[index]!!)
        index += 1
    }

    // Report unresolved types and unresolved constraints
    if !cons.all.is_empty() {
        let info = ""
        for i in cons.all {
            if i is TypeConstraint::Unify {
                let c = i as TypeConstraint::Unify

                info += "  - $i\nleft:${c.left.inspect()}\nright:${c.right.inspect()}\n"
            }
        }
        reporter.report_error("Unresolved type constraints:\n$info\n${cons.codes}", cons.codes.first()!!.span)
        cons.all.clear()
    }

    index = 0
    while index < cons.codes.len {
        finalize_code(cons.codes[index]!!)
        index += 1
    }

    cons.codes.clear()
}

fun TypeChecker.check_code(code: NCode) {
    let previous_code = current_code
    current_code = Some(code)
    defer { current_code = previous_code }

    for v in code.vars {
        check_var(v, code)
    }

    // check_inst() can add new instructions, so we need to loop until the end
    let index = Index @[current: 0]
    while index.current < code.inst.len {
        let current = code.inst[index.current]!!
        check_inst(index, current, code)
        index.current += 1

        // Resolve constraints to replace unresolved types
        // We do this on every line, so when a error occurs, we at the location of the error
        // If we solve at the end, we would have no way of knowing where the error occurred,
        // because the are relations between types that are complex and can be solved in many different ways
        cons.resolve(this, code, current.id, current.span)
    }

    // The last expression, which has an implicit return, must match the return type of the function
    if code.last_expression.is_some() && code.return_type.is_some() && !(types.is_nothing(code.return_type!!) || types.is_never(code.return_type!!)) {
        let current = code.find(code.last_expression!!)!!
        cons.add_unify(current.type_token!!, code.return_type!!, current.span)
        cons.resolve(this, code, current.id, current.span)
    }
}

fun TypeChecker.finalize_code(code: NCode) {
//    println("Finalizing code at ${code.span}")

    // Sanity check
    for i in code.inst {
        check(i.type_token.is_some()) @{ "All instructions must have a type: $i\n$code" }

        if i.kind is NInstKind::LoadVar {
            let kind = i.kind as NInstKind::LoadVar

            check(kind.variable.is_some() || kind.constant.is_some()) @{ "LoadVar is not linked: $i\n${code.parent_code}" }
        }
        if i.kind is NInstKind::StoreVar {
            let kind = i.kind as NInstKind::StoreVar

            check(kind.variable.is_some()) @{ "StoreVar is not linked: $i\n$code" }
        }
        if i.kind is NInstKind::FunCall {
            let kind = i.kind as NInstKind::FunCall

            check(kind.call_site.is_some()) @{ "FunCall is not linked: #${i.id} $i\n$code" }
        }

        let tt = i.type_token!!

        if types.has_unresolved(tt) {
            reporter.report_error("Not enough context information to infer type $tt at #${i.id}", i.span)
        }
    }
}

fun TypeChecker.check_var(v: NVar, code: NCode) {
    if v.type_token.is_none() {
        v.type_token = Some(check_type_usage(v.type_usage))

        // Store the type of `this` for later
        if v.name == "this" {
            code.receiver_type = v.type_token
        }
    }
}

fun TypeChecker.check_inst(index: Index, inst: NInst, code: NCode) {
    // Already visited
    if inst.type_token.is_some() {
        ret
    }

    if inst.kind is NInstKind::Let {
        let kind = inst.kind as NInstKind::Let
        check_var(kind.variable, code)

        inst.type_token = type_cache["Nothing"]
        ret
    }

    if inst.kind is NInstKind::IfStart {
        inst.type_token = type_cache["Nothing"]
        ret
    }

    if inst.kind is NInstKind::IfElse {
        inst.type_token = type_cache["Nothing"]
        ret
    }

    if inst.kind is NInstKind::IfEnd {
        inst.type_token = type_cache["Nothing"]
        ret
    }

    if inst.kind is NInstKind::IfChoose {
        let kind = inst.kind as NInstKind::IfChoose
        let cond_type = code.find_type(kind.condition)
        let if_true_type = code.find_type(kind.if_true)
        let if_false_type = code.find_type(kind.if_false)

        check_not(cond_type.is_none() || if_true_type.is_none() || if_false_type.is_none()) @{
            "Previous instructions must have types (cond: $cond_type, if_true: $if_true_type, if_false: $if_false_type)"
        }

        let common = check_type_usage(NTypeUsage::unresolved(inst.span))

        cons.add_unify(cond_type!!, type_cache["Boolean"]!!, inst.span)
        cons.add_unify(common, if_true_type!!, inst.span)
        cons.add_unify(common, if_false_type!!, inst.span)

        inst.type_token = Some(common)
        ret
    }

    if inst.kind is NInstKind::LoopStart {
        inst.type_token = type_cache["Nothing"]
        ret
    }

    if inst.kind is NInstKind::LoopEnd {
        inst.type_token = type_cache["Nothing"]
        ret
    }

    if inst.kind is NInstKind::BlockJump {
        inst.type_token = type_cache["Nothing"]
        ret
    }

    if inst.kind is NInstKind::WhenStart {
        inst.type_token = type_cache["Nothing"]
        ret
    }

    if inst.kind is NInstKind::WhenEnd {
        inst.type_token = type_cache["Nothing"]
        ret
    }

    if inst.kind is NInstKind::FunCall {
        check_inst_fun_call(inst.kind as NInstKind::FunCall, inst, code)
        ret
    }

    if inst.kind is NInstKind::Literal {
        check_inst_literal(inst.kind as NInstKind::Literal, inst, code)
        ret
    }

    if inst.kind is NInstKind::Return {
        let kind = inst.kind as NInstKind::Return
        let value_tt = code.find_type(kind.value)

        if value_tt.is_some() && code.return_type.is_some() {
            cons.add_unify(value_tt!!, code.return_type!!, inst.span)
        }

        inst.type_token = type_cache["Never"]
        ret
    }

    if inst.kind is NInstKind::IsType {
        inst.type_token = type_cache["Boolean"]
        ret
    }

    if inst.kind is NInstKind::AsType {
        let kind = inst.kind as NInstKind::AsType
        let tt = check_type_usage(kind.type_usage)
        inst.type_token = Some(tt)
        ret
    }

    if inst.kind is NInstKind::LoadVar {
        check_inst_load_var(inst.kind as NInstKind::LoadVar, index, inst, code)
        ret
    }

    if inst.kind is NInstKind::StoreVar {
        check_inst_store_var(inst.kind as NInstKind::StoreVar, index, inst, code)
        ret
    }

    if inst.kind is NInstKind::LoadField {
        check_inst_load_field(inst.kind as NInstKind::LoadField, inst, code)
        ret
    }

    if inst.kind is NInstKind::StoreField {
        check_inst_store_field(inst.kind as NInstKind::StoreField, inst, code)
        ret
    }

    if inst.kind is NInstKind::SizeOf {
        let kind = inst.kind as NInstKind::SizeOf
        kind.type_token = Some(check_type_usage(kind.type_usage))
        inst.type_token = type_cache["Int"]
        ret
    }

    if inst.kind is NInstKind::Alloc {
        check_inst_alloc(inst.kind as NInstKind::Alloc, inst, code)
        ret
    }

    if inst.kind is NInstKind::Lambda {
        let kind = inst.kind as NInstKind::Lambda
        check_inst_lambda(kind, inst, code)
        ret
    }

    if inst.kind is NInstKind::Link {
        let kind = inst.kind as NInstKind::Link
        let link_type = code.find_type(kind.linked_id)

        check_not(link_type.is_none()) @{
            "Linked instruction must have a type (#${kind.linked_id})"
        }

        inst.type_token = link_type
        ret
    }

    if inst.kind is NInstKind::Comment {
        inst.type_token = type_cache["Nothing"]
        ret
    }

    if inst.kind is NInstKind::Noop {
        inst.type_token = type_cache["Nothing"]
        ret
    }

    inst.type_token = type_cache["Nothing"]
    ret
}

fun TypeChecker.add_load_this_var(code: NCode, index: Index): NInstId {
    // Duplicate current instruction
    code.duplicate_inst(index.current)
    // Get the duplicated instruction (first of the two)
    let dup = code.inst[index.current]!!

    let variable = find_variable(code, "this", dup.block, dup.id)

    check_not(variable.is_none()) @{
        "Unable to find variable `this`"
    }

    // Replace it's kind with LoadVar for `this`
    dup.kind = NInstKind::LoadVar @[
        path: "",
        name: "this",
        variable,
        constant: None(),
    ]

    // Check the new instruction now
    check_inst(index, dup, code)

    // Skip the LoadVar instruction
    index.current += 1

    ret dup.id
}

fun TypeChecker.check_inst_literal(kind: NInstKind::Literal, inst: NInst, code: NCode) {
    let expr: NConstExpr = kind.value

    when {
        expr is NConstExpr::NConstInt -> {
            inst.type_token = type_cache["Int"]
        }
        expr is NConstExpr::NConstLong -> {
            inst.type_token = type_cache["Long"]
        }
        expr is NConstExpr::NConstFloat -> {
            inst.type_token = type_cache["Float"]
        }
        expr is NConstExpr::NConstString -> {
            inst.type_token = type_cache["String"]
        }
        expr is NConstExpr::NConstBoolean -> {
            inst.type_token = type_cache["Boolean"]
        }
        else -> {
            inst.type_token = type_cache["Nothing"]
        }
    }
}
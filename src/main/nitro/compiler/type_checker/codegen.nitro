
let ENABLE_RC_GC: Boolean = false
let FIELD_RC_HEADER: String = "internal_rc_header"

fun TypeChecker.generate_struct_rc_functions() {
    // Generate constructors/destructors for all structs
    let pending_constructors = []
    let pending_destructors = []

    for def in program.structs {
        let create_init = program.functions.find @{ f -> f.is_constructor_for(def.name) }.is_none()
        let create_deinit = program.functions.find @{ f -> f.is_destructor_for(def.name) }.is_none()

        if create_init {
            pending_constructors[] = def
        }
        if create_deinit {
            pending_destructors[] = def
        }
    }

    for def in pending_constructors {
        let span = def.span
        let annotations = [
            NAnnotation @[span, name: ANNOTATION_AUTOGENERATED, args: []],
            NAnnotation @[span, name: ANNOTATION_DEFAULT_IMPL, args: []],
        ]

        let init_func = program.create_function(NFunctionHeader::new(span, "", "init", NTypeUsage::simple(span, "Nothing")), annotations)
        let generics = []

        for gen in def.generics.definitions {
            init_func.header.generics[] = NGeneric @[
                id: program.id_provider.next(),
                index: gen.index,
                span: def.span,
                name: gen.name,
                source: NGenericSource::Function,
                bounds: gen.bounds,
            ]
            generics[] = NTypeUsage::generic(span, gen.name, Some(gen.index))
        }

        let init_receiver_type_usage = NTypeUsage::simple_with_params(span, def.full_name, generics)
        init_func.add_parameter(span, "this", init_receiver_type_usage)
        init_func.register_params()
        program.functions[] = init_func
    }

    for def in pending_destructors {
        let span = def.span
        let annotations = [
            NAnnotation @[span, name: ANNOTATION_AUTOGENERATED, args: []],
            NAnnotation @[span, name: ANNOTATION_DEFAULT_IMPL, args: []],
        ]
        let deinit_func = program.create_function(NFunctionHeader::new(span, "", "deinit", NTypeUsage::simple(span, "Nothing")), annotations)
        let generics = []

        for gen in def.generics.definitions {
            deinit_func.header.generics[] = NGeneric @[
                id: program.id_provider.next(),
                index: gen.index,
                span: def.span,
                name: gen.name,
                source: NGenericSource::Function,
                bounds: gen.bounds,
            ]
            generics[] = NTypeUsage::generic(span, gen.name, Some(gen.index))
        }

        let deinit_receiver_type_usage = NTypeUsage::simple_with_params(span, def.full_name, generics)
        deinit_func.add_parameter(span, "this", deinit_receiver_type_usage)
        deinit_func.register_params()
        program.functions[] = deinit_func
    }

    // Generate implementation of tag RC
    for def in program.structs {
        if def.get_annotation(ANNOTATION_TMP_RC).is_none() {
            continue
        }
//        if !def.is_enum && def.get_annotation(ANNOTATION_NO_GC).is_none() {
//            continue
//        }

        let span = def.span
        let generic_type_usages = []
        let annotations = [
            NAnnotation @[span, name: ANNOTATION_NO_GC, args: []],
            NAnnotation @[span, name: ANNOTATION_AUTOGENERATED, args: []]
        ]

        // fun This.get_rc_header(): RcHeader
        let generic_params = NGenericParams::new(NGenericSource::Function)

        for gen in def.generics.definitions {
            let this_generic = NGeneric @[
               id: program.id_provider.next(),
               index: gen.index,
               span,
               name: gen.name,
               source: NGenericSource::Function,
               bounds: gen.bounds,
            ]
            generic_params[] = this_generic
            generic_type_usages[] = NTypeUsage::generic(span, this_generic.name, Some(gen.index))
        }

        // `fun Struct<#Param>.get_rc_header(): RcHeader`
        let parameters = [
            NFunctionParameter @[
                 span,
                 name: "this",
                 type_usage: NTypeUsage::simple_with_params(span, def.full_name, generic_type_usages),
                param_type: None(),
            ]
        ]
        let header = NFunctionHeader::new_full(span, "", "get_rc_header", NTypeUsage::simple(span, "RcHeader"), parameters, generic_params)
        let func = program.create_function(header, annotations)
        func.register_params()

        // `ret this.internal_rc_header`
        let load_this = func.code.add_load_var(span, "", "this", None())
        let field = func.code.add_load_field(span, load_this.id, "internal_rc_header")
        func.code.add_return(span, field.id)

        program.functions[] = func

        // `fun Struct<#Param>.set_rc_header(h: RcHeader): Nothing`
        let parameters2 = [
            NFunctionParameter @[
                 span,
                 name: "this",
                 type_usage: NTypeUsage::simple_with_params(span, def.full_name, generic_type_usages),
                param_type: None(),
            ],
            NFunctionParameter @[
                 span,
                 name: "h",
                 type_usage: NTypeUsage::simple(span, "RcHeader"),
                param_type: None(),
            ]
        ]
        let header2 = NFunctionHeader::new_full(span, "", "set_rc_header", NTypeUsage::simple(span, "Nothing"), parameters2, generic_params)
        let func2 = program.create_function(header2, annotations)
        func2.register_params()

        // `this.internal_rc_header = h`
        let load_this2 = func2.code.add_load_var(span, "", "this", None())
        let load_h = func2.code.add_load_var(span, "", "h", None())
        let store = func2.code.add_store_field(span, load_this2.id, "internal_rc_header", load_h.id)
        let nothing_lit = func2.code.add_lit_nothing(span)
        func2.code.add_return(span, nothing_lit.id)

        program.functions[] = func2

        // `fun Struct<#Param>.internal_free(): Nothing`
        let parameters3 = [
            NFunctionParameter @[
                 span,
                 name: "this",
                 type_usage: NTypeUsage::simple_with_params(span, def.full_name, generic_type_usages),
                param_type: None(),
            ]
        ]

        let header3 = NFunctionHeader::new_full(span, "", "internal_free", NTypeUsage::simple(span, "Nothing"), parameters3, generic_params)
        let func3 = program.create_function(header3, annotations)
        func3.register_params()

        for field in def.fields {
            if !field.field_type!!.has_gc() {
                continue
            }


            // `this.field.ref_dec()`
            let load_this3 = func3.code.add_load_var(span, "", "this", None())
            let load_field3 = func3.code.add_load_field(span, load_this3.id, field.name)
            func3.code.add_ref_dec(span, load_field3.id, load_field3.id, true, func3.code.current_block)
        }

        let load_this3 = func3.code.add_load_var(span, "", "this", None())
        let this_ptr = func3.code.add_fun_call(span, "", "ptr_of", false, [load_this3.id], [])
        let this_address = func3.code.add_fun_call(span, "", "get_address", false, [this_ptr.id], [])
        func3.code.add_fun_call(span, "", "memory_free_internal", false, [this_address.id], [])

        let nothing_lit2 = func3.code.add_lit_nothing(span)
        func3.code.add_return(span, nothing_lit2.id)

        program.functions[] = func3
    }
}

struct TypeCheckerStackFrame {
    block_id: NBlockId,
    inst_list: List<NInstId>
}

fun TypeChecker.generate_rc_instructions() {
    for def in program.functions {

        // Ignore functions with @NoGC annotation
        if def.has_annotation(ANNOTATION_NO_GC) {
            continue
        }

        let code = def.code

        if code.inst_list.is_empty() {
            continue
        }

        let i = 0
        let stack: List<TypeCheckerStackFrame> = []

        // Root level
        stack[] = TypeCheckerStackFrame @[block_id: code.current_block, inst_list: []]

        loop {
            // Detect vars out of scope
            let next_depth = if code.inst_list.len > i {
                let inst_block_id = code.inst_list[i]!!.block
                let block = code.find_block(inst_block_id)
                block.depth + 1
            } else {
                0
            }

            // Pop frames that are no longer in scope
            while next_depth < stack.len {
                let last_frame: TypeCheckerStackFrame = stack.remove_last()!!
                let target = if i < code.inst_list.len { code.inst_list[i]!!.id } else { code.inst_list.last()!!.id }
                let after = i >= code.inst_list.len

                for id in last_frame.inst_list {
                    i += pop_inst_rc(id, code, def.span, target, after, last_frame.block_id)
                }
            }

            if i >= code.inst_list.len {
                break
            }

            let inst = code.inst_list[i]!!

            // Update scope stack
            while next_depth > stack.len {
                stack[] = TypeCheckerStackFrame @[block_id: inst.block, inst_list: []]
            }

            // Detect value to check for out of scope
            let stack_frame: TypeCheckerStackFrame = stack.last()!!
            when {
                inst.type_token.is_none() -> {}
                inst.kind is NInstKind::Let -> {
                    let variable_id = (inst.kind as NInstKind::Let).variable
                    let variable = code.vars_map[variable_id]!!
                    let inst_type = variable.type_token!!.find_type()
                    if inst_type.has_gc() {
                        stack_frame.inst_list[] = inst.id
                    }
                }
                inst.kind is NInstKind::FunCall || inst.kind is NInstKind::Alloc || inst.kind is NInstKind::Lambda -> {
                    let inst_type = inst.type_token!!.find_type()
                    if inst_type.has_gc() {
                        stack_frame.inst_list[] = inst.id
                    }
                }
                inst.kind is NInstKind::Return -> {
                    let kind = inst.kind as NInstKind::Return
                    let inst_type = code.find_inst(kind.value).type_token!!.find_type()

                    // Inc return value
                    if inst_type.has_gc() {
                        code.add_ref_inc(def.span, kind.value, inst.id, false, inst.block)
                        i += 1
                    }

                    // Dec everything else
                    while stack.is_not_empty() {
                        let last_frame: TypeCheckerStackFrame = stack.remove_last()!!
                        let target = if i < code.inst_list.len { code.inst_list[i]!!.id } else { code.inst_list.last()!!.id }
                        let after = i >= code.inst_list.len

                        for id in last_frame.inst_list {
                            i += pop_inst_rc(id, code, def.span, target, after, last_frame.block_id)
                        }
                    }
                }
            }

            // Detect value aliasing
            i += generate_rc_instructions_for_inst(def, code, inst)
            i += 1
        }
    }
}

fun TypeChecker.pop_inst_rc(id: NInstId, code: NCode, span: Span, target: NInstId, after: Boolean, block_id: NBlockId): Int {
    let inst: NInst = code.find_inst(id)
    let last_id = code.inst_list.last()!!.id

    if inst.kind is NInstKind::Let {
        let var_id = (inst.kind as NInstKind::Let).variable
        let variable = code.vars_map[var_id]!!

        let var_type = variable.type_token!!.find_type()
        if var_type.has_gc() {
            ret code.add_var_ref_dec(span, variable, target, after, block_id)
        }
    } else {
        let inst_type = inst.type_token!!.find_type()
        if inst_type.has_gc() {
            code.add_ref_dec(span, id, target, after, block_id)
            ret 1
        }
    }
    ret 0
}

fun TypeChecker.generate_rc_instructions_for_inst(def: NFunction, code: NCode, inst: NInst): Int {
    when {
        // Add ref_inc for variable assignment
        inst.kind is NInstKind::StoreVar -> {
            let kind = inst.kind as NInstKind::StoreVar
            let i = 0

            if kind.variable.is_some() {
                let var_id = kind.variable!!
                let variable = code.vars_map[var_id]!!

                if variable.type_token!!.find_type().has_gc() {
                    i += code.add_var_ref_dec(def.span, variable, inst.id, false, inst.block)
                }

                if variable.init_at.is_none() {
                    variable.init_at = Some(inst.id)
                }
            }

            let prev = code.find_inst(kind.value)
            if prev.type_token!!.find_type().has_gc() {
                code.add_ref_inc(def.span, kind.value, inst.id, true, inst.block)
                i += 1
            }

            ret i
        }

        // Add ref_inc for field assignment
        inst.kind is NInstKind::StoreField -> {
            let kind = inst.kind as NInstKind::StoreField

            if kind.field_type_token.is_none(){
                ret 0
            }

            if !kind.field_type_token!!.find_type().has_gc() {
                ret 0
            }

            let i = 0
            let load = code.add_inst_before(inst.id, def.span, NInstKind::LoadField @[
                instance: kind.instance,
                name: kind.name,
                field: kind.field,
                field_type_token: kind.field_type_token,
                call_site_generics: kind.call_site_generics,
            ])
            code.add_ref_dec(def.span, load.id, load.id, true, inst.block)

            code.add_ref_inc(def.span, kind.value, inst.id, true, inst.block)
            ret 3
        }

        // Add RcHeader after struct alloc
        inst.kind is NInstKind::Alloc -> {
            let kind = inst.kind as NInstKind::Alloc

            if kind.is_enum || kind.type_token.is_none() {
                ret 0
            }

            let inst_type = kind.type_token!!.find_type()

            if !inst_type.has_gc() {
                ret 0
            }

            // Add initialization of rc header
            let header = code.add_inst_after(inst.id, def.span, NInstKind::FunCall @[
                path: "RcHeader",
                name: "new",
                explicit_receiver: true,
                arguments: [],
                explicit_type_arguments: [],
                call_site: None(),
            ])

            // Store rc header in struct
            code.add_inst_after(header.id, def.span, NInstKind::StoreField @[
                instance: inst.id,
                name: FIELD_RC_HEADER,
                field: None(),
                field_type_token: None(),
                call_site_generics: None(),
                value: header.id,
            ])

            ret 2
        }

        inst.kind is NInstKind::FunCall -> {
            // ref_inc() is inserted inside the function and not at the call site
            ret 0
        }
        inst.kind is NInstKind::Let -> {
            let kind = inst.kind as NInstKind::Let
            let variable = code.vars_map[kind.variable]!!

            if !variable.is_parameter {
                ret 0
            }

            let ty = variable.type_token!!.find_type()

            if ty.has_gc() {
                let load = code.add_inst_after(inst.id, def.span, NInstKind::LoadVar @[
                    path: "",
                    name: variable.name,
                    variable: Some(variable.id),
                    constant: None(),
                ])
                code.add_ref_inc(def.span, load.id, load.id, true, inst.block)
                ret 2
            }

            ret 0
        }

        // TODO return
        // TODO continue/break
    }
    ret 0
}

fun NCode.add_ref_inc(span: Span, value: NInstId, inst_id: Id, after: Boolean, block_id: NBlockId): NInst {
    let code = this
    let kind = NInstKind::FunCall @[
        path: "",
        name: "ref_inc",
        explicit_receiver: true,
        arguments: [value],
        explicit_type_arguments: [],
        call_site: None(),
    ]
    ret if after {
        code.add_inst_after(inst_id, span, kind)
    } else {
        code.add_inst_before(inst_id, span, kind)
    }
}

fun NCode.add_ref_dec(span: Span, value: NInstId, inst_id: Id, after: Boolean, block_id: NBlockId): NInst {
    let code = this
    let kind = NInstKind::FunCall @[
        path: "",
        name: "ref_dec",
        explicit_receiver: true,
        arguments: [value],
        explicit_type_arguments: [],
        call_site: None(),
    ]

    let fun_call = if after {
        code.add_inst_after(inst_id, span, kind)
    } else {
        code.add_inst_before(inst_id, span, kind)
    }
    fun_call.block = block_id
    ret fun_call
}

fun NCode.add_var_ref_dec(span: Span, variable: NVar, inst_id: Id, after: Boolean, block_id: NBlockId): Int {
    let code = this

    if variable.init_at.is_none() && !variable.is_parameter {
        ret 0
    }

    let kind = NInstKind::LoadVar @[
       path: "",
       name: variable.name,
       variable: Some(variable.id),
       constant: None(),
   ]

    let variable_load2 = if after {
        code.add_inst_after(inst_id, span, kind)
    } else {
        code.add_inst_before(inst_id, span, kind)
    }
    variable_load2.block = block_id

    let fun_call = code.add_inst_after(variable_load2.id, span, NInstKind::FunCall @[
        path: "",
        name: "ref_dec",
        explicit_receiver: true,
        arguments: [variable_load2.id],
        explicit_type_arguments: [],
        call_site: None(),
    ])
    fun_call.block = block_id

    ret 2
}

fun Type.has_gc(): Boolean {
    // DEBUG
    if kind is TypeKind::Struct {
        ret (kind as TypeKind::Struct).instance.get_annotation(ANNOTATION_TMP_RC).is_some()
    }
    ret false

    when {
        kind is TypeKind::Struct -> {
            let instance = (kind as TypeKind::Struct).instance
            if !instance.is_enum && instance.get_annotation(ANNOTATION_NO_GC).is_none() { ret true }
        }
        kind is TypeKind::Option -> {
            let instance = (kind as TypeKind::Option).instance
            if instance.get_annotation(ANNOTATION_NO_GC).is_none() { ret true }
        }
        kind is TypeKind::OptionItem -> {
            let instance = (kind as TypeKind::OptionItem).instance
            if !instance.is_enum && instance.get_annotation(ANNOTATION_NO_GC).is_none() { ret true }
        }
    }
    ret false
}

@CompilationFlag [name: "enable-rc-gc", description: "Enable reference counting garbage collector"]
let ENABLE_RC_GC: Boolean = false
let FIELD_RC_HEADER: String = "internal_rc_header"

fun TypeChecker.generate_struct_rc_functions() {
    // Generate constructors/destructors for all structs
    let pending_constructors = []
    let pending_destructors = []

    for def in program.structs {
        let create_init = program.functions.find @{ f -> f.is_constructor_for(def.name) }.is_none()
        let create_deinit = program.functions.find @{ f -> f.is_destructor_for(def.name) }.is_none()

        if create_init {
            pending_constructors[] = def
        }
        if create_deinit {
            pending_destructors[] = def
        }
    }

    for def in pending_constructors {
        let span = def.span
        let annotations = NAnnotationContainer::new([
            NAnnotation @[span, name: ANNOTATION_AUTOGENERATED, args: []].with_arg("name", "<internal>"),
            NAnnotation @[span, name: ANNOTATION_DEFAULT_IMPL, args: []],
        ])

        let init_func = program.create_function(NFunctionHeader::new(span, "", "init", NTypeUsage::simple(span, "Nothing")), annotations)
        let generics = []

        for gen in def.generics.definitions {
            init_func.header.generics[] = NGeneric @[
                id: program.id_provider.next(),
                index: gen.index,
                span: def.span,
                name: gen.name,
                source: NGenericSource::Function,
                bounds: gen.bounds,
            ]
            generics[] = NTypeUsage::generic(span, gen.name, Some(gen.index))
        }

        let init_receiver_type_usage = NTypeUsage::simple_with_params(span, def.full_name, generics)
        init_func.add_parameter(span, "this", init_receiver_type_usage)
        init_func.register_params()
        program.functions[] = init_func
    }

    for def in pending_destructors {
        let span = def.span
        let annotations = NAnnotationContainer::new([
            NAnnotation @[span, name: ANNOTATION_AUTOGENERATED, args: []].with_arg("name", "<internal>"),
            NAnnotation @[span, name: ANNOTATION_DEFAULT_IMPL, args: []],
        ])
        let deinit_func = program.create_function(NFunctionHeader::new(span, "", "deinit", NTypeUsage::simple(span, "Nothing")), annotations)
        let generics = []

        for gen in def.generics.definitions {
            deinit_func.header.generics[] = NGeneric @[
                id: program.id_provider.next(),
                index: gen.index,
                span: def.span,
                name: gen.name,
                source: NGenericSource::Function,
                bounds: gen.bounds,
            ]
            generics[] = NTypeUsage::generic(span, gen.name, Some(gen.index))
        }

        let deinit_receiver_type_usage = NTypeUsage::simple_with_params(span, def.full_name, generics)
        deinit_func.add_parameter(span, "this", deinit_receiver_type_usage)
        deinit_func.register_params()
        program.functions[] = deinit_func
    }

    // Generate implementation of tag RC
    for def in program.structs {
        if def.annotations[ANNOTATION_TMP_RC].is_none() {
            continue
        }
//        if !def.is_enum && def.annotations[ANNOTATION_NO_GC].is_none() {
//            continue
//        }

        let span = def.span
        let generic_type_usages = []
        let annotations = NAnnotationContainer::new([
            NAnnotation @[span, name: ANNOTATION_NO_GC, args: []],
            NAnnotation @[span, name: ANNOTATION_AUTOGENERATED, args: []].with_arg("name", "<internal>")
        ])

        let generic_params = NGenericParams::new(NGenericSource::Function)

        for gen in def.generics.definitions {
            let this_generic = NGeneric @[
               id: program.id_provider.next(),
               index: gen.index,
               span,
               name: gen.name,
               source: NGenericSource::Function,
               bounds: gen.bounds,
            ]
            generic_params[] = this_generic
            generic_type_usages[] = NTypeUsage::generic(span, this_generic.name, Some(gen.index))
        }

        // fun This.get_rc_header_ptr(): Ptr<Rc::RcHeader>
        let struct_tu = NTypeUsage::simple_with_params(span, def.full_name, generic_type_usages);
        let parameters = [
            NFunctionParameter @[
                span,
                name: "this",
                type_usage: struct_tu,
                param_type: None(),
            ]
        ]
        let fun_return_tu = NTypeUsage::simple_with_params(span, "Ptr", [NTypeUsage::simple_with_path(span, "Rc", "RcHeader")])
        let header = NFunctionHeader::new_full(span, "", "get_rc_header_ptr", fun_return_tu, parameters, generic_params)
        let func = program.create_function(header, annotations)
        func.register_params()

        // `ret ptr_of(this).offset_in_bytes(<offset of RcHeader>).unsafe_cast()`
        let load_this = func.code.add_load_var(span, "", "this", None())
        let ptr_of = func.code.add_fun_call(span, "", "ptr_of", false, [load_this.id], [])
        let offset = func.code.add_offset_of(span, struct_tu, FIELD_RC_HEADER)
        let offset_in_bytes = func.code.add_fun_call(span, "", "offset_in_bytes", true, [ptr_of.id, offset.id], [])
        let cast = func.code.add_fun_call(span, "", "unsafe_cast", true, [offset_in_bytes.id], [])
        func.code.add_return(span, cast.id)

        program.functions[] = func
    }
}

struct TypeCheckerStackFrame {
    block_depth: Int,
    inst_list: List<NInstId>
}

fun TypeChecker.generate_rc_instructions() {
    let i = 0
    while i < program.codes.len {
        let code = program.codes[i]!!
        i += 1

        if code.container.annotations[ANNOTATION_NO_GC].is_some() {
            continue
        }

        generate_code_rc_instructions(code)
        code.add_deferred_code()
    }
}

fun TypeChecker.generate_code_rc_instructions(code: NCode) {
    // Rules:
    // 1. Variable declaration with GC type:
    //let var = value
    //var.ref_inc()
    //defer { var.ref_dec() }

    // 2. Variable assignment (var already exists):
    //var.ref_dec()       // Release current reference (only if previously initialized)
    //var = new_value
    //new_value.ref_inc() // Acquire new reference

    // 3. Function parameters:
    //func foo(param: GcType) {
    //    defer { param.ref_dec() }  // Caller did ref_inc()
    //}

    // 4. Function calls:
    //arg.ref_inc()  // Before call
    //foo(arg)

    // 5. Return values:
    //value.ref_inc()
    //return value

    // 6. Field assignment:
    //obj.field.ref_dec()
    //obj.field = value
    //obj.field.ref_inc()

    // 7. New instances (not assigned to variable):
    // let temp = new Type()
    // Rc::RcHeader::init(temp)

    // Track which variables have been initialized to avoid ref_dec() on uninitialized vars
    let initialized_vars = Set::new<NVarId>()

    let i = 0
    while i < code.inst_list.len {
        let inst = code.inst_list[i]!!

        if inst.gc_related {
            i += 1
            continue
        }

        if inst.kind is NInstKind::Let {
            let kind = inst.kind as NInstKind::Let
            let nvar = code.find_var(kind.variable)

            if nvar.type_token!!.has_gc() {
                // Rule 1: Variable declaration with GC type
                //let var = value
                //defer { var.ref_dec() }
                let sub = code.new_child_code(code.container, true)
                let load_var = sub.add_load_var(inst.span, "", nvar.name, Some(nvar.id))
                load_var.gc_related = true
                sub.add_ref_dec(inst.span, load_var.id)

                code.seek_to_pos(i + 1)
                let def = code.add_defer(inst.span, sub)
                def.gc_related = true

                // Mark parameter variables as initialized (they get values from caller)
                if nvar.is_parameter {
                    initialized_vars.add(kind.variable)
                }
            }

            // 3. Function parameters:
            //func foo(param: GcType) {
            //    defer { param.ref_dec() }  // Caller did ref_inc()
            //}
            // Function parameters are handled using NInstKind::Let without an assignment
        }

        if inst.kind is NInstKind::FunCall {
            let kind = inst.kind as NInstKind::FunCall
            let callsite = kind.call_site!!

            // Skip special functions that do not allow GC handling
            if callsite.target.has_annotation(ANNOTATION_NO_GC) {
                i += 1
                continue
            }

            let arg_types = callsite.argument_types

            let j = 0

            while j < kind.arguments.len {
                let arg_id = kind.arguments[j]!!
                let arg_type = arg_types[j]!!
                j += 1

                if arg_type.has_gc() {
                    // 4. Function calls:
                    //arg.ref_inc()  // Before call
                    //foo(arg)
                    code.seek_after_inst(arg_id)
                    code.add_ref_inc(inst.span, arg_id)
                }
            }
        }

        if inst.kind is NInstKind::Return {
            let kind = inst.kind as NInstKind::Return
            let value_inst = code.find_inst(kind.value)

            if value_inst.type_token!!.has_gc() {
                // Rule 5: Return values
                //value.ref_inc()
                //return value
                code.seek_to_pos(i)
                code.add_ref_inc(inst.span, value_inst.id)
            }
        }

        if inst.kind is NInstKind::StoreVar {
            let kind = inst.kind as NInstKind::StoreVar
            // Constants
            if kind.variable.is_none() {
                continue
            }
            let nvar = code.find_var(kind.variable!!)

            if nvar.type_token!!.has_gc() {
                // Rule 2: Variable assignment (var already exists)
                //var.ref_dec()       // Release current reference (only if previously initialized)
                //var = new_value
                //var.ref_inc() // Acquire new reference (only if not freshly allocated)

                // Only add ref_dec() if the variable was previously initialized
                if initialized_vars.contains(kind.variable!!) {
                    code.seek_to_pos(i - 1)
                    let prev = code.add_load_var(inst.span, "", nvar.name, Some(nvar.id))
                    prev.gc_related = true
                    code.add_ref_dec(inst.span, prev.id)
                }

                // Check if the value being stored comes from a fresh allocation
                let value_inst = code.find_inst(kind.value)
                let is_fresh_allocation = value_inst.kind is NInstKind::Link
                
                // Only add ref_inc() if this is NOT a fresh allocation
                // Fresh allocations already have ref count 1 from RcHeader::init
                if !is_fresh_allocation {
                    code.seek_after_inst(inst.id)
                    let load_value = code.add_load_var(inst.span, "", nvar.name, Some(nvar.id))
                    load_value.gc_related = true
                    code.add_ref_inc(inst.span, load_value.id)
                }

                // Mark variable as initialized after first assignment
                initialized_vars.add(kind.variable!!)
            }
        }

        if inst.kind is NInstKind::Alloc {
            let kind = inst.kind as NInstKind::Alloc
            let ntype = kind.type_token!!.find_type()

            if ntype.has_gc() {
                // Rule 7: New instances (not assigned to variable)
                // Rc::RcHeader::init(temp)
                code.seek_to_pos(i + 1)
                let call = code.add_fun_call(inst.span, "Rc::RcHeader", "init", false, [inst.id], [])
                call.gc_related = true
                
                // Check if this allocation is used in an assignment in the next few instructions
                let is_used_in_assignment = false
                let j = i + 2  // Start after the init call
                let search_limit = (i + 10).min(code.inst_list.len)  // Look ahead a few instructions
                
                while j < search_limit {
                    let next_inst = code.inst_list[j]!!
                    if next_inst.kind is NInstKind::StoreVar {
                        let store_kind = next_inst.kind as NInstKind::StoreVar
                        if store_kind.value == inst.id {
                            is_used_in_assignment = true
                            break
                        }
                    }
                    j += 1
                }
                
                // If not used in assignment, it's a temporary - add immediate cleanup
                if !is_used_in_assignment {
                    code.seek_to_pos(j)  // Position after the allocation usage
                    let ref_dec_call = code.add_fun_call(inst.span, "Rc", "ref_dec", true, [inst.id], [])
                    ref_dec_call.gc_related = true
                }
            }
        }

        i = code.index_of_inst(inst.id)!! + 1
    }

    code.seek_end()
}

fun NCode.add_ref_inc(span: Span, value: NInstId): NInst {
    let kind = NInstKind::FunCall @[
        path: "Rc",
        name: "ref_inc",
        explicit_receiver: true,
        arguments: [value],
        explicit_type_arguments: [],
        use_paths: [],
        call_site: None(),
    ]
    let inst = add_inst(span, kind)
    inst.gc_related = true
    ret inst
}

fun NCode.add_ref_dec(span: Span, value: NInstId): NInst {
    let kind = NInstKind::FunCall @[
        path: "Rc",
        name: "ref_dec",
        explicit_receiver: true,
        arguments: [value],
        explicit_type_arguments: [],
        use_paths: [],
        call_site: None(),
    ]
    let inst = add_inst(span, kind)
    inst.gc_related = true
    ret inst
}

fun TypeToken.has_gc(): Boolean = find_type().has_gc()

fun Type.has_gc(): Boolean {
    // DEBUG
    if kind is TypeKind::Struct {
        ret (kind as TypeKind::Struct).instance.annotations[ANNOTATION_TMP_RC].is_some()
    }
    ret false

    when {
        kind is TypeKind::Struct -> {
            let instance = (kind as TypeKind::Struct).instance
            if !instance.is_enum && instance.annotations[ANNOTATION_NO_GC].is_none() { ret true }
        }
        kind is TypeKind::Option -> {
            let instance = (kind as TypeKind::Option).instance
            if instance.annotations[ANNOTATION_NO_GC].is_none() { ret true }
        }
        kind is TypeKind::OptionItem -> {
            let instance = (kind as TypeKind::OptionItem).instance
            if !instance.is_enum && instance.annotations[ANNOTATION_NO_GC].is_none() { ret true }
        }
    }
    ret false
}

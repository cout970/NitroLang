
fun TypeContainer.common_type(left: TypeToken, right: TypeToken): Optional<TypeToken> {
    if left == right {
        ret Some(left)
    }

    // Invalid
    if is_invalid(left) {
        ret Some(right)
    }
    if is_invalid(right) {
        ret Some(left)
    }

    // Never
    if is_never(left) {
        ret Some(right)
    }
    if is_never(right) {
        ret Some(left)
    }

    // Union
    if is_union(left) && is_union(right) {
        let left_ty = left.find_type()
        let right_ty = right.find_type()
        let set = %[]

        set.add_all(left_ty.params)
        set.add_all(right_ty.params)

        ret common_type_of_list(set.to_list())
    }
    if is_union(left) {
        let left_ty = left.find_type()
        let set = %[]

        set.add_all(left_ty.params)
        set.add(right.type_id)

        ret common_type_of_list(set.to_list())
    }
    if is_union(right) {
        let right_ty = right.find_type()
        let set = %[]

        set.add_all(right_ty.params)
        set.add(left.type_id)

        ret common_type_of_list(set.to_list())
    }

    // Composite
    if is_composite(left) && is_composite(right) {
        let left_ty = left.find_type()
        let right_ty = right.find_type()

        if left_ty.params.len != right_ty.params.len {
            ret None()
        }

        let opt = common_kind_type(left_ty.kind, right_ty.kind)

        if opt.is_none() {
            ret None()
        }

        let params = []

        repeat left_ty.params.len {
            let aux = common_type(
                create_type_token(left_ty.params[it]!!),
                create_type_token(right_ty.params[it]!!)
            )

            if aux.is_none() {
                ret None()
            }
            params[] = aux!!
        }

        ret Some(create_type(opt!!, params))
    }

    ret None()
}

fun TypeContainer.common_type_of_list(list: List<TypeId>): Optional<TypeToken> {
    ret when list.len {
        0 -> None()
        1 -> Some(create_type_token(list.first()!!))
        2 -> common_type(create_type_token(list[0]!!), create_type_token(list[1]!!))
        else -> {
            let curr: TypeToken = create_type_token(list.first()!!)

            for other in list.rest() {
                let aux = common_type(curr, create_type_token(other))

                if aux.is_none() {
                    ret None()
                }
                curr = aux!!
            }

            ret Some(curr)
        }
    }
}

fun TypeContainer.common_kind_type(left: TypeKind, right: TypeKind): Optional<TypeKind> {
    if left == right {
        ret Some(left)
    }

    if left is TypeKind::Struct && (left as TypeKind::Struct).instance.full_name == "Never" {
        ret Some(right)
    }
    if right is TypeKind::Struct && (right as TypeKind::Struct).instance.full_name == "Never" {
        ret Some(left)
    }

    // Ordering and Ordering::Equals => Ordering
    if left is TypeKind::Option && right is TypeKind::OptionItem {
        let left_option: NOption = (left as TypeKind::Option).instance
        let right_struct = (right as TypeKind::OptionItem).instance

        for item in left_option.items {
            if item.def == right_struct {
                ret Some(left)
            }
        }

        ret None()
    }

    // Ordering::Equals and Ordering => Ordering
    if left is TypeKind::OptionItem && right is TypeKind::Option {
        let left_struct = (left as TypeKind::OptionItem).instance
        let right_option: NOption = (right as TypeKind::Option).instance

        for item in right_option.items {
            if item.def == left_struct {
                ret Some(right)
            }
        }

        ret None()
    }

    // Ordering::Less and Ordering::Equals => Ordering
    if left is TypeKind::OptionItem && right is TypeKind::OptionItem {
        let left_struct = (left as TypeKind::OptionItem).instance
        let right_struct = (right as TypeKind::OptionItem).instance

        if left_struct == right_struct {
            ret Some(left)
        }

        ret None()
    }

    // Function and Lambda => Function
    if left is TypeKind::Struct && (left as TypeKind::Struct).instance.full_name == "Function" && right is TypeKind::Lambda {
        ret Some(left)
    }
    if right is TypeKind::Struct && (right as TypeKind::Struct).instance.full_name == "Function" && left is TypeKind::Lambda {
        ret Some(right)
    }

    ret None()
}

fun TypeContainer.contains_generic(tt: TypeToken): Boolean {
    let ty = tt.find_type()

    if ty.kind is TypeKind::Generic {
        ret true
    }

    for param in ty.params {
        if contains_generic(create_type_token(param)) {
            ret true
        }
    }

    ret false
}

fun TypeContainer.contains_param(curr: TypeToken, find: TypeToken): Boolean {
    let ty = curr.find_type()

    for param in ty.params {
        if param == find.type_id {
            ret true
        }

        if contains_param(create_type_token(param), find) {
            ret true
        }
    }

    ret false
}

fun TypeContainer.has_unresolved(tt: TypeToken): Boolean {
    let ty = tt.find_type()

    if ty.kind is TypeKind::Unresolved || ty.kind is TypeKind::UnresolvedFunction {
        ret true
    }

    for p in ty.params {
        if has_unresolved(create_type_token(p)) {
            ret true
        }
    }
    ret false
}


fun TypeContainer.is_unresolved(tt: TypeToken): Boolean {
    ret tt.find_type().kind is TypeKind::Unresolved
}

fun TypeContainer.is_unresolved_function(tt: TypeToken): Boolean {
    ret tt.find_type().kind is TypeKind::UnresolvedFunction
}

fun TypeContainer.is_generic(tt: TypeToken): Boolean {
    ret tt.find_type().kind is TypeKind::Generic
}

fun TypeContainer.is_union(tt: TypeToken): Boolean {
    ret tt.find_type().kind is TypeKind::Union
}

fun TypeContainer.is_invalid(tt: TypeToken): Boolean {
    ret tt.find_type().kind is TypeKind::Invalid
}

fun TypeContainer.is_composite(tt: TypeToken): Boolean {
    let kind = tt.find_type().kind
    ret kind is TypeKind::Struct || kind is TypeKind::Option || kind is TypeKind::OptionItem
}

fun TypeContainer.is_lambda(tt: TypeToken): Boolean {
    let kind = tt.find_type().kind
    ret kind is TypeKind::Lambda
}

fun TypeContainer.is_named(tt: TypeToken, name: String): Boolean {
    let ty = tt.find_type()

    if ty.kind is TypeKind::Struct {
        ret (ty.kind as TypeKind::Struct).instance.full_name == name
    }

    if ty.kind is TypeKind::Option {
        ret (ty.kind as TypeKind::Option).instance.full_name == name
    }

    if ty.kind is TypeKind::OptionItem {
        ret (ty.kind as TypeKind::OptionItem).instance.full_name == name
    }

    ret false
}

fun TypeContainer.is_boolean(tt: TypeToken): Boolean = this.is_named(tt, "Boolean")
fun TypeContainer.is_byte(tt: TypeToken): Boolean = this.is_named(tt, "Byte")
fun TypeContainer.is_char(tt: TypeToken): Boolean = this.is_named(tt, "Char")
fun TypeContainer.is_float(tt: TypeToken): Boolean = this.is_named(tt, "Float")
fun TypeContainer.is_function(tt: TypeToken): Boolean = this.is_named(tt, "Function")
fun TypeContainer.is_int(tt: TypeToken): Boolean = this.is_named(tt, "Int")
fun TypeContainer.is_long(tt: TypeToken): Boolean = this.is_named(tt, "Long")
fun TypeContainer.is_never(tt: TypeToken): Boolean = this.is_named(tt, "Never")
fun TypeContainer.is_nothing(tt: TypeToken): Boolean = this.is_named(tt, "Nothing")
fun TypeContainer.is_string(tt: TypeToken): Boolean = this.is_named(tt, "String")
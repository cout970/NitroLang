let source_code: String = r#"

struct String {
    byte_len: Int
    ptr: RawArray<Byte>
}

@ValueType
option Optional<#Value> {
    None
    Some { value: #Value }
}

include "./main.nitro"

type_alias Int32 = Int

let PI: Float = 3

mod Test {

}

@Test
fun add(a: Int, b: Int): Int = 0

fun <#A, #B> add2(a: #A, b: #B): #A = 0

fun a() {
    defer 1
    defer {
        2
    }
    let i: Int = 0

    if 1 { 1 } else { 0 }

    repeat 10 {
        2
    }

    while 1 {
        2
    }

    loop {
        3
    }

    for i in 4 {
        5
    }

    ```js
    const sum = (a, b) => a + b;
    console.log(sum(1, 2));
    ```

    let j = 12

    when {
        1 -> 2
        3 -> 4
        else -> 5
    }

    when 1 {
        1 -> 1
        else -> 0
    }
}

test! "Do something" {
    1
}

enum Direction {
   Up      @[name: "up"]
   Down    @[name: "down"]
   Left    @[name: "left"]
   Right   @[name: "right"]
   Front   @[name: "front"]
   Back    @[name: "back"]

   let name: String
}

fun a(): Int = if 0 { 1 } else { 2 }
fun b(): Int = ret
fun c(): Int = ret 0
fun d(): Boolean = false || true && true
fun f(): Boolean = 0 is Int
fun g(): Int = 0 as Int
fun h(variable: List<Int>): Boolean = 0 !in variable
fun i() { loop { break } }
fun j() { loop { continue } }

"#

let tokenizer_test2: String = r#"
// INT_NUMBER
12345
0
0x123456789abcdf
0x123456789ABCDF
0o1234567
0b1010101010101010101010101010101010101010101010101010101010101010
+1
-1
// LONG_NUMBER
123L
0L
1l
-1L
+42l
// FLOAT_NUMBER
1.0
.025
1f
0f
-1f
1.0f
1.0F
1.0e10
1.0e-10
+1.0e+10d
-1.0e-10D
"#

let tokenizer_test: String = r#"
..=
..<
@{
%[
#[
@[
::
->
||
or
&&
and
^^
xor
<=>
==
!=
<=
>=
!!
+=
-=
*=
/=
%=
?
_
.
(
)
{
[
]
,
:
+
-
*
/
^
$
%
@
#
|
&
not
!
=
<
>
this
This
fun
let
mod
struct
ret
return
size_of
sizeOf
sizeof
option
internal
rec
tag
defer
type_alias
typeAlias
typealias
enum
nothing
when
match
alias
if
else
for
in
while
repeat
loop
is
as
true
false
null
include
break
continue
use
mut
json!
test!
"#

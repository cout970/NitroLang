
struct NFunction {
    id: Id
    span: Span
    annotations: List<NAnnotation>
    header: NFunctionHeader
    code: NCode
    full_name: String
}

struct NFunctionParameter {
    span: Span
    name: String
    type_usage: NTypeUsage
    param_type: Optional<Type>
}

fun Parser.create_function(header: NFunctionHeader, annotations: List<NAnnotation>): NFunction {
    let full_name = Path::join(header.path, header.name)
    let func = NFunction @[
        id: id_provider.next(),
        span: header.span,
        annotations,
        header,
        code: NCode::new(header.span, full_name),
        full_name,
    ]

    func.code.generics = header.generics
    ret func
}

fun Parser.register_nitro_function(func: NFunction) {
    program.functions[] = func
}

fun NFunction.add_parameter(span: Span, name: String, type_usage: NTypeUsage) {
    header.parameters[] = NFunctionParameter @[span, name, type_usage, param_type: None()]
    header.update_key()
}

fun NFunction.register_params() {
    // Create a local variable per function parameter
    for param in header.parameters {
        let variable = code.add_let(param.span, param.name, Some(param.type_usage))
        variable.is_parameter = true
    }
}


fun NFunction.get_param_types(): List<Type> = header.param_types

fun NFunction.is_auto_generated(): Boolean {
    ret has_annotation("AutoGenerated")
}

fun NFunction.get_annotation(name: String): Optional<NAnnotation> {
    for a in annotations {
        if a.name == name {
            ret Some(a)
        }
    }
    ret None()
}

fun NFunction.has_annotation(name: String): Boolean {
    ret get_annotation(name).is_some()
}

fun NFunction.to_string(): String {
    let prefix = if annotations.is_empty() { "" } else { annotations.join("\n") + "\n" }

    let args = ""
    for p in header.parameters {
        if !args.is_empty() {
            args += ", "
        }
        args += "${p.name}: ${p.type_usage}"
    }

    return "${prefix}fun $full_name($args): ${header.return_type_usage} $code // $span"
}

struct ExternAnnotation {
    lib: String
    name: String
    autogenerate: Boolean
}

fun NFunction.get_extern_annotation(): Optional<ExternAnnotation> {
    let extern_annotation = get_annotation("Extern")
    if extern_annotation.is_none() {
        ret None()
    }

    let a: NAnnotation = extern_annotation!!
    let lib: Optional<NConstExpr> = a.get_arg("lib")
    let name: Optional<NConstExpr> = a.get_arg("name")

    if lib.is_none() || name.is_none() {
        ret None()
    }

    let lib_str: Optional<String> = lib!!.get_string()
    let name_str: Optional<String> = name!!.get_string()

    if lib_str.is_none() || name_str.is_none() {
        ret None()
    }

    let autogenerate: Boolean = false
    let autogenerate_arg: Optional<NConstExpr> = a.get_arg("autogenerate")

    if autogenerate_arg.is_some() && autogenerate_arg!!.get_boolean().is_some() {
        autogenerate = autogenerate_arg!!.get_boolean()!!
    }

    ret Some(ExternAnnotation @[
        lib: lib_str!!,
        name: name_str!!,
        autogenerate,
    ])
}
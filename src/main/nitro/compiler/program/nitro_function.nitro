
struct NFunction {
    id: Id
    span: Span
    annotations: List<NAnnotation>
    header: NFunctionHeader
    code: NCode
    full_name: String
}

struct NFunctionParameter {
    span: Span
    name: String
    type_usage: NTypeUsage
    param_type: Optional<Type>
}

fun Parser.create_function(header: NFunctionHeader, annotations: List<NAnnotation>): NFunction {
    let full_name = Path::join(header.path, header.name)
    let func = NFunction @[
        id: id_provider.next(),
        span: header.span,
        annotations,
        header,
        code: NCode::new(header.span, full_name),
        full_name,
    ]

    func.code.link_generics(header.generics)
    ret func
}

fun Parser.register_nitro_function(func: NFunction) {
    program.functions[] = func
}

fun NFunction.add_parameter(span: Span, name: String, type_usage: NTypeUsage) {
    header.parameters[] = NFunctionParameter @[span, name, type_usage, param_type: None()]
    header.update_key()
}

fun NFunction.register_params() {
    // Create a local variable per function parameter
    for param in header.parameters {
        let variable = code.add_let(param.span, param.name, Some(param.type_usage))
        variable.is_parameter = true
    }
}


fun NFunction.get_param_types(): List<Type> = header.param_types

fun NFunction.is_auto_generated(): Boolean {
    ret has_annotation("AutoGenerated")
}

fun NFunction.get_annotation(name: String): Optional<NAnnotation> {
    for a in annotations {
        if a.name == name {
            ret Some(a)
        }
    }
    ret None()
}

fun NFunction.has_annotation(name: String): Boolean {
    ret get_annotation(name).is_some()
}

fun NFunction.to_string(): String {
    let prefix = if annotations.is_empty() { "" } else { annotations.join("\n") + "\n" }

    let args = ""
    for p in header.parameters {
        if !args.is_empty() {
            args += ", "
        }
        args += "${p.name}: ${p.type_usage}"
    }

    return "${prefix}${header.to_pretty_string()} $code // $span"
}

fun NFunctionHeader.to_pretty_string(): String {
    let str = StringBuilder::new()
    let full_name = Path::join(path, name)

    str[] = "fun "
    str[] = full_name
    str[] = "("

    let args = ""
    for p in parameters {
        if !args.is_empty() {
            str[] = ", "
        }
        str[] = p.name
        str[] = ": "
        str[] = p.type_usage
    }
    str[] = "): "
    str[] = return_type_usage

    return str.to_string()
}

struct ExternAnnotation {
    lib: String
    name: String
    autogenerate: Boolean
}

fun NFunction.is_extern(): Boolean = get_extern_annotation().is_some()

fun NFunction.get_extern_annotation(): Optional<ExternAnnotation> {
    let extern_annotation = get_annotation("Extern")
    if extern_annotation.is_none() {
        ret None()
    }

    let a: NAnnotation = extern_annotation!!
    let lib: Optional<NConstExpr> = a.get_arg("lib")
    let name: Optional<NConstExpr> = a.get_arg("name")

    if lib.is_none() || name.is_none() {
        ret None()
    }

    let lib_str: Optional<String> = lib!!.get_string()
    let name_str: Optional<String> = name!!.get_string()

    if lib_str.is_none() || name_str.is_none() {
        ret None()
    }

    let autogenerate: Boolean = false
    let autogenerate_arg: Optional<NConstExpr> = a.get_arg("autogenerate")

    if autogenerate_arg.is_some() && autogenerate_arg!!.get_boolean().is_some() {
        autogenerate = autogenerate_arg!!.get_boolean()!!
    }

    ret Some(ExternAnnotation @[
        lib: lib_str!!,
        name: name_str!!,
        autogenerate,
    ])
}

fun ByteBuffer.serialize_function(value: NFunction) {
    let frame = start_frame(true)
    serialize_id(value.id)
    serialize_span(value.span)
    write_int(value.annotations.len)
    for a in value.annotations {
        serialize_annotation(a)
    }
    serialize_function_header(value.header)
    serialize_code(value.code)
    end_frame(frame)
}

fun ByteBuffer.deserialize_function(): NFunction {
    let frame = start_frame(false)
    let id = deserialize_id()
    let span = deserialize_span()
    let annotations = []
    repeat read_int() {
        annotations[] = deserialize_annotation()
    }
    let header = deserialize_function_header()
    let code = deserialize_code(None(), header.generics)

    let full_name = header.full_name
    let value = NFunction @[
        id,
        span,
        annotations,
        header,
        code,
        full_name,
    ]

    end_frame(frame)
    ret value
}

fun ByteBuffer.serialize_function_parameter(value: NFunctionParameter) {
    let frame = start_frame(true)
    serialize_span(value.span)
    write_string(value.name)
    serialize_type_usage(value.type_usage)
    end_frame(frame)
}

fun ByteBuffer.deserialize_function_parameter(): NFunctionParameter {
    let frame = start_frame(false)
    let span = deserialize_span()
    let name = read_string()
    let type_usage = deserialize_type_usage()
    let param_type = None()

    let value = NFunctionParameter @[
        span,
        name,
        type_usage,
        param_type,
    ]

    end_frame(frame)
    ret value
}
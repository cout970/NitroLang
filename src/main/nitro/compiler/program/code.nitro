
// NCode represents a block of code, which can be a function, a constant initialization or a lambda expression.
struct NCode {
    // Ref to the program containing all the codes
    program: Program
    // Unique identifier of the code
    id: Id
    // Container of the code, ie. the function, constant or lambda expression that contains this block of code
    container: NCodeContainer
    // Indicate that this block belong to the same context as the parent, for example, for code reordering, will be false for lambdas, defer, etc.
    is_transparent_child: Boolean
    // List of lambdas defined in this code
    lambdas: List<Id>
    // Id provider for marks
    mark_id_provider: IdProvider
    // Id provider for new instructions
    inst_id_provider: IdProvider
    // List of instructions of the function/constant
    inst_list: List<NInst>
    // Id provider for new variables
    variable_id_provider: IdProvider
    // Declared variables, names can be duplicated
    vars_map: Map<NVarId, NVar>
    // List of jumps generated by break statements, to be updated at the end of a loop
    break_jumps: List<NInstId>
    // List of jumps generated by continue statements, to be updated at the end of a loop
    continue_jumps: List<NInstId>
    // Last executed expression, used to generate implicit return statements
    last_expression: Optional<NInstId>
    // Type of the receiver of the function, used to generate implicit self references
    receiver_type_token: Optional<TypeToken>
    // Expected type to be returned by the function
    return_type_token: Optional<TypeToken>
    // Cache of constants used in this code, constants depend on the location of the function inside the global scope,
    // In a block of code (function or constant) a given name will always refer to the same constant
    const_cache: Map<String, NConst>
    // Cursor pointing to the index of the last added instruction, if is -1, instructions will be added at the end
    cursor: Int
}

fun NCode::new(program: Program, container: NCodeContainer): NCode {
    let code = NCode @[
        program,
        id: program.id_provider.next(),
        container,
        is_transparent_child: false,
        lambdas: [],
        inst_list: [],
        vars_map: #[],
        mark_id_provider: IdProvider::new(),
        inst_id_provider: IdProvider::new(),
        variable_id_provider: IdProvider::new(),
        break_jumps: [],
        continue_jumps: [],
        last_expression: None(),
        receiver_type_token: None(),
        return_type_token: None(),
        const_cache: #[],
        cursor: -1,
    ]

    ret code
}

fun NCode.new_child_code(container: NCodeContainer, is_transparent_child: Boolean): NCode {
    let subcode = NCode::new(program, container)
    subcode.is_transparent_child = is_transparent_child
    subcode.variable_id_provider.seek_to(variable_id_provider)
    ret subcode
}

fun NCode::create_from(other: NCode): NCode {
    let subcode = NCode::new(other.program, other.container)
    subcode.is_transparent_child = other.is_transparent_child
    subcode.variable_id_provider.seek_to(other.variable_id_provider)
    ret subcode
}

fun NCode.get_generics(): NGenericParams = container.generics

fun NCode.get_parent_code(): Optional<NCode> {
    if container is NCodeContainer::Lambda {
        let def = (container as NCodeContainer::Lambda).def

        if def.container is NCodeContainer::None {
            crash("Cannot get parent code of a lambda without container, lambda: $def, code: $this")
        }

        ret Some(def.container.code)
    }
    ret None()
}

fun NCode.get_span(): Span = container.span

fun NCode.enter_block(span: Span, is_jump_target: Boolean): NInstId {
    let inst = add_block_start(span, is_jump_target)
    ret inst.id
}

fun NCode.exit_block(span: Span) {
    add_block_end(span)
}

fun NCode.find_inst(id: NInstId): NInst {
    let i = 0
    while i < inst_list.len {
        let inst = inst_list[i]!!
        i += 1

        if inst.id == id {
            ret inst
        }
    }

    crash("Instruction not found: #$id at $this")
}

fun NCode.find_inst_type_token(id: NInstId): Optional<TypeToken> {
    let i = 0
    while i < inst_list.len {
        let inst = inst_list[i]!!
        i += 1

        if inst.id == id {
            if inst.type_token.is_some() {
                ret Some(inst.type_token!!)
            }
            ret None()
        }
    }

    ret None()
}

fun NCode.index_of_inst(id: NInstId): Optional<Int> {
    let current = 0
    let i = 0
    while i < inst_list.len {
        let inst = inst_list[i]!!
        i += 1

        if inst.id == id {
            ret Some(current)
        }
        current += 1
    }

    ret None()
}

fun NCode.find_var(id: NVarId): NVar {
    let opt = vars_map[id]
    if opt.is_some() {
        ret opt!!
    }

    if parent_code.is_some() {
        ret parent_code!!.find_var(id)
    }

    crash("Variable not found: #$id")
}

fun NCode.find_receiver_type(): Optional<Type> {
    if receiver_type_token.is_some() {
        ret Some(receiver_type_token!!.find_type())
    }

    if parent_code.is_some() {
        ret parent_code!!.find_receiver_type()
    }

    ret None()
}

fun NCode.get_upvalues(): List<NVarId> {
    let upvalues = []
    let i = 0
    while i < inst_list.len {
        let inst = inst_list[i]!!
        i += 1

        if inst.kind is NInstKind::LetUpvalue {
            let kind = inst.kind as NInstKind::LetUpvalue
            upvalues[] = kind.variable
        }
    }

    ret upvalues
}

fun NCode.index_of_mark(id: Id): Optional<Int> {
    let current = 0
    let i = 0
    while i < inst_list.len {
        let inst = inst_list[i]!!
        i += 1

        if inst.kind is NInstKind::Mark {
            let kind = inst.kind as NInstKind::Mark
            if kind.id == id {
                ret Some(current)
            }
        }
        current += 1
    }

    ret None()
}

fun NCode.get_inst_list_between(start_mark: Id, end_mark: Id): List<NInst> {
    let start = index_of_mark(start_mark)!!
    let end = index_of_mark(end_mark)!!
    let cur = start
    let tmp = []

    loop {
        if cur > end {
            break
        }

        let inst = inst_list[cur]!!
        tmp[] = inst
        cur += 1
    }

    ret tmp
}

fun NCode.remove_inst_list_between(start_mark: Id, end_mark: Id) {
    let start = index_of_mark(start_mark)!!
    let end = index_of_mark(end_mark)!!

    repeat end - start + 1 {
        inst_list.remove_at(start)!!
    }
}

fun NCode.move_instructions_to_end(start_mark: Id, end_mark: Id) {
    let start = index_of_mark(start_mark)!!
    let end = index_of_mark(end_mark)!!
    let cur = start

    loop {
        if cur > end {
            break
        }

        let inst = inst_list[cur]!!
        inst_list[] = inst
        cur += 1
    }

    repeat end - start + 1 {
        inst_list.remove_at(start)!!
    }
}

fun NCode.move_instructions_after(target: NInstId, start_mark: Id, end_mark: Id) {
    let tmp = get_inst_list_between(start_mark, end_mark)

    if tmp.is_empty() {
        ret
    }

    remove_inst_list_between(start_mark, end_mark)

    let index = index_of_inst(target)!! + 1
    for inst in tmp {
        inst_list.insert(index, inst)
        index += 1
    }
}

fun NCode.move_instructions_before(target: NInstId, start_mark: Id, end_mark: Id) {
    let tmp = get_inst_list_between(start_mark, end_mark)

    if tmp.is_empty() {
        ret
    }

    remove_inst_list_between(start_mark, end_mark)

    let index = index_of_inst(target)!!
    for inst in tmp {
        inst_list.insert(index, inst)
        index += 1
    }
}

fun NCode.remove_mark(id: Id) {
    let index = index_of_mark(id)!!
    inst_list.remove_at(index)!!
}

struct NCodeJumps {
    prev_break_jumps: List<NInstId>
    prev_continue_jumps: List<NInstId>
}

fun NCode.save_jump_points(): NCodeJumps {
    let prev_break_jumps = this.break_jumps
    let prev_continue_jumps = this.continue_jumps

    this.break_jumps = []
    this.continue_jumps = []

    ret NCodeJumps @[prev_break_jumps, prev_continue_jumps]
}

fun NCode.link_jump_points(break_block: NInstId, continue_block: NInstId) {
    // Link all continue and break jumps inside de loop
    for jump in break_jumps {
        let kind = find_inst(jump).kind as NInstKind::BlockJump
        kind.block = Some(break_block)
    }

    for jump in continue_jumps {
        let kind = find_inst(jump).kind as NInstKind::BlockJump
        kind.block = Some(continue_block)
    }
}

fun NCode.restore_jump_points(jumps: NCodeJumps) {
    check_jump_points()

    this.break_jumps = jumps.prev_break_jumps
    this.continue_jumps = jumps.prev_continue_jumps
}

fun NCode.check_jump_points() {
    // Check all jumps are linked
    for jump in break_jumps {
        let kind = find_inst(jump).kind as NInstKind::BlockJump
        if kind.block.is_none() {
            crash("Jump not linked: 'break' #$jump\n$this")
        }
    }

    for jump in continue_jumps {
        let kind = find_inst(jump).kind as NInstKind::BlockJump
        if kind.block.is_none() {
            crash("Jump not linked: 'continue' #$jump\n$this")
        }
    }
}

fun NCode.calculate_back_references() {
    for inst in inst_list {
        inst.back_references.clear()
    }

    for inst in inst_list {
        when  {
            inst.kind is NInstKind::IfStart -> {
                let kind = inst.kind as NInstKind::IfStart
                let dep = find_inst(kind.condition)
                dep.back_references[] = inst.id
            }
            inst.kind is NInstKind::IfChoose -> {
                let kind = inst.kind as NInstKind::IfChoose
                let dep = find_inst(kind.condition)
                dep.back_references[] = inst.id

                let dep2 = find_inst(kind.if_true)
                dep2.back_references[] = inst.id

                let dep3 = find_inst(kind.if_false)
                dep3.back_references[] = inst.id
            }
            inst.kind is NInstKind::FunCall -> {
                let kind = inst.kind as NInstKind::FunCall
                for id in kind.arguments {
                    let dep = find_inst(id)
                    dep.back_references[] = inst.id
                }
            }
            inst.kind is NInstKind::Return -> {
                let kind = inst.kind as NInstKind::Return
                let dep = find_inst(kind.value)
                dep.back_references[] = inst.id
            }
            inst.kind is NInstKind::IsType -> {
                let kind = inst.kind as NInstKind::IsType
                let dep = find_inst(kind.value)
                dep.back_references[] = inst.id
            }
            inst.kind is NInstKind::AsType -> {
                let kind = inst.kind as NInstKind::AsType
                let dep = find_inst(kind.value)
                dep.back_references[] = inst.id
            }
            inst.kind is NInstKind::StoreVar -> {
                let kind = inst.kind as NInstKind::StoreVar
                let dep = find_inst(kind.value)
                dep.back_references[] = inst.id
            }
            inst.kind is NInstKind::LoadField -> {
                let kind = inst.kind as NInstKind::LoadField
                let dep = find_inst(kind.instance)
                dep.back_references[] = inst.id
            }
            inst.kind is NInstKind::StoreField -> {
                let kind = inst.kind as NInstKind::StoreField
                let dep = find_inst(kind.instance)
                dep.back_references[] = inst.id
                let dep2 = find_inst(kind.value)
                dep2.back_references[] = inst.id
            }
            inst.kind is NInstKind::InitField -> {
                let kind = inst.kind as NInstKind::InitField
                let dep = find_inst(kind.instance)
                dep.back_references[] = inst.id
                let dep2 = find_inst(kind.value)
                dep2.back_references[] = inst.id
            }
            inst.kind is NInstKind::Link -> {
                let kind = inst.kind as NInstKind::Link
                let dep = find_inst(kind.linked_id)
                dep.back_references[] = inst.id
            }
            else -> {}
        }
    }
}

fun NCode.get_depth_of_inst(inst_id: NInstId): Int {
    let depth = 0
    let i = 0

    while i < inst_list.len {
        let inst = inst_list[i]!!
        i += 1

        if inst.kind is NInstKind::BlockEnd {
            depth -= 1
        }
        if inst.kind is NInstKind::BlockStart {
            depth += 1
        }
        if inst.id == inst_id {
            break
        }
    }
    ret depth
}

fun NCode.add_deferred_code() {
    // Avoid replacing the last expression, since deferred code cannot be used for the implicit return
    let prev_last_expression = last_expression
    let i = inst_list.len - 1

    while i >= 0 {
        let inst = inst_list[i]!!

        if inst.kind !is NInstKind::Defer {
            i -= 1
            continue
        }

        // Current depth
        let defer_depth = get_depth_of_inst(inst.id)

        // Remove the defer instruction from the list
        inst_list.remove_at(i)!!

        let kind = inst.kind as NInstKind::Defer
        let subcode = kind.deferred_code

        // Go to the end of the current block
        let j = i
        let skip = false
        let aux_depth = defer_depth

        while j < inst_list.len {
            let sub_inst = inst_list[j]!!

            if sub_inst.kind is NInstKind::BlockStart {
                aux_depth += 1
            }

            if sub_inst.kind is NInstKind::BlockJump {
                // Identify if the jump is outside the block that contains the defer
                let kind = sub_inst.kind as NInstKind::BlockJump

                if kind.block.is_some() {
                    let start = kind.block!!
                    let depth_of_target_block = this.get_depth_of_inst(start)

                    // If the instruction jumps to a block that is less deep or the same depth as the defer, execute the code
                    if depth_of_target_block < defer_depth {
                        this.add_at_index(j, subcode)
                        j = this.index_of_inst(sub_inst.id)!!
                        j += 1
                        skip = true
                        continue
                    }
                }

                skip = true
            }

            if sub_inst.kind is NInstKind::Return {
                // We reached a return, insert the deferred code here before the return
                this.add_at_index(j, subcode)
                j = this.index_of_inst(sub_inst.id)!!
                j += 1
                skip = true
                continue
            }

            if sub_inst.kind is NInstKind::BlockEnd {
                aux_depth -= 1

                // We reached the end of the block, insert the deferred code here
                // but only if there was no return or jump just before
                // and the depth of the block is the same as the defer depth
                if aux_depth == defer_depth - 1 {
                    if !skip {
                        this.add_at_index(j, subcode)
                        j = this.index_of_inst(sub_inst.id)!!
                        j += 1
                    }
                    skip = true
                    break
                }

                skip = false
            }

            j += 1
        }

        // End of the code
        if !skip {
            this.add_at_index(j, subcode)
        }
    }

    last_expression = prev_last_expression
}

fun NCode.clear() {
    lambdas.clear()
    inst_list.clear()
    vars_map.clear()
    break_jumps.clear()
    continue_jumps.clear()
    last_expression = None()
    receiver_type_token = None()
    return_type_token = None()
    const_cache.clear()
    cursor = -1
}

fun NCode.to_string(): String {
    if inst_list.is_empty() && vars_map.is_empty() {
        ret "{}"
    }

    let body_str = StringBuilder::new()

    body_str[] = "{"
    body_str[] = "\n  id: $id"
    body_str[] = "\n  container: $container"
    body_str[] = "\n  span: ${this.span}"
    body_str[] = "\n  generics: ${generics}"
    body_str[] = "\n  vars: ["
    for variable in vars_map.values_to_list() {
        body_str[] = variable.name
        if variable.type_token.is_some() {
            body_str[] = ": "
            body_str[] = variable.type_token.to_string()
        }
        body_str[] = ","
    }
    body_str[] = "]"

    let depth = 0

    for i in inst_list {
        if i.kind is NInstKind::BlockEnd {
            depth -= 1
        }
        let current_depth = depth
        if i.kind is NInstKind::BlockStart {
            depth += 1
        }

        let id = i.id.to_string()
        let line = StringBuilder::new()
        line[] = " " * (5 - id.len - 1)
        line[] = "#"
        line[] = id
        line[] = " | "
        let prefix_len = line.len
        line[] = "  " * current_depth
        if i.gc_related {
            line[] = "[GC] "
        }
        line[] = i.to_string(this).indent(prefix_len).trim()

        if i.type_token.is_some() {
            if !i.type_token!!.find_type().is_nothing() {
                line[] = " -> "
                line[] = i.type_token!!.to_string()
            }
        } else {
            line[] = " -> "
            line[] = "<not set>"
        }

        body_str[] = "\n"
        body_str[] = line
    }

    body_str[] = "\n  last_expression: $last_expression"
    body_str[] = "\n  receiver_type_token: $receiver_type_token"
    body_str[] = "\n  return_type_token: $return_type_token"
    body_str[] = "\n  lambdas: ${lambdas}"
    body_str[] = "\n}"

    ret body_str.to_string()
}

fun ByteBuffer.serialize_code(code: NCode) {
    let frame = start_frame(true)
    serialize_id(code.id)
    serialize_code_container(code.container)
    write_boolean(code.is_transparent_child)
    serialize_id_provider(code.mark_id_provider)
    serialize_id_provider(code.inst_id_provider)
    serialize_id_provider(code.variable_id_provider)
    write_int(code.break_jumps.len)
    write_int(code.cursor)
    for jump in code.break_jumps {
        serialize_id(jump)
    }
    write_int(code.continue_jumps.len)
    for jump in code.continue_jumps {
        serialize_id(jump)
    }
    write_boolean(code.last_expression.is_some())
    if code.last_expression.is_some() {
        serialize_id(code.last_expression!!)
    }
    write_int(code.vars_map.len)
    for entry in code.vars_map {
        serialize_var(entry.second)
    }
    write_int(code.inst_list.len)
    for inst in code.inst_list {
        serialize_inst(inst)
    }
    write_int(code.lambdas.len)
    for lambda_id in code.lambdas {
        serialize_id(lambda_id)
    }
    end_frame(frame)
}

fun ByteBuffer.deserialize_code(program: Program): NCode {
    let frame = start_frame(false)
    let id = deserialize_id()
    let container = deserialize_code_container(program)
    let is_transparent_child = read_boolean()
    let lambdas = []
    let mark_id_provider = deserialize_id_provider()
    let inst_id_provider = deserialize_id_provider()
    let inst_list = []
    let variable_id_provider = deserialize_id_provider()
    let vars_map = #[]
    let cursor = read_int()
    let break_jumps = []
    repeat read_int() {
        break_jumps[] = deserialize_id()
    }
    let continue_jumps = []
    repeat read_int() {
        continue_jumps[] = deserialize_id()
    }
    let last_expression = None()
    if read_boolean() {
        last_expression = Some(deserialize_id())
    }
    let value = NCode @[
        program,
        id,
        container,
        is_transparent_child,
        lambdas,
        mark_id_provider,
        inst_id_provider,
        inst_list,
        variable_id_provider,
        vars_map,
        break_jumps,
        continue_jumps,
        last_expression,
        const_cache: #[],
        receiver_type_token: None(),
        return_type_token: None(),
        cursor,
    ]

    repeat read_int() {
        let variable = deserialize_var()
        vars_map[variable.id] = variable
    }

    repeat read_int() {
        inst_list[] = deserialize_inst(value)
    }

    repeat read_int() {
        lambdas[] = deserialize_id()
    }

    end_frame(frame)
    ret value
}


// NCode represents a block of code, which can be a function, a constant initialization or a lambda expression.
struct NCode {
    // Parent code, ie. the code of the function containing a lambda expression represented by this code
    parent_code: Optional<NCode>
    parent_inst: Optional<NInstId>
    parent_block: Optional<NBlock>
    parent_span: Optional<Span>
    generics: NGenericParams
    // List of instructions of the function/constant
    inst: List<NInst>
    // Declared variables, names can be duplicated
    vars: List<NVar>
    // Last allocated id for new instructions
    last_id: NInstId
    // Last allocated id for new variables
    last_var_id: NVarId
    // Root block. Blocks determine the scope of each instruction
    root_block: NBlock
    // Current block, assigned to new instructions
    current_block: NBlock
    // Stack of blocks, used to restore the previous block value of [current_block] when exiting a block
    block_stack: List<NBlock>
    // Last allocated id for new blocks
    last_block_id: NBlockId
    // Flag to indicate if the code has jumped out of the current block with a return/continue/break
    jumped_out_of_block: Boolean
    // List of jumps generated by break statements, to be updated at the end of a loop
    break_jumps: List<NInstId>
    // List of jumps generated by continue statements, to be updated at the end of a loop
    continue_jumps: List<NInstId>
    // Last executed expression, used to generate implicit return statements
    last_expression: Optional<NInstId>
    // Type of the receiver of the function, used to generate implicit self references
    receiver_type: Optional<TypeToken>
    // Cache of constants used in this code, constants depend on the location of the function inside the global scope,
    // In a block of code (function or constant) a given name will always refer to the same constant
    const_cache: Map<String, NConst>
}

fun NCode::new(): NCode {
    let root_block = NBlock @[
        id: 0,
        parent: None(),
        is_jump_target: false,
        deferred_code: [],
        variable_stack: [],
    ]

    ret NCode @[
        parent_code: None(),
        parent_inst: None(),
        parent_block: None(),
        parent_span: None(),
        generics: NGenericParams::new(),
        inst: [],
        vars: [],
        last_id: -1,
        last_var_id: -1,
        root_block,
        current_block: root_block,
        block_stack: [],
        last_block_id: 0,
        jumped_out_of_block: false,
        break_jumps: [],
        continue_jumps: [],
        last_expression: None(),
        receiver_type: None(),
        const_cache: #[],
    ]
}

fun NCode.new_child(span: Span): NCode {
    let subcode = NCode::new()
    subcode.parent_code = Some(this)
    subcode.parent_inst = Some(last_id)
    subcode.parent_block = Some(current_block)
    subcode.parent_span = Some(span)
    ret subcode
}

fun NCode.enter_block(is_jump_target: Boolean) {
    block_stack[] = current_block
    last_block_id += 1
    current_block = NBlock @[
        id: last_block_id,
        parent: Some(current_block),
        is_jump_target,
        deferred_code: [],
        variable_stack: [],
    ]
}

fun NCode.exit_block() {
    if !jumped_out_of_block && current_block.deferred_code.is_not_empty() {
        for subcode in current_block.deferred_code.to_reversed() {
            this.merge(subcode)
        }
    }
    jumped_out_of_block = false
    current_block = block_stack.remove_last()!!
}

fun NCode.find(id: NInstId): Optional<NInst> {
    for i in this.inst {
        if i.id == id {
            ret Some(i)
        }
    }

    ret None()
}

fun NCode.find_type(id: NInstId): Optional<TypeToken> {
    for i in this.inst {
        if i.id == id {
            ret i.type_token
        }
    }

    ret None()
}

fun NCode.execute_deferred_actions(block: NBlock, is_return: Boolean) {
    if block.deferred_code.is_not_empty() {
        for subcode in block.deferred_code.to_reversed() {
            this.merge(subcode)
        }
    }

    if block.parent.is_some() && (is_return || !block.is_jump_target) {
        execute_deferred_actions(block.parent!!, is_return)
    }
}

struct NCodeJumps {
    prev_break_jumps: List<NInstId>
    prev_continue_jumps: List<NInstId>
}

fun NCode.save_jump_points(): NCodeJumps {
    let prev_break_jumps = this.break_jumps
    let prev_continue_jumps = this.continue_jumps

    this.break_jumps = []
    this.continue_jumps = []

    ret NCodeJumps @[prev_break_jumps, prev_continue_jumps]
}

fun NCode.link_jump_points(break_block: NBlock, continue_block: NBlock) {
    // Link all continue and break jumps inside de loop
    for jump in this.break_jumps {
        let kind = this.find(jump)!!.kind as NInstKind::BlockJump
        kind.block = Some(break_block)
    }

    for jump in this.continue_jumps {
        let kind = this.find(jump)!!.kind as NInstKind::BlockJump
        kind.block = Some(continue_block)
    }
}

fun NCode.restore_jump_points(jumps: NCodeJumps) {
    this.break_jumps = jumps.prev_break_jumps
    this.continue_jumps = jumps.prev_continue_jumps
}

fun NCode.merge(other: NCode) {
    let mapping: Map<NInstId, NInstId> = #[]

    for i in other.inst {
        this.add_copy(i, mapping)
    }
}

fun NCode.to_string(): String {
    if inst.is_empty() {
        ret "{}"
    }

    let body_str = "{"

     for i in inst {
        let id = i.id.to_string()
        let line = ""
        line += " " * (5 - id.len - 1)
        line += "#"
        line += id
        line += " | "
        let prefix_len = line.len
        line += "  " * i.block.depth
        line += i.to_string().indent(prefix_len).trim()
        line += "  [type: "
        line += i.type_token.to_string()
        line += "]"

        body_str += "\n"
        body_str += line
    }
    body_str += "\n  last-expression: $last_expression"
    body_str += "\n}"

    ret body_str
}

// NCode represents a block of code, which can be a function, a constant initialization or a lambda expression.
struct NCode {
    name: String
    // Parent code, ie. the code of the function containing a lambda expression represented by this code
    parent_code: Optional<NCode>
    parent_inst: Optional<NInstId>
    parent_block: Optional<NBlockId>
    parent_span: Optional<Span>
    // Any nested code, lambdas or deferred code
    children: List<NCode>
    // Span of the start of the block
    span: Span
    // Generics defined for this block of code
    generics: NGenericParams
    // Last allocated id for new instructions
    last_id: NInstId
    // List of instructions of the function/constant
    inst_list: List<NInst>
    // Last allocated id for new variables
    last_var_id: NVarId
    // Declared variables, names can be duplicated
    vars_map: Map<NVarId, NVar>
    // Last allocated id for new blocks
    last_block_id: NBlockId
    // All the blocks defined in this code
    block_map: Map<NBlockId, NBlock>
    // Current block, assigned to new instructions
    current_block: NBlockId
    // Flag to indicate if the code has jumped out of the current block with a return/continue/break
    jumped_out_of_block: Boolean
    // List of jumps generated by break statements, to be updated at the end of a loop
    break_jumps: List<NInstId>
    // List of jumps generated by continue statements, to be updated at the end of a loop
    continue_jumps: List<NInstId>
    // Last executed expression, used to generate implicit return statements
    last_expression: Optional<NInstId>
    // Type of the receiver of the function, used to generate implicit self references
    receiver_type_token: Optional<TypeToken>
    // Expected type to be returned by the function
    return_type_token: Optional<TypeToken>
    // Cache of constants used in this code, constants depend on the location of the function inside the global scope,
    // In a block of code (function or constant) a given name will always refer to the same constant
    const_cache: Map<String, NConst>
    // List of upvalues used by this code, to be used by the parent code
    upvalues: List<NVarId>
}

fun NCode::new(span: Span, name: String): NCode {
    let root_block_id = 0

    let code = NCode @[
        name,
        parent_code: None(),
        parent_inst: None(),
        parent_block: None(),
        parent_span: None(),
        children: [],
        span,
        generics: NGenericParams::new(),
        inst_list: [],
        vars_map: #[],
        last_id: -1,
        last_var_id: -1,
        current_block: root_block_id,
        last_block_id: root_block_id,
        block_map: #[],
        jumped_out_of_block: false,
        break_jumps: [],
        continue_jumps: [],
        last_expression: None(),
        receiver_type_token: None(),
        return_type_token: None(),
        const_cache: #[],
        upvalues: [],
    ]

    let root_block = NBlock @[
        id: root_block_id,
        parent_id: None(),
        is_jump_target: false,
        deferred_code: [],
        code,
    ]

    code.block_map[root_block_id] = root_block
    ret code
}

fun NCode.new_child(span: Span): NCode {
    let subcode = NCode::new(span, "$name::child")
    subcode.parent_code = Some(this)
    subcode.parent_inst = Some(last_id)
    subcode.parent_block = Some(current_block)
    subcode.parent_span = Some(span)
    children[] = subcode
    ret subcode
}

fun NCode.enter_block(is_jump_target: Boolean) {
    last_block_id += 1
    let new_block = NBlock @[
        id: last_block_id,
        parent_id: Some(current_block),
        is_jump_target,
        deferred_code: [],
        code: this,
    ]
    block_map[new_block.id] = new_block
    current_block = new_block.id
}

fun NCode.exit_block() {
    let block = find_block(current_block)
    if !jumped_out_of_block && block.deferred_code.is_not_empty() {
        for subcode in block.deferred_code.to_reversed() {
            // Avoid replacing the last expression, since deferred code cannot be used for the implicit return
            let prev_last_expression = this.last_expression
            this.merge(subcode)
            this.last_expression = prev_last_expression
        }
    }
    jumped_out_of_block = false
    current_block = block.parent_id!!
}

fun NCode.find_inst(id: NInstId): NInst {
    for i in inst_list {
        if i.id == id {
            ret i
        }
    }

    crash("Instruction not found: #$id at $this")
}

fun NCode.find_inst_type_token(id: NInstId): Optional<TypeToken> {
    for i in inst_list {
        if i.id == id {
            if i.type_token.is_some() {
                ret Some(i.type_token!!)
            }
            ret None()
        }
    }

    ret None()
}

fun NCode.index_of(id: NInstId): Optional<Index> {
    let current = 0
    for i in inst_list {
        if i.id == id {
            ret Some(Index @[current])
        }
        current += 1
    }

    ret None()
}

fun NCode.find_block(id: NBlockId): NBlock {
    let opt = block_map[id]
    if opt.is_some() {
        ret opt!!
    }

    crash("Block not found: #$id at $this")
}

fun NCode.find_var(id: NVarId): NVar {
    let opt = vars_map[id]
    if opt.is_some() {
        ret opt!!
    }

    if parent_code.is_some() {
        ret parent_code!!.find_var(id)
    }

    crash("Variable not found: #$id at $this")
}

fun NCode.find_receiver_type(): Optional<Type> {
    if receiver_type_token.is_some() {
        ret Some(receiver_type_token!!.find_type())
    }

    if parent_code.is_some() {
        ret parent_code!!.find_receiver_type()
    }

    ret None()
}

fun NCode.execute_deferred_actions(block_id: NBlockId, is_return: Boolean) {
    let block = find_block(block_id)

    if block.deferred_code.is_not_empty() {
        for subcode in block.deferred_code.to_reversed() {
            // Avoid replacing the last expression, since deferred code cannot be used for the implicit return
            let prev_last_expression = this.last_expression
            this.merge(subcode)
            this.last_expression = prev_last_expression
        }
    }

    if block.parent_id.is_some() && (is_return || !block.is_jump_target) {
        execute_deferred_actions(block.parent_id!!, is_return)
    }
}

struct NCodeJumps {
    prev_break_jumps: List<NInstId>
    prev_continue_jumps: List<NInstId>
}

fun NCode.save_jump_points(): NCodeJumps {
    let prev_break_jumps = this.break_jumps
    let prev_continue_jumps = this.continue_jumps

    this.break_jumps = []
    this.continue_jumps = []

    ret NCodeJumps @[prev_break_jumps, prev_continue_jumps]
}

fun NCode.link_jump_points(break_block: NBlockId, continue_block: NBlockId) {
    // Link all continue and break jumps inside de loop
    for jump in break_jumps {
        let kind = find_inst(jump).kind as NInstKind::BlockJump
        kind.block = Some(break_block)
    }

    for jump in continue_jumps {
        let kind = find_inst(jump).kind as NInstKind::BlockJump
        kind.block = Some(continue_block)
    }
}

fun NCode.restore_jump_points(jumps: NCodeJumps) {
    check_jump_points()

    this.break_jumps = jumps.prev_break_jumps
    this.continue_jumps = jumps.prev_continue_jumps
}

fun NCode.check_jump_points() {
    // Check all jumps are linked
    for jump in break_jumps {
        let kind = find_inst(jump).kind as NInstKind::BlockJump
        if kind.block.is_none() {
            crash("Jump not linked: 'break' #$jump\n$this")
        }
    }

    for jump in continue_jumps {
        let kind = find_inst(jump).kind as NInstKind::BlockJump
        if kind.block.is_none() {
            crash("Jump not linked: 'continue' #$jump\n$this")
        }
    }
}

fun NCode.calculate_back_references() {
    for inst in inst_list {
        inst.back_references.clear()
    }

    for inst in inst_list {
        when  {
            inst.kind is NInstKind::IfStart -> {
                let kind = inst.kind as NInstKind::IfStart
                let dep = find_inst(kind.condition)
                dep.back_references[] = inst.id
            }
            inst.kind is NInstKind::IfChoose -> {
                let kind = inst.kind as NInstKind::IfChoose
                let dep = find_inst(kind.condition)
                dep.back_references[] = inst.id

                let dep2 = find_inst(kind.if_true)
                dep2.back_references[] = inst.id

                let dep3 = find_inst(kind.if_false)
                dep3.back_references[] = inst.id
            }
            inst.kind is NInstKind::FunCall -> {
                let kind = inst.kind as NInstKind::FunCall
                for id in kind.arguments {
                    let dep = find_inst(id)
                    dep.back_references[] = inst.id
                }
            }
            inst.kind is NInstKind::Return -> {
                let kind = inst.kind as NInstKind::Return
                let dep = find_inst(kind.value)
                dep.back_references[] = inst.id
            }
            inst.kind is NInstKind::IsType -> {
                let kind = inst.kind as NInstKind::IsType
                let dep = find_inst(kind.value)
                dep.back_references[] = inst.id
            }
            inst.kind is NInstKind::AsType -> {
                let kind = inst.kind as NInstKind::AsType
                let dep = find_inst(kind.value)
                dep.back_references[] = inst.id
            }
            inst.kind is NInstKind::StoreVar -> {
                let kind = inst.kind as NInstKind::StoreVar
                let dep = find_inst(kind.value)
                dep.back_references[] = inst.id
            }
            inst.kind is NInstKind::LoadField -> {
                let kind = inst.kind as NInstKind::LoadField
                let dep = find_inst(kind.instance)
                dep.back_references[] = inst.id
            }
            inst.kind is NInstKind::StoreField -> {
                let kind = inst.kind as NInstKind::StoreField
                let dep = find_inst(kind.instance)
                dep.back_references[] = inst.id
                let dep2 = find_inst(kind.value)
                dep2.back_references[] = inst.id
            }
            inst.kind is NInstKind::Link -> {
                let kind = inst.kind as NInstKind::Link
                let dep = find_inst(kind.linked_id)
                dep.back_references[] = inst.id
            }
            else -> {}
        }
    }
}

fun NCode.to_string(): String {
    if inst_list.is_empty() {
        ret "{}"
    }

    let body_str = "{"

    body_str += "\n  span: $span"
    body_str += "\n  name: $name"

    for i in inst_list {
        let id = i.id.to_string()
        let line = ""
        line += " " * (5 - id.bytes_len - 1)
        line += "#"
        line += id
        line += " | "
        let prefix_len = line.bytes_len
        line += "  " * find_block(i.block).depth
        line += i.to_string().indent(prefix_len).trim()

        line += " -> "
        if i.type_token.is_some() {
            line += i.type_token!!.to_string()
        } else {
            line += "<not inferred>"
        }

        body_str += "\n"
        body_str += line
    }

    body_str += "\n  last_expression: $last_expression"
    body_str += "\n  receiver_type_token: $receiver_type_token"
    body_str += "\n  return_type_token: $return_type_token"
    body_str += "\n  parent_inst: $parent_inst"
    body_str += "\n}"

    ret body_str
}
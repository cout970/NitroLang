
let ANNOTATION_TMP_RC: String = "Rc"
let ANNOTATION_NO_GC: String = "NoGC"
let ANNOTATION_EXTERN: String = "Extern"
let ANNOTATION_AUTOGENERATED: String = "Autogenerated"
let ANNOTATION_DEFAULT_IMPL: String = "DefaultImplementation"
let ANNOTATION_OVERRIDE: String = "Override"
let ANNOTATION_WASM_NAME: String = "WasmName"
let ANNOTATION_WASM_INLINE: String = "WasmInline"
let ANNOTATION_INTRINSIC: String = "Intrinsic"
let ANNOTATION_INTRINSIC_SIZE: String = "IntrinsicSize"
let ANNOTATION_INIT_PRIORITY: String = "InitPriority"
let ANNOTATION_DUMP_IR: String = "DumpIr"

struct NAnnotationContainer {
    values: List<NAnnotation>
}

struct NAnnotation {
    span: Span
    name: String
    args: List<NAnnotationArg>
}

struct NAnnotationArg {
    span: Span
    key: String
    value: NValue
}

fun NAnnotationContainer::new(): NAnnotationContainer {
    ret NAnnotationContainer @[values: []]
}

fun NAnnotationContainer::new(values: List<NAnnotation>): NAnnotationContainer {
    ret NAnnotationContainer @[values]
}

fun NAnnotationContainer.add(value: NAnnotation) {
    values[] = value
}

fun NAnnotationContainer.get(name: String): Optional<NAnnotation> {
    for value in values {
        if value.name == name {
            ret Some(value)
        }
    }

    ret None()
}

fun NAnnotationContainer.to_string(): String {
    let s = StringBuilder::new()

    for value in values {
        s[] = "$value\n"
    }

    ret s.to_string()
}

fun NAnnotation.get_arg(name: String): Optional<NValue> {
    for arg in args {
        if arg.key == name {
            ret Some(arg.value)
        }
    }

    ret None()
}

struct ExternAnnotation {
    lib: String
    name: String
}

fun NAnnotationContainer.get_extern_annotation(): Optional<ExternAnnotation> {
    let extern_annotation = get(ANNOTATION_EXTERN)
    if extern_annotation.is_none() {
        ret None()
    }

    let a: NAnnotation = extern_annotation!!
    let lib: Optional<NValue> = a.get_arg("lib")
    let name: Optional<NValue> = a.get_arg("name")

    if lib.is_none() || name.is_none() {
        ret None()
    }

    let lib_str: Optional<String> = lib!!.get_string()
    let name_str: Optional<String> = name!!.get_string()

    if lib_str.is_none() || name_str.is_none() {
        ret None()
    }

    ret Some(ExternAnnotation @[
        lib: lib_str!!,
        name: name_str!!,
    ])
}

struct AutogeneratedAnnotation {
    name: String
}

fun NAnnotationContainer.get_autogenerated_annotation(): Optional<AutogeneratedAnnotation> {
    let autogenerate_annotation = get(ANNOTATION_AUTOGENERATED)
    if autogenerate_annotation.is_none() {
        ret None()
    }

    let a: NAnnotation = autogenerate_annotation!!
    let name: Optional<NValue> = a.get_arg("name")

    if name.is_none() {
        ret None()
    }

    let name_str: Optional<String> = name!!.get_string()

    if name_str.is_none() {
        ret None()
    }

    ret Some(AutogeneratedAnnotation @[name: name_str!!])
}

struct WasmNameAnnotation {
    name: String
}

fun NAnnotationContainer.get_wasm_name_annotation(): Optional<WasmNameAnnotation> {
    let wasm_name_annotation = get(ANNOTATION_WASM_NAME)
    if wasm_name_annotation.is_none() {
        ret None()
    }

    let a: NAnnotation = wasm_name_annotation!!
    let name: Optional<NValue> = a.get_arg("name")

    if name.is_none() {
        ret None()
    }

    let name_str: Optional<String> = name!!.get_string()

    if name_str.is_none() {
        ret None()
    }

    ret Some(WasmNameAnnotation @[name: name_str!!])
}

struct IntrinsicSizeAnnotation {
    size: Int
}

fun NAnnotationContainer.get_intrinsic_size_annotation(): Optional<IntrinsicSizeAnnotation> {
    let intrinsic_size_annotation = get(ANNOTATION_INTRINSIC_SIZE)
    if intrinsic_size_annotation.is_none() {
        ret None()
    }

    let a: NAnnotation = intrinsic_size_annotation!!
    let size: Optional<NValue> = a.get_arg("size")

    if size.is_none() {
        ret None()
    }

    let size_opt: Optional<Int> = size!!.get_int()

    if size_opt.is_none() {
        ret None()
    }

    ret Some(IntrinsicSizeAnnotation @[size: size_opt!!])
}

struct OnlyIfAnnotation {
    target: String
}

fun NAnnotationContainer.get_only_if_annotation(): Optional<OnlyIfAnnotation> {
    let only_if_annotation = get("OnlyIf")
    if only_if_annotation.is_none() {
        ret None()
    }

    let a: NAnnotation = only_if_annotation!!
    let target: Optional<NValue> = a.get_arg("target")

    if target.is_none() {
        ret None()
    }

    let target_str: Optional<String> = target!!.get_string()

    if target_str.is_none() {
        ret None()
    }

    ret Some(OnlyIfAnnotation @[target: target_str!!])
}

struct CompilationFlag {
    name: String
    description: String
}

fun NAnnotationContainer.get_compilation_flag_annotation(): Optional<CompilationFlag> {
    let compilation_flag_annotation = get("CompilationFlag")
    if compilation_flag_annotation.is_none() {
        ret None()
    }

    let a: NAnnotation = compilation_flag_annotation!!
    let name: Optional<NValue> = a.get_arg("name")
    let description: Optional<NValue> = a.get_arg("description")

    if name.is_none() || description.is_none() {
        ret None()
    }

    let name_str: Optional<String> = name!!.get_string()
    let description_str: Optional<String> = description!!.get_string()

    if name_str.is_none() || description_str.is_none() {
        ret None()
    }

    ret Some(CompilationFlag @[name: name_str!!, description: description_str!!])
}

fun NAnnotationContainer.validate_annotations(collector: Reporter) {
    // TODO verify that the annotations contain the neccessary arguments
}

fun NAnnotation.to_string(): String {
    let s = StringBuilder::new()
    s[] = "@"
    s[] = name

    if args.len > 0 {
        s[] = " @[\n"
        let i = 0

        for arg in args {
            s[] = "  "
            s[] = arg.key
            s[] = ": "
            s[] = arg.value
            i += 1
            if i == args.len { s[] = ",\n" }
        }
        s[] = "]"
    }

    ret s.to_string()
}

fun ByteBuffer.serialize_annotation_container(value: NAnnotationContainer) {
    write_int(value.values.len)
    for a in value.values {
        serialize_annotation(a)
    }
}

fun ByteBuffer.deserialize_annotation_container(): NAnnotationContainer {
    let values = NAnnotationContainer::new()

    repeat read_int() {
        values[] = deserialize_annotation()
    }

    ret values
}

fun ByteBuffer.serialize_annotation(value: NAnnotation) {
    let frame = start_frame(true)
    serialize_span(value.span)
    write_string(value.name)
    write_int(value.args.len)

    for arg in value.args {
        serialize_annotation_arg(arg)
    }
    end_frame(frame)
}

fun ByteBuffer.deserialize_annotation(): NAnnotation {
    let frame = start_frame(false)
    let span = deserialize_span()
    let name = read_string()
    let args = []

    repeat read_int() {
        args[] = deserialize_annotation_arg()
    }

    end_frame(frame)

    ret NAnnotation @[span, name, args]
}

fun ByteBuffer.serialize_annotation_arg(value: NAnnotationArg) {
    serialize_span(value.span)
    write_string(value.key)
    serialize_nvalue(value.value)
}

fun ByteBuffer.deserialize_annotation_arg(): NAnnotationArg {
    let span = deserialize_span()
    let key = read_string()
    let value = deserialize_nvalue()

    ret NAnnotationArg @[span, key, value]
}

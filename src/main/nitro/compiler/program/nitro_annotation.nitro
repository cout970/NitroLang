
let ANNOTATION_TMP_RC: String = "Rc"
let ANNOTATION_NO_GC: String = "NoGC"
let ANNOTATION_EXTERN: String = "Extern"
let ANNOTATION_AUTOGENERATED: String = "Autogenerated"
let ANNOTATION_DEFAULT_IMPL: String = "DefaultImplementation"
let ANNOTATION_OVERRIDE: String = "Override"
let ANNOTATION_WASM_NAME: String = "WasmName"
let ANNOTATION_WASM_INLINE: String = "WasmInline"
let ANNOTATION_INTRINSIC: String = "Intrinsic"
let ANNOTATION_INTRINSIC_SIZE: String = "IntrinsicSize"
let ANNOTATION_INIT_PRIORITY: String = "InitPriority"
let ANNOTATION_DUMP_IR: String = "DumpIr"

struct NAnnotation {
    span: Span
    name: String
    args: List<NAnnotationArg>
}

struct NAnnotationArg {
    span: Span
    key: String
    value: NValue
}

fun NAnnotation.get_arg(name: String): Optional<NValue> {
    for arg in args {
        if arg.key == name {
            ret Some(arg.value)
        }
    }

    ret None()
}


struct ExternAnnotation {
    lib: String
    name: String
    autogenerate: Boolean
}

fun NFunction.get_extern_annotation(): Optional<ExternAnnotation> {
    let extern_annotation = get_annotation(ANNOTATION_EXTERN)
    if extern_annotation.is_none() {
        ret None()
    }

    let a: NAnnotation = extern_annotation!!
    let lib: Optional<NValue> = a.get_arg("lib")
    let name: Optional<NValue> = a.get_arg("name")

    if lib.is_none() || name.is_none() {
        ret None()
    }

    let lib_str: Optional<String> = lib!!.get_string()
    let name_str: Optional<String> = name!!.get_string()

    if lib_str.is_none() || name_str.is_none() {
        ret None()
    }

    let autogenerate: Boolean = false
    let autogenerate_arg: Optional<NValue> = a.get_arg("autogenerate")

    if autogenerate_arg.is_some() && autogenerate_arg!!.get_boolean().is_some() {
        autogenerate = autogenerate_arg!!.get_boolean()!!
    }

    ret Some(ExternAnnotation @[
        lib: lib_str!!,
        name: name_str!!,
        autogenerate,
    ])
}

struct AutogeneratedAnnotation {
    name: String
}

fun NFunction.get_autogenerated_annotation(): Optional<AutogeneratedAnnotation> {
    let autogenerate_annotation = get_annotation(ANNOTATION_AUTOGENERATED)
    if autogenerate_annotation.is_none() {
        ret None()
    }

    let a: NAnnotation = autogenerate_annotation!!
    let name: Optional<NValue> = a.get_arg("name")

    if name.is_none() {
        ret None()
    }

    let name_str: Optional<String> = name!!.get_string()

    if name_str.is_none() {
        ret None()
    }

    ret Some(AutogeneratedAnnotation @[name: name_str!!])
}

struct WasmNameAnnotation {
    name: String
}

fun NFunction.get_wasm_name_annotation(): Optional<WasmNameAnnotation> {
    let wasm_name_annotation = get_annotation(ANNOTATION_WASM_NAME)
    if wasm_name_annotation.is_none() {
        ret None()
    }

    let a: NAnnotation = wasm_name_annotation!!
    let name: Optional<NValue> = a.get_arg("name")

    if name.is_none() {
        ret None()
    }

    let name_str: Optional<String> = name!!.get_string()

    if name_str.is_none() {
        ret None()
    }

    ret Some(WasmNameAnnotation @[name: name_str!!])
}

struct IntrinsicSizeAnnotation {
    size: Int
}

fun NStruct.get_intrinsic_size_annotation(): Optional<IntrinsicSizeAnnotation> {
    let intrinsic_size_annotation = get_annotation(ANNOTATION_INTRINSIC_SIZE)
    if intrinsic_size_annotation.is_none() {
        ret None()
    }

    let a: NAnnotation = intrinsic_size_annotation!!
    let size: Optional<NValue> = a.get_arg("size")

    if size.is_none() {
        ret None()
    }

    let size_opt: Optional<Int> = size!!.get_int()

    if size_opt.is_none() {
        ret None()
    }

    ret Some(IntrinsicSizeAnnotation @[size: size_opt!!])
}

fun NAnnotation.to_string(): String {
    let s = "@$name"

    if args.len > 0 {
        s += " @[\n"

        for arg in args {
            s += "  ${arg.key}: ${arg.value},\n"
        }
        s += "]"
    }

    ret s
}

fun ByteBuffer.serialize_annotation(value: NAnnotation) {
    let frame = start_frame(true)
    serialize_span(value.span)
    write_string(value.name)
    write_int(value.args.len)

    for arg in value.args {
        serialize_annotation_arg(arg)
    }
    end_frame(frame)
}

fun ByteBuffer.deserialize_annotation(): NAnnotation {
    let frame = start_frame(false)
    let span = deserialize_span()
    let name = read_string()
    let args = []

    repeat read_int() {
        args[] = deserialize_annotation_arg()
    }

    end_frame(frame)

    ret NAnnotation @[span, name, args]
}

fun ByteBuffer.serialize_annotation_arg(value: NAnnotationArg) {
    serialize_span(value.span)
    write_string(value.key)
    serialize_nvalue(value.value)
}

fun ByteBuffer.deserialize_annotation_arg(): NAnnotationArg {
    let span = deserialize_span()
    let key = read_string()
    let value = deserialize_nvalue()

    ret NAnnotationArg @[span, key, value]
}
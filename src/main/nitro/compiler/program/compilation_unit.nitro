
struct CompilationUnit {
    reporter: Reporter
    included_paths: List<String>
    program: Program
    use_cache: Boolean
}

fun CompilationUnit::new(): CompilationUnit {
    ret CompilationUnit @[
        reporter: Reporter::new(),
        included_paths: [],
        program: Program::new(),
        use_cache: true
    ]
}

fun CompilationUnit.include_file(path: String) {
    if path in included_paths {
        ret
    }
    included_paths[] = path

    let last_modified: Int = FilePath::new(path).unsafe_debug_last_modified()
    let source: Optional<String> = None()

    // Load from cache
    if false /*use_cache*/ {
        let start = Instant::now()
        let file_path = get_cache_file_path(path)

        if file_path.exists()!! {
            let bytes: Array<Byte> = file_path.unsafe_debug_read_bytes()
            let bytes_list = List @[
                capacity: bytes.len,
                count: bytes.len,
                items: bytes
            ]
            let buffer = ByteBuffer::new(bytes_list)
            buffer.start_read()

            // Header
            let cache_version = buffer.reader.read_int_be()
            let cache_time = buffer.reader.read_int_be()
            let cache_crc = buffer.reader.read_int_be()
            let cache_last_modified = buffer.reader.read_int_be()
            let valid = true

            if cache_version != 0x01 {
                println("Ignoring cache file: $path, invalid version: $cache_version")
                valid = false
            }

            if valid && last_modified != cache_last_modified {
                println("Ignoring cache file: $path, last modified mismatch: $last_modified != $cache_last_modified")
                valid = false
            }

            // No way to check if the file was modified, other than comparing the hash of contents
            if valid && (last_modified == 0 || cache_last_modified == 0) {
                let source = Some(FilePath::new(path).read_text()!!)

                if CRC32::from_string(source!!) != cache_crc {
                    println("Ignoring cache file: $path, CRC mismatch")
                    valid = false
                }
            }

            if valid {
                let sub_program = buffer.deserialize_program()
//                program.extend_with(sub_program)
                let end = Instant::now()
//                Log::debug("Included file (cached): $path in ${(end - start).to_milliseconds()} ms")
            }
        }
    }



    if source.is_none() {
        source = Some(FilePath::new(path).read_text()!!)
    }

    let sub_program = include_source(source!!, path)

    // Save to cache
    if use_cache {
        let buffer = ByteBuffer::new()

        // Header
        buffer.writer.add_int_be(0x01)
        buffer.writer.add_int_be(Instant::now().unix_timestamp.to_int())
        buffer.writer.add_int_be(CRC32::from_string(source!!))
        buffer.writer.add_int_be(last_modified)
        // Content
        buffer.serialize_program(sub_program)
        let bytes = buffer.finish_write()
        let file_path = get_cache_file_path(path)
        file_path.unsafe_debug_write_bytes(bytes.items, bytes.len)
    }
}

fun CompilationUnit.get_cache_file_path(path: String): FilePath {
    let invalid_chars = [".", "/", "\\", ":", "*", "?", "\"", "<", ">", "|", " "]
    let safe_path = path

    if safe_path.starts_with("..") {
        safe_path = safe_path.substring(2, safe_path.bytes_len)
    }
    if safe_path.starts_with("/") {
        safe_path = safe_path.substring(1, safe_path.bytes_len)
    }
    if safe_path.starts_with("../") {
        safe_path = safe_path.substring(3, safe_path.bytes_len)
    }
    if safe_path.starts_with("./") {
        safe_path = safe_path.substring(2, safe_path.bytes_len)
    }
    if safe_path.ends_with(".nitro") {
        safe_path = safe_path.substring(0, safe_path.bytes_len - 6)
    }
    for c in invalid_chars {
        safe_path = safe_path.replace(c, "_")
    }
    return FilePath::new("cache/$safe_path.bin")
}

fun CompilationUnit.include_source(source: String, path: String): Program {
    let start = Instant::now()
    let sub_program = Program::new()

    let lexer = Lexer::new(source, path)
    lexer.read_all()

    let parser = Parser::new(lexer, reporter, sub_program)
    parser.read_file()

    for inc in sub_program.includes {
        let include_path = CompilationUnit::process_path(inc.path, path)
        include_file(include_path)
    }

    program.extend_with(sub_program)
    let end = Instant::now()
//    Log::debug("Included file: $path in ${(end - start).to_milliseconds()} ms")
    ret sub_program
}

fun CompilationUnit::process_path(path: String, current_path: String): String {
    if ":" in path {
        path = path.split(":")[1]!!
    }

    let dir = FilePath::directory_name(current_path)
    ret FilePath::join(dir, path)
}

fun CompilationUnit.check_types() {
    let type_checker = TypeChecker::new(reporter, program)
    type_checker.check_all()
}

fun CompilationUnit.compile() {
    let backend = WasmBackend::new(reporter, program)
    backend.compile_program()

    let buffer = backend.emitter.buffer

    // Temporary for debugging
    if backend.emitter.debug_print {
        println(backend.emitter.debug_buffer.to_string())
    }

    /*
    let sb = StringBuilder::new()

    repeat buffer.len {
        let value = buffer[it]!!.to_int()

        if value < 16 {
            sb[] = "0"
        }
        sb.add_int_in_base(16, value)

        if it % 16 == 15 {
            sb[] = "\n"
        } else {
            sb[] = " "
        }
    }

    // Use `cat output.wasm.hex | xxd -r -p > output.wasm ; wasm2wat -o output.wat output.wasm` to get the wat file
    FilePath::new("output.wasm.hex").write_text(sb.to_string())!!
    */

    if !FilePath::new("output.wasm").unsafe_debug_write_bytes(buffer.items, buffer.len) {
        crash("Unable to write output.wasm")
    }
}
